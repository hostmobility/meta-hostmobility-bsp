From a329e715110060e348d05a56cc5d2e2a0720f459 Mon Sep 17 00:00:00 2001
From: rikardo <rikard.olander@hostmobility.com>
Date: Tue, 3 Sep 2019 12:33:25 +0200
Subject: [PATCH] Add support for thermal throttling
support both tegra20 and tegra30 from 4.18 patch.


---
 Documentation/cpu-freq/core.txt          |   2 +-
 Documentation/cpu-freq/cpufreq-stats.txt |   8 +-
 arch/arm/boot/dts/tegra30.dtsi           | 842 ++++++++++++++++++++++++++++++-
 arch/arm/mach-tegra/tegra.c              |   4 +
 drivers/cpufreq/Kconfig.arm              |   6 +-
 drivers/cpufreq/cpufreq-dt-platdev.c     |   3 +
 drivers/cpufreq/cpufreq-dt.c             |   2 +-
 drivers/cpufreq/tegra20-cpufreq.c        | 704 +++++++++++++++++++++-----
 drivers/opp/core.c                       |   9 +-
 drivers/soc/tegra/fuse/tegra-apbmisc.c   |   1 +
 include/linux/pm_opp.h                   |   4 +-
 11 files changed, 1446 insertions(+), 139 deletions(-)

diff --git a/Documentation/cpu-freq/core.txt b/Documentation/cpu-freq/core.txt
index 073f128..55193e6 100644
--- a/Documentation/cpu-freq/core.txt
+++ b/Documentation/cpu-freq/core.txt
@@ -95,7 +95,7 @@ flags	- flags of the cpufreq driver
 
 3. CPUFreq Table Generation with Operating Performance Point (OPP)
 ==================================================================
-For details about OPP, see Documentation/power/opp.txt
+For details about OPP, see Documentation/power/opp.rst
 
 dev_pm_opp_init_cpufreq_table -
 	This function provides a ready to use conversion routine to translate
diff --git a/Documentation/cpu-freq/cpufreq-stats.txt b/Documentation/cpu-freq/cpufreq-stats.txt
index a873855..14378ce 100644
--- a/Documentation/cpu-freq/cpufreq-stats.txt
+++ b/Documentation/cpu-freq/cpufreq-stats.txt
@@ -86,9 +86,11 @@ transitions.
 This will give a fine grained information about all the CPU frequency
 transitions. The cat output here is a two dimensional matrix, where an entry
 <i,j> (row i, column j) represents the count of number of transitions from 
-Freq_i to Freq_j. Freq_i is in descending order with increasing rows and 
-Freq_j is in descending order with increasing columns. The output here also 
-contains the actual freq values for each row and column for better readability.
+Freq_i to Freq_j. Freq_i rows and Freq_j columns follow the sorting order in
+which the driver has provided the frequency table initially to the cpufreq core
+and so can be sorted (ascending or descending) or unsorted.  The output here
+also contains the actual freq values for each row and column for better
+readability.
 
 If the transition table is bigger than PAGE_SIZE, reading this will
 return an -EFBIG error.
diff --git a/arch/arm/boot/dts/tegra30.dtsi b/arch/arm/boot/dts/tegra30.dtsi
index a6781f6..2cfa25a 100644
--- a/arch/arm/boot/dts/tegra30.dtsi
+++ b/arch/arm/boot/dts/tegra30.dtsi
@@ -4,6 +4,7 @@
 #include <dt-bindings/memory/tegra30-mc.h>
 #include <dt-bindings/pinctrl/pinctrl-tegra.h>
 #include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <dt-bindings/thermal/thermal.h>
 
 / {
 	compatible = "nvidia,tegra30";
@@ -896,7 +897,7 @@
 		nvidia,elastic-limit = <16>;
 		nvidia,term-range-adj = <6>;
 		nvidia,xcvr-setup = <51>;
-		nvidia.xcvr-setup-use-fuses;
+		nvidia,xcvr-setup-use-fuses;
 		nvidia,xcvr-lsfslew = <1>;
 		nvidia,xcvr-lsrslew = <1>;
 		nvidia,xcvr-hsslew = <32>;
@@ -933,7 +934,7 @@
 		nvidia,elastic-limit = <16>;
 		nvidia,term-range-adj = <6>;
 		nvidia,xcvr-setup = <51>;
-		nvidia.xcvr-setup-use-fuses;
+		nvidia,xcvr-setup-use-fuses;
 		nvidia,xcvr-lsfslew = <2>;
 		nvidia,xcvr-lsrslew = <2>;
 		nvidia,xcvr-hsslew = <32>;
@@ -969,7 +970,7 @@
 		nvidia,elastic-limit = <16>;
 		nvidia,term-range-adj = <6>;
 		nvidia,xcvr-setup = <51>;
-		nvidia.xcvr-setup-use-fuses;
+		nvidia,xcvr-setup-use-fuses;
 		nvidia,xcvr-lsfslew = <2>;
 		nvidia,xcvr-lsrslew = <2>;
 		nvidia,xcvr-hsslew = <32>;
@@ -978,32 +979,855 @@
 		status = "disabled";
 	};
 
+	cpu0_opp_table: opp_table0 {
+		compatible = "operating-points-v2";
+		opp-shared;
+		/*Tegra30 v1.1A is <0x08 0x0001>; other values is other tegra30 variants*/
+		opp@460000000_800 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <800000 800000 1250000>;
+			opp-supported-hw = <0x01 0x0192>; /*can not recover from this freq(0x08 0x0001)!*/
+			opp-hz = /bits/ 64 <460000000>;
+		};
+
+		opp@480000000_800 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <800000 800000 1250000>;
+			opp-supported-hw = <0x02 0x019E>;
+			opp-hz = /bits/ 64 <480000000>;
+		};
+
+		opp@520000000_800 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <800000 800000 1250000>;
+			opp-supported-hw = <0x08 0x0001>; 
+			opp-hz = /bits/ 64 <520000000>;
+		};
+
+		opp@550000000_800 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <800000 800000 1250000>;
+			opp-supported-hw = <0x18 0x31FE>;
+			opp-hz = /bits/ 64 <550000000>;
+		};
+
+		opp@550000000_850 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <850000 850000 1250000>;
+			opp-supported-hw = <0x01 0x0192>;
+			opp-hz = /bits/ 64 <550000000>;
+		};
+
+		opp@600000000_850 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <850000 850000 1250000>;
+			opp-supported-hw = <0x08 0x0001>;
+			opp-hz = /bits/ 64 <600000000>;
+		};
+
+		opp@650000000_850 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <850000 850000 1250000>;
+			opp-supported-hw = <0x02 0x019E>;
+			opp-hz = /bits/ 64 <650000000>;
+		};
+
+		opp@680000000_900 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <900000 900000 1250000>;
+			opp-supported-hw = <0x01 0x0192>;
+			opp-hz = /bits/ 64 <680000000>;
+		};
+
+		opp@684000000_850 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <850000 850000 1250000>;
+			opp-supported-hw = <0x01 0x0001>;
+			opp-hz = /bits/ 64 <684000000>;
+		};
+
+		opp@700000000_850 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <850000 850000 1250000>;
+			opp-supported-hw = <0x04 0x019E>;
+			opp-hz = /bits/ 64 <700000000>;
+		};
+
+		opp@770000000_850 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <850000 850000 1250000>;
+			opp-supported-hw = <0x18 0x31FE>;
+			opp-hz = /bits/ 64 <770000000>;
+		};
+
+		opp@780000000_900 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <900000 900000 1250000>;
+			opp-supported-hw = <0x02 0x019E>;
+			opp-hz = /bits/ 64 <780000000>;
+		};
+
+		opp@807000000_850 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <850000 850000 1250000>;
+			opp-supported-hw = <0x02 0x0001>;
+			opp-hz = /bits/ 64 <807000000>;
+		};
+
+		opp@817000000_900 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <900000 900000 1250000>;
+			opp-supported-hw = <0x01 0x0001>;
+			opp-hz = /bits/ 64 <817000000>;
+		};
+
+		opp@820000000_975 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <975000 975000 1250000>;
+			opp-supported-hw = <0x01 0x0192>;
+			opp-hz = /bits/ 64 <820000000>;
+		};
+
+		opp@860000000_900 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <900000 900000 1250000>;
+			opp-supported-hw = <0x08 0x0001>;
+			opp-hz = /bits/ 64 <860000000>;
+		};
+
+		opp@883000000_850 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <850000 850000 1250000>;
+			opp-supported-hw = <0x04 0x0001>;
+			opp-hz = /bits/ 64 <883000000>;
+		};
+
+		opp@900000000_850 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <850000 850000 1250000>;
+			opp-supported-hw = <0x1F 0x0400>;
+			opp-hz = /bits/ 64 <900000000>;
+		};
+
+		opp@900000000_912 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <912000 912000 1250000>;
+			opp-supported-hw = <0x1F 0x0200>;
+			opp-hz = /bits/ 64 <900000000>;
+		};
+
+		opp@910000000_900 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <900000 900000 1250000>;
+			opp-supported-hw = <0x08 0x31FE>;
+			opp-hz = /bits/ 64 <910000000>;
+		};
+
+		opp@931000000_850 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <850000 850000 1250000>;
+			opp-supported-hw = <0x08 0x0001>;
+			opp-hz = /bits/ 64 <931000000>;
+		};
+
+		opp@940000000_900 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <900000 900000 1250000>;
+			opp-supported-hw = <0x10 0x31E0>;
+			opp-hz = /bits/ 64 <940000000>;
+		};
+
+		opp@948000000_900 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <900000 900000 1250000>;
+			opp-supported-hw = <0x02 0x0001>;
+			opp-hz = /bits/ 64 <948000000>;
+		};
+
+		opp@970000000_1000 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1000000 1000000 1250000>;
+			opp-supported-hw = <0x01 0x0192>;
+			opp-hz = /bits/ 64 <970000000>;
+		};
+
+		opp@990000000_975 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <975000 975000 1250000>;
+			opp-supported-hw = <0x02 0x019E>;
+			opp-hz = /bits/ 64 <990000000>;
+		};
+
+		opp@1026000000_975 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <975000 975000 1250000>;
+			opp-supported-hw = <0x08 0x0001>;
+			opp-hz = /bits/ 64 <1026000000>;
+		};
+
+		opp@1039000000_900 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <900000 900000 1250000>;
+			opp-supported-hw = <0x04 0x0001>;
+			opp-hz = /bits/ 64 <1039000000>;
+		};
+
+		opp@1040000000_1000 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1000000 1000000 1250000>;
+			opp-supported-hw = <0x02 0x019E>;
+			opp-hz = /bits/ 64 <1040000000>;
+		};
+
+		opp@1040000000_1025 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1025000 1025000 1250000>;
+			opp-supported-hw = <0x01 0x0192>;
+			opp-hz = /bits/ 64 <1040000000>;
+		};
+
+		opp@1050000000_975 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <975000 975000 1250000>;
+			opp-supported-hw = <0x04 0x019E>;
+			opp-hz = /bits/ 64 <1050000000>;
+		};
+
+		opp@1080000000_1050 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1050000 1050000 1250000>;
+			opp-supported-hw = <0x01 0x0192>;
+			opp-hz = /bits/ 64 <1080000000>;
+		};
+
+		opp@1100000000_1025 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1025000 1025000 1250000>;
+			opp-supported-hw = <0x02 0x019E>;
+			opp-hz = /bits/ 64 <1100000000>;
+		};
+
+		opp@1102000000_900 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <900000 900000 1250000>;
+			opp-supported-hw = <0x08 0x0001>;
+			opp-hz = /bits/ 64 <1102000000>;
+		};
+
+		opp@1102000000_1000 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1000000 1000000 1250000>;
+			opp-supported-hw = <0x01 0x0001>;
+			opp-hz = /bits/ 64 <1102000000>;
+		};
+
+		opp@1117000000_975 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <975000 975000 1250000>;
+			opp-supported-hw = <0x02 0x0001>;
+			opp-hz = /bits/ 64 <1117000000>;
+		};
+
+		opp@1149000000_1025 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1025000 1025000 1250000>;
+			opp-supported-hw = <0x01 0x0001>;
+			opp-hz = /bits/ 64 <1149000000>;
+		};
+
+		opp@1150000000_975 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <975000 975000 1250000>;
+			opp-supported-hw = <0x08 0x31FE>;
+			opp-hz = /bits/ 64 <1150000000>;
+		};
+
+		opp@1150000000_1000 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1000000 1000000 1250000>;
+			opp-supported-hw = <0x04 0x019E>;
+			opp-hz = /bits/ 64 <1150000000>;
+		};
+
+		opp@1150000000_1075 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1075000 1075000 1250000>;
+			opp-supported-hw = <0x01 0x0192>;
+			opp-hz = /bits/ 64 <1150000000>;
+		};
+
+		opp@1160000000_975 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <975000 975000 1250000>;
+			opp-supported-hw = <0x10 0x31E0>;
+			opp-hz = /bits/ 64 <1160000000>;
+		};
+
+		opp@1171000000_1000 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1000000 1000000 1250000>;
+			opp-supported-hw = <0x02 0x0001>;
+			opp-hz = /bits/ 64 <1171000000>;
+		};
+
+		opp@1178000000_975 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <975000 975000 1250000>;
+			opp-supported-hw = <0x04 0x0001>;
+			opp-hz = /bits/ 64 <1178000000>;
+		};
+
+		opp@1187000000_1050 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1050000 1050000 1250000>;
+			opp-supported-hw = <0x01 0x0001>;
+			opp-hz = /bits/ 64 <1187000000>;
+		};
+
+		opp@1200000000_1025 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1025000 1025000 1250000>;
+			opp-supported-hw = <0x04 0x019E>;
+			opp-hz = /bits/ 64 <1200000000>;
+		};
+
+		opp@1200000000_1050 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1050000 1050000 1250000>;
+			opp-supported-hw = <0x02 0x019E>;
+			opp-hz = /bits/ 64 <1200000000>;
+		};
+
+		opp@1200000000_1100 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1100000 1100000 1250000>;
+			opp-supported-hw = <0x01 0x0192>;
+			opp-hz = /bits/ 64 <1200000000>;
+		};
+
+		opp@1206000000_1000 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1000000 1000000 1250000>;
+			opp-supported-hw = <0x04 0x0001>;
+			opp-hz = /bits/ 64 <1206000000>;
+		};
+
+		opp@1206000000_1025 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1025000 1025000 1250000>;
+			opp-supported-hw = <0x02 0x0001>;
+			opp-hz = /bits/ 64 <1206000000>;
+		};
+
+		opp@1216000000_975 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <975000 975000 1250000>;
+			opp-supported-hw = <0x08 0x0001>;
+			opp-hz = /bits/ 64 <1216000000>;
+		};
+
+		opp@1225000000_1075 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1075000 1075000 1250000>;
+			opp-supported-hw = <0x01 0x0001>;
+			opp-hz = /bits/ 64 <1225000000>;
+		};
+
+		opp@1230000000_1000 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1000000 1000000 1250000>;
+			opp-supported-hw = <0x08 0x31FE>;
+			opp-hz = /bits/ 64 <1230000000>;
+		};
+
+		opp@1240000000_1000 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1000000 1000000 1250000>;
+			opp-supported-hw = <0x10 0x3060>;
+			opp-hz = /bits/ 64 <1240000000>;
+		};
+
+		opp@1240000000_1125 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1125000 1125000 1250000>;
+			opp-supported-hw = <0x01 0x0010>;
+			opp-hz = /bits/ 64 <1240000000>;
+		};
+
+		opp@1250000000_1075 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1075000 1075000 1250000>;
+			opp-supported-hw = <0x02 0x001C>;
+			opp-hz = /bits/ 64 <1250000000>;
+		};
+
+		opp@1280000000_1025 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1025000 1025000 1250000>;
+			opp-supported-hw = <0x18 0x307C>;
+			opp-hz = /bits/ 64 <1280000000>;
+		};
+
+		opp@1280000000_1050 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1050000 1050000 1250000>;
+			opp-supported-hw = <0x04 0x001C>;
+			opp-hz = /bits/ 64 <1280000000>;
+		};
+
+		opp@1280000000_1125 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1125000 1125000 1250000>;
+			opp-supported-hw = <0x01 0x0182>;
+			opp-hz = /bits/ 64 <1280000000>;
+		};
+
+		opp@1280000000_1150 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1150000 1150000 1250000>;
+			opp-supported-hw = <0x01 0x0010>;
+			opp-hz = /bits/ 64 <1280000000>;
+		};
+
+		opp@1282000000_1100 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1100000 1100000 1250000>;
+			opp-supported-hw = <0x01 0x0001>;
+			opp-hz = /bits/ 64 <1282000000>;
+		};
+
+		opp@1300000000_1000_3_0 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1000000 1000000 1250000>;
+			opp-supported-hw = <0x08 0x0001>;
+			opp-hz = /bits/ 64 <1300000000>;
+		};
+
+		opp@1300000000_1000 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1000000 1000000 1250000>;
+			opp-supported-hw = <0x10 0x0180>;
+			opp-hz = /bits/ 64 <1300000000>;
+		};
+
+		opp@1300000000_1025_2_0 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1025000 1025000 1250000>;
+			opp-supported-hw = <0x04 0x0001>;
+			opp-hz = /bits/ 64 <1300000000>;
+		};
+
+		opp@1300000000_1025_3_1 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1025000 1025000 1250000>;
+			opp-supported-hw = <0x08 0x0002>;
+			opp-hz = /bits/ 64 <1300000000>;
+		};
+
+		opp@1300000000_1025_3_7 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1025000 1025000 1250000>;
+			opp-supported-hw = <0x08 0x0080>;
+			opp-hz = /bits/ 64 <1300000000>;
+		};
+
+		opp@1300000000_1025_3_8 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1025000 1025000 1250000>;
+			opp-supported-hw = <0x08 0x0100>;
+			opp-hz = /bits/ 64 <1300000000>;
+		};
+
+		opp@1300000000_1050_1_0 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1050000 1050000 1250000>;
+			opp-supported-hw = <0x02 0x0001>;
+			opp-hz = /bits/ 64 <1300000000>;
+		};
+
+		opp@1300000000_1050_2_1 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1050000 1050000 1250000>;
+			opp-supported-hw = <0x04 0x0002>;
+			opp-hz = /bits/ 64 <1300000000>;
+		};
+
+		opp@1300000000_1050_3_2 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1050000 1050000 1250000>;
+			opp-supported-hw = <0x08 0x0004>;
+			opp-hz = /bits/ 64 <1300000000>;
+		};
+
+		opp@1300000000_1050_3_3 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1050000 1050000 1250000>;
+			opp-supported-hw = <0x08 0x0008>;
+			opp-hz = /bits/ 64 <1300000000>;
+		};
+
+		opp@1300000000_1050_2_7 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1050000 1050000 1250000>;
+			opp-supported-hw = <0x04 0x0080>;
+			opp-hz = /bits/ 64 <1300000000>;
+		};
+
+		opp@1300000000_1050_2_8 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1050000 1050000 1250000>;
+			opp-supported-hw = <0x04 0x0100>;
+			opp-hz = /bits/ 64 <1300000000>;
+		};
+
+		opp@1300000000_1075_1_1 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1075000 1075000 1250000>;
+			opp-supported-hw = <0x02 0x0002>;
+			opp-hz = /bits/ 64 <1300000000>;
+		};
+
+		opp@1300000000_1075_2_2 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1075000 1075000 1250000>;
+			opp-supported-hw = <0x04 0x0004>;
+			opp-hz = /bits/ 64 <1300000000>;
+		};
+
+		opp@1300000000_1075_2_3 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1075000 1075000 1250000>;
+			opp-supported-hw = <0x04 0x0008>;
+			opp-hz = /bits/ 64 <1300000000>;
+		};
+
+		opp@1300000000_1075_2_4 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1075000 1075000 1250000>;
+			opp-supported-hw = <0x04 0x0010>;
+			opp-hz = /bits/ 64 <1300000000>;
+		};
+
+		opp@1300000000_1075_1_7 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1075000 1075000 1250000>;
+			opp-supported-hw = <0x02 0x0080>;
+			opp-hz = /bits/ 64 <1300000000>;
+		};
+
+		opp@1300000000_1075_1_8 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1075000 1075000 1250000>;
+			opp-supported-hw = <0x02 0x0100>;
+			opp-hz = /bits/ 64 <1300000000>;
+		};
+
+		opp@1300000000_1100_1_2 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1100000 1100000 1250000>;
+			opp-supported-hw = <0x02 0x0004>;
+			opp-hz = /bits/ 64 <1300000000>;
+		};
+
+		opp@1300000000_1100_1_3 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1100000 1100000 1250000>;
+			opp-supported-hw = <0x02 0x0008>;
+			opp-hz = /bits/ 64 <1300000000>;
+		};
+
+		opp@1300000000_1100_1_4 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1100000 1100000 1250000>;
+			opp-supported-hw = <0x02 0x0010>;
+			opp-hz = /bits/ 64 <1300000000>;
+		};
+
+		opp@1300000000_1125 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1125000 1125000 1250000>;
+			opp-supported-hw = <0x01 0x0001>;
+			opp-hz = /bits/ 64 <1300000000>;
+		};
+
+		opp@1300000000_1150 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1150000 1150000 1250000>;
+			opp-supported-hw = <0x01 0x0182>;
+			opp-hz = /bits/ 64 <1300000000>;
+		};
+
+		opp@1320000000_1175 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1175000 1175000 1250000>;
+			opp-supported-hw = <0x01 0x0010>;
+			opp-hz = /bits/ 64 <1320000000>;
+		};
+
+		opp@1330000000_1050 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1050000 1050000 1250000>;
+			opp-supported-hw = <0x08 0x3070>;
+			opp-hz = /bits/ 64 <1330000000>;
+		};
+
+		opp@1330000000_1125 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1125000 1125000 1250000>;
+			opp-supported-hw = <0x02 0x001C>;
+			opp-hz = /bits/ 64 <1330000000>;
+		};
+
+		opp@1340000000_1100 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1100000 1100000 1250000>;
+			opp-supported-hw = <0x04 0x0010>;
+			opp-hz = /bits/ 64 <1340000000>;
+		};
+
+		opp@1350000000_1075 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1075000 1075000 1250000>;
+			opp-supported-hw = <0x08 0x000C>;
+			opp-hz = /bits/ 64 <1350000000>;
+		};
+
+		opp@1350000000_1100 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1100000 1100000 1250000>;
+			opp-supported-hw = <0x04 0x000C>;
+			opp-hz = /bits/ 64 <1350000000>;
+		};
+
+		opp@1360000000_1050 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1050000 1050000 1250000>;
+			opp-supported-hw = <0x10 0x3060>;
+			opp-hz = /bits/ 64 <1360000000>;
+		};
+
+		opp@1360000000_1150 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1150000 1150000 1250000>;
+			opp-supported-hw = <0x02 0x0010>;
+			opp-hz = /bits/ 64 <1360000000>;
+		};
+
+		opp@1360000000_1200 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1200000 1200000 1250000>;
+			opp-supported-hw = <0x01 0x0010>;
+			opp-hz = /bits/ 64 <1360000000>;
+		};
+
+		opp@1370000000_1075 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1075000 1075000 1250000>;
+			opp-supported-hw = <0x08 0x3070>;
+			opp-hz = /bits/ 64 <1370000000>;
+		};
+
+		opp@1380000000_1125 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1125000 1125000 1250000>;
+			opp-supported-hw = <0x04 0x0010>;
+			opp-hz = /bits/ 64 <1380000000>;
+		};
+
+		opp@1390000000_1075 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1075000 1075000 1250000>;
+			opp-supported-hw = <0x10 0x3060>;
+			opp-hz = /bits/ 64 <1390000000>;
+		};
+
+		opp@1400000000_1100 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1100000 1100000 1250000>;
+			opp-supported-hw = <0x08 0x307C>;
+			opp-hz = /bits/ 64 <1400000000>;
+		};
+
+		opp@1400000000_1125 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1125000 1125000 1250000>;
+			opp-supported-hw = <0x04 0x000C>;
+			opp-hz = /bits/ 64 <1400000000>;
+		};
+
+		opp@1400000000_1150 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1150000 1150000 1250000>;
+			opp-supported-hw = <0x02 0x000C>;
+			opp-hz = /bits/ 64 <1400000000>;
+		};
+
+		opp@1400000000_1175 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1175000 1175000 1250000>;
+			opp-supported-hw = <0x02 0x0010>;
+			opp-hz = /bits/ 64 <1400000000>;
+		};
+
+		opp@1470000000_1100 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1100000 1100000 1250000>;
+			opp-supported-hw = <0x10 0x3060>;
+			opp-hz = /bits/ 64 <1470000000>;
+		};
+
+		opp@1470000000_1125 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1125000 1125000 1250000>;
+			opp-supported-hw = <0x08 0x3060>;
+			opp-hz = /bits/ 64 <1470000000>;
+		};
+
+		opp@1500000000_1125_3_4 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1125000 1125000 1250000>;
+			opp-supported-hw = <0x08 0x0010>;
+			opp-hz = /bits/ 64 <1500000000>;
+		};
+
+		opp@1500000000_1125 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1125000 1125000 1250000>;
+			opp-supported-hw = <0x10 0x3060>;
+			opp-hz = /bits/ 64 <1500000000>;
+		};
+
+		opp@1500000000_1150 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1150000 1150000 1250000>;
+			opp-supported-hw = <0x04 0x0010>;
+			opp-hz = /bits/ 64 <1500000000>;
+		};
+
+		opp@1500000000_1150_3_5 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1150000 1150000 1250000>;
+			opp-supported-hw = <0x08 0x0020>;
+			opp-hz = /bits/ 64 <1500000000>;
+		};
+
+		opp@1500000000_1150_3_6 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1150000 1150000 1250000>;
+			opp-supported-hw = <0x08 0x0040>;
+			opp-hz = /bits/ 64 <1500000000>;
+		};
+
+		opp@1500000000_1150_3_12 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1150000 1150000 1250000>;
+			opp-supported-hw = <0x08 0x1000>;
+			opp-hz = /bits/ 64 <1500000000>;
+		};
+
+		opp@1500000000_1150_3_13 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1150000 1150000 1250000>;
+			opp-supported-hw = <0x08 0x2000>;
+			opp-hz = /bits/ 64 <1500000000>;
+		};
+
+		opp@1500000000_1200 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1200000 1200000 1250000>;
+			opp-supported-hw = <0x02 0x0010>;
+			opp-hz = /bits/ 64 <1500000000>;
+		};
+
+		opp@1500000000_1237 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1237000 1237000 1250000>;
+			opp-supported-hw = <0x01 0x0010>;
+			opp-hz = /bits/ 64 <1500000000>;
+		};
+
+		opp@1520000000_1150 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1150000 1150000 1250000>;
+			opp-supported-hw = <0x10 0x3060>;
+			opp-hz = /bits/ 64 <1520000000>;
+		};
+
+		opp@1540000000_1200 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1200000 1200000 1250000>;
+			opp-supported-hw = <0x08 0x3060>;
+			opp-hz = /bits/ 64 <1540000000>;
+		};
+
+		opp@1590000000_1200 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1200000 1200000 1250000>;
+			opp-supported-hw = <0x10 0x3060>;
+			opp-hz = /bits/ 64 <1590000000>;
+		};
+
+		opp@1700000000_1212 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1212000 1212000 1250000>;
+			opp-supported-hw = <0x10 0x3060>;
+			opp-hz = /bits/ 64 <1700000000>;
+		};
+
+		opp@1700000000_1237 {
+			clock-latency-ns = <100000>;
+			opp-microvolt = <1237000 1237000 1250000>;
+			opp-supported-hw = <0x08 0x3060>;
+			opp-hz = /bits/ 64 <1700000000>;
+		};
+	};
+
 	cpus {
 		#address-cells = <1>;
 		#size-cells = <0>;
 
-		cpu@0 {
+		cpu0: cpu@0 {
 			device_type = "cpu";
 			compatible = "arm,cortex-a9";
 			reg = <0>;
+			clocks = <&tegra_car TEGRA30_CLK_CCLK_G>;
+			operating-points-v2 = <&cpu0_opp_table>;
+			cooling-min-state = <0>;
+			cooling-max-state = <7>;
+			#cooling-cells = <2>;
 		};
 
-		cpu@1 {
+		cpu1: cpu@1 {
 			device_type = "cpu";
 			compatible = "arm,cortex-a9";
 			reg = <1>;
+			clocks = <&tegra_car TEGRA30_CLK_CCLK_G>;
+			operating-points-v2 = <&cpu0_opp_table>;
+			cooling-min-state = <0>;
+			cooling-max-state = <7>;
+			#cooling-cells = <2>;
 		};
 
-		cpu@2 {
+		cpu2: cpu@2 {
 			device_type = "cpu";
 			compatible = "arm,cortex-a9";
 			reg = <2>;
+			clocks = <&tegra_car TEGRA30_CLK_CCLK_G>;
+			operating-points-v2 = <&cpu0_opp_table>;
+			cooling-min-state = <0>;
+			cooling-max-state = <7>;
+			#cooling-cells = <2>;
 		};
 
-		cpu@3 {
+		cpu3: cpu@3 {
 			device_type = "cpu";
 			compatible = "arm,cortex-a9";
 			reg = <3>;
+			clocks = <&tegra_car TEGRA30_CLK_CCLK_G>;
+			operating-points-v2 = <&cpu0_opp_table>;
+			cooling-min-state = <0>;
+			cooling-max-state = <7>;
+			#cooling-cells = <2>;
 		};
 	};
 
@@ -1013,5 +1837,9 @@
 			     <GIC_SPI 145 IRQ_TYPE_LEVEL_HIGH>,
 			     <GIC_SPI 146 IRQ_TYPE_LEVEL_HIGH>,
 			     <GIC_SPI 147 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-affinity = <&{/cpus/cpu@0}>,
+				     <&{/cpus/cpu@1}>,
+				     <&{/cpus/cpu@2}>,
+				     <&{/cpus/cpu@3}>;
 	};
 };
diff --git a/arch/arm/mach-tegra/tegra.c b/arch/arm/mach-tegra/tegra.c
index f9587be..e82e839 100644
--- a/arch/arm/mach-tegra/tegra.c
+++ b/arch/arm/mach-tegra/tegra.c
@@ -101,6 +101,10 @@ static void __init tegra_dt_init_late(void)
 	if (IS_ENABLED(CONFIG_ARCH_TEGRA_2x_SOC) &&
 	    of_machine_is_compatible("nvidia,tegra20"))
 		platform_device_register_simple("tegra20-cpufreq", -1, NULL, 0);
+
+	if (IS_ENABLED(CONFIG_ARCH_TEGRA_3x_SOC) &&
+	    of_machine_is_compatible("nvidia,tegra30"))
+		platform_device_register_simple("tegra20-cpufreq", -1, NULL, 0);
 }
 
 static const char * const tegra_dt_board_compat[] = {
diff --git a/drivers/cpufreq/Kconfig.arm b/drivers/cpufreq/Kconfig.arm
index 0cd8eb7..6480d70 100644
--- a/drivers/cpufreq/Kconfig.arm
+++ b/drivers/cpufreq/Kconfig.arm
@@ -262,14 +262,16 @@ config ARM_TANGO_CPUFREQ
 
 config ARM_TEGRA20_CPUFREQ
 	tristate "Tegra20 CPUFreq support"
+	depends on !CPU_THERMAL || THERMAL
 	depends on ARCH_TEGRA
+	select PM_OPP
 	default y
 	help
 	  This adds the CPUFreq driver support for Tegra20 SOCs.
 
 config ARM_TEGRA124_CPUFREQ
-	tristate "Tegra124 CPUFreq support"
-	depends on ARCH_TEGRA && CPUFREQ_DT && REGULATOR
+	bool "Tegra124 CPUFreq support"
+	depends on ARCH_TEGRA && CPUFREQ_DT
 	default y
 	help
 	  This adds the CPUFreq driver support for Tegra124 SOCs.
diff --git a/drivers/cpufreq/cpufreq-dt-platdev.c b/drivers/cpufreq/cpufreq-dt-platdev.c
index fe14c57..c825b0b 100644
--- a/drivers/cpufreq/cpufreq-dt-platdev.c
+++ b/drivers/cpufreq/cpufreq-dt-platdev.c
@@ -114,6 +114,9 @@ static const struct of_device_id blacklist[] __initconst = {
 	{ .compatible = "mediatek,mt8173", },
 	{ .compatible = "mediatek,mt8176", },
 
+	{ .compatible = "nvidia,tegra20", },
+	{ .compatible = "nvidia,tegra30", },
+
 	{ .compatible = "nvidia,tegra124", },
 
 	{ .compatible = "qcom,apq8096", },
diff --git a/drivers/cpufreq/cpufreq-dt.c b/drivers/cpufreq/cpufreq-dt.c
index e58bfcb..7cd658f 100644
--- a/drivers/cpufreq/cpufreq-dt.c
+++ b/drivers/cpufreq/cpufreq-dt.c
@@ -196,7 +196,7 @@ static int cpufreq_init(struct cpufreq_policy *policy)
 	 */
 	name = find_supply_name(cpu_dev);
 	if (name) {
-		opp_table = dev_pm_opp_set_regulators(cpu_dev, &name, 1);
+		opp_table = dev_pm_opp_set_regulators(cpu_dev, &name, 1, false );
 		if (IS_ERR(opp_table)) {
 			ret = PTR_ERR(opp_table);
 			dev_err(cpu_dev, "Failed to set regulator for cpu%d: %d\n",
diff --git a/drivers/cpufreq/tegra20-cpufreq.c b/drivers/cpufreq/tegra20-cpufreq.c
index 05f57dc..33fd645 100644
--- a/drivers/cpufreq/tegra20-cpufreq.c
+++ b/drivers/cpufreq/tegra20-cpufreq.c
@@ -1,236 +1,698 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (C) 2010 Google, Inc.
  *
  * Author:
  *	Colin Cross <ccross@google.com>
  *	Based on arch/arm/plat-omap/cpu-omap.c, (C) 2005 Nokia Corporation
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
  */
 
 #include <linux/clk.h>
+#include <linux/cpu.h>
+#include <linux/cpu_cooling.h>
 #include <linux/cpufreq.h>
 #include <linux/err.h>
-#include <linux/init.h>
+#include <linux/ktime.h>
 #include <linux/module.h>
+#include <linux/of.h>
 #include <linux/platform_device.h>
+#include <linux/pm_opp.h>
+#include <linux/regulator/consumer.h>
 #include <linux/types.h>
-
-static struct cpufreq_frequency_table freq_table[] = {
-	{ .frequency = 216000 },
-	{ .frequency = 312000 },
-	{ .frequency = 456000 },
-	{ .frequency = 608000 },
-	{ .frequency = 760000 },
-	{ .frequency = 816000 },
-	{ .frequency = 912000 },
-	{ .frequency = 1000000 },
-	{ .frequency = CPUFREQ_TABLE_END },
+#include <linux/workqueue.h>
+
+#include <asm/smp_plat.h>
+#include <soc/tegra/fuse.h>
+
+#define PLLP			0
+#define PLLP_OUT4		1
+#define PLLP_OUT3		2
+#define PLLM			3
+#define PLLC			4
+#define PLLX			5
+
+static const char *tegra_parent_clocks[] =  {
+	[PLLP]		= "pll_p",
+	[PLLP_OUT4]	= "pll_p_out4",
+	[PLLP_OUT3]	= "pll_p_out3",
+	[PLLM]		= "pll_m",
+	[PLLC]		= "pll_c",
+	[PLLX]		= "pll_x",
 };
 
-struct tegra20_cpufreq {
+struct tegra_cpufreq {
 	struct device *dev;
+	struct device *cpu_dev;
+	struct regulator *reg_cpu;
+	struct opp_table *opp_table;
 	struct cpufreq_driver driver;
+	struct thermal_cooling_device *cdev;
+	struct cpufreq_frequency_table *freq_table;
 	struct clk *cpu_clk;
-	struct clk *pll_x_clk;
-	struct clk *pll_p_clk;
-	bool pll_x_prepared;
+	struct clk *intermediate_clk;
+	struct clk *parent_clk;
+	struct clk_bulk_data cpu_parents[ARRAY_SIZE(tegra_parent_clocks)];
+	unsigned long intermediate_rate;
+	unsigned int state;
+
+	/* deferred voltage change */
+	struct delayed_work work;
+	struct dev_pm_opp_supply supply_cpu;
+	unsigned long actual_cpu_uV;
+	unsigned long permitted_interim_rate;
+	ktime_t work_timeout;
+
+	/* deferred clocks disable */
+	ktime_t parent_clk_ktime[ARRAY_SIZE(tegra_parent_clocks)];
+	unsigned long parents_enabled;
 };
 
+/*
+ * Voltage changing usually introduces quite huge latency which is not
+ * taken into account by the governor, hence we will simply avoid the
+ * frequent voltage changes by deferring the voltage dropping.
+ */
+static unsigned int voltage_drop_interval_ms = 1000;
+
+static int tegra_prepare_parent_clock(struct tegra_cpufreq *cpufreq,
+				      unsigned int id)
+{
+	int err = 0;
+
+	cpufreq->parent_clk_ktime[id] = ktime_add_ms(ktime_get(), 300);
+
+	if (!test_bit(id, &cpufreq->parents_enabled)) {
+		err = clk_prepare_enable(cpufreq->cpu_parents[id].clk);
+		set_bit(id, &cpufreq->parents_enabled);
+	}
+
+	WARN_ON_ONCE(err);
+
+	return err;
+}
+
+static void tegra_unprepare_parent_clocks(struct tegra_cpufreq *cpufreq,
+					  bool force_disable)
+{
+	ktime_t time = ktime_get();
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(cpufreq->parent_clk_ktime); i++) {
+		if (!test_bit(i, &cpufreq->parents_enabled))
+			continue;
+
+		if (!force_disable &&
+		    ktime_before(time, cpufreq->parent_clk_ktime[i]))
+			continue;
+
+		clk_disable_unprepare(cpufreq->cpu_parents[i].clk);
+		clear_bit(i, &cpufreq->parents_enabled);
+	}
+}
+
+static struct clk *tegra_select_intermediate_clk(struct tegra_cpufreq *cpufreq)
+{
+	struct clk *parent, *best_intermediate = NULL;
+	long rate, permitted_rate, best_rate = 0;
+	unsigned int i, best_id = PLLP_OUT4;
+	int err;
+
+	cancel_delayed_work_sync(&cpufreq->work);
+
+	/*
+	 * CPU voltage is constrained to the parent's rate because CCLK
+	 * divider uses clock-skipping technique.
+	 */
+	parent = clk_get_parent(cpufreq->cpu_clk);
+	rate = clk_get_rate(parent);
+
+	/*
+	 * Until deferred voltage change comes into effect, we're allowed
+	 * to select faster transition rate.
+	 */
+	if (cpufreq->permitted_interim_rate > rate)
+		permitted_rate = cpufreq->permitted_interim_rate;
+	else
+		permitted_rate = rate;
+
+	WARN_ON_ONCE(permitted_rate <= 0);
+
+	for (i = 0; i < ARRAY_SIZE(cpufreq->cpu_parents); i++) {
+		if (i == PLLX)
+			continue;
+
+		/*
+		 * Make sure that intermediate clock rate stays consistent
+		 * during transition by entering into critical section of the
+		 * intermediate clock.
+		 */
+		err = clk_rate_exclusive_get(cpufreq->cpu_parents[i].clk);
+
+		if (WARN_ON_ONCE(err))
+			continue;
+
+		rate = clk_get_rate(cpufreq->cpu_parents[i].clk);
+
+		/*
+		 * Intermediate rate shall not be faster than the current CPU
+		 * freq because otherwise there is a solid chance to violate
+		 * voltage restriction.
+		 */
+		if (WARN_ON_ONCE(rate <= 0) || rate > permitted_rate)
+			goto exclusive_put;
+
+		if (rate <= best_rate)
+			goto exclusive_put;
+
+		clk_rate_exclusive_get(cpufreq->cpu_parents[i].clk);
+		best_intermediate = cpufreq->cpu_parents[i].clk;
+		best_rate = rate;
+		best_id = i;
+exclusive_put:
+		clk_rate_exclusive_put(cpufreq->cpu_parents[i].clk);
+	}
+
+	/*
+	 * PLLP should be suitable for all of reasonable clock rates and
+	 * voltages.
+	 */
+	if (!best_intermediate) {
+		best_intermediate = cpufreq->cpu_parents[best_id].clk;
+		err = clk_rate_exclusive_get(best_intermediate);
+		WARN_ON_ONCE(err);
+	}
+
+	tegra_prepare_parent_clock(cpufreq, best_id);
+
+	return best_intermediate;
+}
+
+static struct clk *tegra_select_parent_clk(struct tegra_cpufreq *cpufreq,
+					   unsigned long target_rate)
+{
+	long rate, pllx_min_rate, best_rate = ULONG_MAX;
+	struct clk *best_parent = NULL;
+	unsigned int i, best_id = PLLX;
+	int err;
+
+	/*
+	 * Note that only CPU is allowed to run off PLLX and clk_round_rate()
+	 * takes into account active CLK users in order to limit the rounded
+	 * min rate, but CPU is running off intermediate clock right now and
+	 * hence rounding returns the desired result.
+	 */
+	pllx_min_rate = clk_round_rate(cpufreq->cpu_parents[PLLX].clk, 460000000);/*Tegra could be less cpu freq but let this be the minimum*/
+	WARN_ON_ONCE(pllx_min_rate <= 0);
+
+	/*
+	 * Always prefer PLLX whenever possible because it's the main
+	 * CPU PLL.
+	 */
+	if (target_rate >= pllx_min_rate)
+		goto enable_clk;
+
+	/*
+	 * If target rate is lower than any of parents clock rates,
+	 * then CCLK divider should be utilized in order to achieve
+	 * the desired rate.  Note that divider use clock skipping
+	 * technique, hence CPU voltage still should be set in accordance
+	 * to the parents clock rate and *not* the divided CCLK(!).
+	 */
+	for (i = 0; i < ARRAY_SIZE(cpufreq->cpu_parents); i++) {
+		/* CCLK divider is in bypass mode if running off PLLX */
+		if (i == PLLX)
+			continue;
+
+		err = clk_rate_exclusive_get(cpufreq->cpu_parents[i].clk);
+
+		if (WARN_ON_ONCE(err))
+			continue;
+
+		rate = clk_get_rate(cpufreq->cpu_parents[i].clk);
+
+		if (WARN_ON_ONCE(rate <= 0) || rate < target_rate)
+			goto exclusive_put;
+
+		if (rate >= best_rate)
+			goto exclusive_put;
+
+		clk_rate_exclusive_get(cpufreq->cpu_parents[i].clk);
+		best_parent = cpufreq->cpu_parents[i].clk;
+		best_rate = rate;
+		best_id = i;
+exclusive_put:
+		clk_rate_exclusive_put(cpufreq->cpu_parents[i].clk);
+	}
+
+	if (WARN_ON_ONCE(!best_parent)) {
+		best_id = PLLP_OUT4;
+		best_parent = cpufreq->cpu_parents[best_id].clk;
+	}
+
+enable_clk:
+	tegra_prepare_parent_clock(cpufreq, best_id);
+
+	return best_parent;
+}
+
 static unsigned int tegra_get_intermediate(struct cpufreq_policy *policy,
 					   unsigned int index)
 {
-	struct tegra20_cpufreq *cpufreq = cpufreq_get_driver_data();
-	unsigned int ifreq = clk_get_rate(cpufreq->pll_p_clk) / 1000;
+	struct tegra_cpufreq *cpufreq = cpufreq_get_driver_data();
+	struct clk *cpu_parent = clk_get_parent(cpufreq->cpu_clk);
+
+	/* select fastest intermediate clock */
+	cpufreq->intermediate_clk = tegra_select_intermediate_clk(cpufreq);
 
 	/*
-	 * Don't switch to intermediate freq if:
-	 * - we are already at it, i.e. policy->cur == ifreq
-	 * - index corresponds to ifreq
+	 * When target rate is equal to intermediate rate, we don't need to
+	 * switch to intermediate clock and so the intermediate routine isn't
+	 * called.  Also, we wouldn't be using PLLX anymore and must not
+	 * take extra reference to it, as it can be disabled to save some
+	 * power.
 	 */
-	if (freq_table[index].frequency == ifreq || policy->cur == ifreq)
+	cpufreq->intermediate_rate = clk_get_rate(cpufreq->intermediate_clk);
+
+	/* don't switch to intermediate freq if we are already at it */
+	if (clk_is_match(cpu_parent, cpufreq->intermediate_clk))
 		return 0;
 
-	return ifreq;
+	return cpufreq->intermediate_rate / 1000;
 }
 
 static int tegra_target_intermediate(struct cpufreq_policy *policy,
 				     unsigned int index)
 {
-	struct tegra20_cpufreq *cpufreq = cpufreq_get_driver_data();
+	struct tegra_cpufreq *cpufreq = cpufreq_get_driver_data();
+	int err;
+
+	err = clk_set_parent(cpufreq->cpu_clk, cpufreq->intermediate_clk);
+	if (WARN_ON_ONCE(err))
+		goto err_exclusive_put;
+
+	err = clk_set_rate(cpufreq->cpu_clk, cpufreq->intermediate_rate);
+	if (err)
+		goto err_exclusive_put;
+
+	return 0;
+
+err_exclusive_put:
+	clk_rate_exclusive_put(cpufreq->intermediate_clk);
+
+	return err;
+}
+
+static int tegra_target(struct cpufreq_policy *policy, unsigned int index)
+{
+	struct tegra_cpufreq *cpufreq = cpufreq_get_driver_data();
+	unsigned long new_rate = cpufreq->freq_table[index].frequency * 1000;
 	int ret;
 
+	/* select most appropriate parent clock, NULL means PLLX */
+	cpufreq->parent_clk = tegra_select_parent_clk(cpufreq, new_rate);
+
 	/*
-	 * Take an extra reference to the main pll so it doesn't turn
-	 * off when we move the cpu off of it as enabling it again while we
-	 * switch to it from tegra_target() would take additional time.
-	 *
-	 * When target-freq is equal to intermediate freq we don't need to
-	 * switch to an intermediate freq and so this routine isn't called.
-	 * Also, we wouldn't be using pll_x anymore and must not take extra
-	 * reference to it, as it can be disabled now to save some power.
+	 * Switch to new OPP. Change PLLX rate, switch parent clock source
+	 * and toggle CCLK divider.
 	 */
-	clk_prepare_enable(cpufreq->pll_x_clk);
+	ret = dev_pm_opp_set_rate(cpufreq->cpu_dev, new_rate);
 
-	ret = clk_set_parent(cpufreq->cpu_clk, cpufreq->pll_p_clk);
-	if (ret)
-		clk_disable_unprepare(cpufreq->pll_x_clk);
-	else
-		cpufreq->pll_x_prepared = true;
+	clk_rate_exclusive_put(cpufreq->parent_clk);
+	clk_rate_exclusive_put(cpufreq->intermediate_clk);
+
+	tegra_unprepare_parent_clocks(cpufreq, false);
 
 	return ret;
 }
 
-static int tegra_target(struct cpufreq_policy *policy, unsigned int index)
+static int tegra_cpu_opp_set_cpu_voltage(struct tegra_cpufreq *cpufreq,
+					 struct dev_pm_opp_supply *supply)
 {
-	struct tegra20_cpufreq *cpufreq = cpufreq_get_driver_data();
-	unsigned long rate = freq_table[index].frequency;
-	unsigned int ifreq = clk_get_rate(cpufreq->pll_p_clk) / 1000;
 	int ret;
 
+	ret = regulator_count_voltages(cpufreq->reg_cpu);
+	if (ret < 0)
+		return ret;
+
 	/*
-	 * target freq == pll_p, don't need to take extra reference to pll_x_clk
-	 * as it isn't used anymore.
+	 * Nothing to do if regulator's voltage is fixed, this a case for
+	 * Tegra20 Trimslice which is outlet-powered device and it provides
+	 * a dummy-stub regulator.
 	 */
-	if (rate == ifreq)
-		return clk_set_parent(cpufreq->cpu_clk, cpufreq->pll_p_clk);
+	if (ret == 1)
+		return 0;
 
-	ret = clk_set_rate(cpufreq->pll_x_clk, rate * 1000);
-	/* Restore to earlier frequency on error, i.e. pll_x */
+	ret = regulator_set_voltage_triplet(cpufreq->reg_cpu,
+					    supply->u_volt_min,
+					    supply->u_volt,
+					    supply->u_volt_max);
 	if (ret)
-		dev_err(cpufreq->dev, "Failed to change pll_x to %lu\n", rate);
+		dev_err_ratelimited(cpufreq->dev,
+			"failed to set cpu voltage (%lu %lu %lu): %d\n",
+			supply->u_volt_min, supply->u_volt,
+			supply->u_volt_max, ret);
 
-	ret = clk_set_parent(cpufreq->cpu_clk, cpufreq->pll_x_clk);
-	/* This shouldn't fail while changing or restoring */
-	WARN_ON(ret);
+	return ret;
+}
+
+static void tegra_cpu_deferred_voltage_drop(struct work_struct *work)
+{
+	struct tegra_cpufreq *cpufreq = container_of(work, struct tegra_cpufreq,
+						     work.work);
+	int err;
+
+	err = tegra_cpu_opp_set_cpu_voltage(cpufreq, &cpufreq->supply_cpu);
+	if (err)
+		return;
+
+	cpufreq->actual_cpu_uV = cpufreq->supply_cpu.u_volt;
+	cpufreq->permitted_interim_rate = 0;
+	cpufreq->work_timeout = 0;
+
+	tegra_unprepare_parent_clocks(cpufreq, false);
+}
+
+static int tegra_cpu_opp_raise_voltage(struct tegra_cpufreq *cpufreq,
+				       struct dev_pm_opp_supply *supply_cpu)
+{
+	int err;
+
+	err = tegra_cpu_opp_set_cpu_voltage(cpufreq, supply_cpu);
+	if (err)
+		return err;
+
+	cpufreq->actual_cpu_uV = supply_cpu->u_volt;
+
+	return 0;
+}
+
+static void tegra_cpu_opp_schedule_voltage_drop(
+					struct tegra_cpufreq *cpufreq,
+					struct dev_pm_opp_supply *supply_cpu)
+{
+	unsigned long jiffies = msecs_to_jiffies(voltage_drop_interval_ms);
+	int cpu = get_logical_index(0);
 
 	/*
-	 * Drop count to pll_x clock only if we switched to intermediate freq
-	 * earlier while transitioning to a target frequency.
+	 * It's more power-efficient to keep secondary CPU's in a deeper
+	 * idling state, that's why CPU0 is preferred.
 	 */
-	if (cpufreq->pll_x_prepared) {
-		clk_disable_unprepare(cpufreq->pll_x_clk);
-		cpufreq->pll_x_prepared = false;
+	if (WARN_ON_ONCE(cpu < 0))
+		return;
+
+	cpufreq->supply_cpu = *supply_cpu;
+
+	if (!cpufreq->work_timeout)
+		cpufreq->work_timeout = ktime_add_ms(ktime_get(),
+						     voltage_drop_interval_ms);
+
+	/*
+	 * CPU freq may go lower and then switch only between lower rates,
+	 * thus endlessly deferring the voltage drop. Avoid such situation
+	 * by enforcing the drop if deadline crossed.
+	 */
+	if (ktime_after(ktime_get(), cpufreq->work_timeout))
+		tegra_cpu_deferred_voltage_drop(&cpufreq->work.work);
+	else
+		schedule_delayed_work_on(cpu, &cpufreq->work, jiffies);
+}
+
+static int tegra_cpu_set_opp(struct dev_pm_set_opp_data *data)
+{
+	struct tegra_cpufreq *cpufreq = cpufreq_get_driver_data();
+	struct dev_pm_opp_supply *supply_cpu;
+	struct clk *parent_clk;
+	int err;
+
+	cancel_delayed_work_sync(&cpufreq->work);
+
+	supply_cpu = &data->new_opp.supplies[0];
+	cpufreq->reg_cpu = data->regulators[0];
+
+	/* Scaling up? Scale voltage before frequency */
+	if (cpufreq->actual_cpu_uV < supply_cpu->u_volt) {
+		err = tegra_cpu_opp_raise_voltage(cpufreq, supply_cpu);
+		if (err)
+			return err;
+
+		cpufreq->permitted_interim_rate = data->new_opp.rate;
+		cpufreq->work_timeout = 0;
+	} else if (cpufreq->actual_cpu_uV == supply_cpu->u_volt) {
+		cpufreq->work_timeout = 0;
 	}
 
-	return ret;
+	/* change PLLX rate */
+	err = clk_set_rate(data->clk, data->new_opp.rate);
+	if (err) {
+		dev_err(cpufreq->dev, "failed to change pllx clock rate: %d\n",
+			err);
+		return err;
+	}
+
+	if (cpufreq->parent_clk)
+		parent_clk = cpufreq->parent_clk;
+	else
+		parent_clk = data->clk;
+
+	/* switch CCLK parent to PLLX or other source */
+	err = clk_set_parent(cpufreq->cpu_clk, parent_clk);
+	if (err)
+		return err;
+
+	/* toggle CCLK divider */
+	err = clk_set_rate(cpufreq->cpu_clk, data->new_opp.rate);
+	if (err)
+		return err;
+
+	if (cpufreq->actual_cpu_uV > supply_cpu->u_volt)
+		tegra_cpu_opp_schedule_voltage_drop(cpufreq, supply_cpu);
+
+	return 0;
 }
 
-static int tegra_cpu_init(struct cpufreq_policy *policy)
+static int tegra_cpu_setup_opp(struct tegra_cpufreq *cpufreq)
 {
-	struct tegra20_cpufreq *cpufreq = cpufreq_get_driver_data();
-	int ret;
+	const char * const regulators[] = { "cpu" };
+	struct device *dev = cpufreq->cpu_dev;
+	struct opp_table *opp_table;
+	u32 versions[2];
+	int err;
+
+	if (of_machine_is_compatible("nvidia,tegra20")) {
+		versions[0] = BIT(tegra_sku_info.cpu_process_id);
+		versions[1] = BIT(tegra_sku_info.soc_speedo_id);
+	} else {
+		versions[0] = BIT(tegra_sku_info.cpu_process_id);
+		versions[1] = BIT(tegra_sku_info.cpu_speedo_id);
+	}
 
-	clk_prepare_enable(cpufreq->cpu_clk);
+	cpufreq->opp_table = dev_pm_opp_set_supported_hw(dev, versions, 2);
+	if (IS_ERR(cpufreq->opp_table)) {
+		err = PTR_ERR(cpufreq->opp_table);
+		dev_err(cpufreq->dev,
+			"failed to setup opp supported hw: %d\n", err);
+		return err;
+	}
 
-	/* FIXME: what's the actual transition time? */
-	ret = cpufreq_generic_init(policy, freq_table, 300 * 1000);
-	if (ret) {
-		clk_disable_unprepare(cpufreq->cpu_clk);
-		return ret;
+	opp_table = dev_pm_opp_set_regulators(dev, regulators, 1, false);
+	if (IS_ERR(opp_table)) {
+		err = PTR_ERR(opp_table);
+		dev_err(dev, "failed to setup opp regulators: %d\n", err);
+		goto err_put_supported_hw;
+	}
+
+	opp_table = dev_pm_opp_set_clkname(dev, "pll_x");
+	if (IS_ERR(opp_table)) {
+		err = PTR_ERR(opp_table);
+		dev_err(cpufreq->dev, "failed to change opp clk: %d\n", err);
+		goto err_put_regulators;
+	}
+
+	opp_table = dev_pm_opp_register_set_opp_helper(dev, tegra_cpu_set_opp);
+	if (IS_ERR(opp_table)) {
+		err = PTR_ERR(opp_table);
+		dev_err(cpufreq->dev, "failed to set opp helper: %d\n", err);
+		goto err_put_regulators;
+	}
+
+	err = dev_pm_opp_of_cpumask_add_table(cpu_possible_mask);
+	if (err) {
+		dev_err(cpufreq->dev, "failed to add opp table: %d\n", err);
+		goto err_unregister_opp_helper;
+	}
+
+	err = dev_pm_opp_init_cpufreq_table(dev, &cpufreq->freq_table);
+	if (err) {
+		dev_err(cpufreq->dev,
+			"failed to initialize opp table: %d\n", err);
+		goto err_remove_table;
+	}
+
+	return 0;
+
+err_remove_table:
+	dev_pm_opp_of_cpumask_remove_table(cpu_possible_mask);
+
+err_unregister_opp_helper:
+	dev_pm_opp_unregister_set_opp_helper(cpufreq->opp_table);
+
+err_put_regulators:
+	dev_pm_opp_put_regulators(cpufreq->opp_table);
+
+err_put_supported_hw:
+	dev_pm_opp_put_supported_hw(cpufreq->opp_table);
+
+	return err;
+}
+
+static void tegra_cpu_release_opp(struct tegra_cpufreq *cpufreq)
+{
+	dev_pm_opp_free_cpufreq_table(cpufreq->cpu_dev, &cpufreq->freq_table);
+	dev_pm_opp_of_cpumask_remove_table(cpu_possible_mask);
+	dev_pm_opp_unregister_set_opp_helper(cpufreq->opp_table);
+	dev_pm_opp_put_regulators(cpufreq->opp_table);
+	dev_pm_opp_put_supported_hw(cpufreq->opp_table);
+}
+
+static int tegra_cpu_get_clocks(struct tegra_cpufreq *cpufreq)
+{
+	struct device_node *np = cpufreq->cpu_dev->of_node;
+	unsigned int i;
+	int err;
+
+	cpufreq->cpu_clk = devm_get_clk_from_child(cpufreq->dev, np, NULL);
+	if (IS_ERR(cpufreq->cpu_clk)) {
+		err = PTR_ERR(cpufreq->cpu_clk);
+		dev_err(cpufreq->dev, "failed to get cpu clock: %d\n", err);
+		dev_err(cpufreq->dev, "please update your device tree\n");
+		return err;
 	}
 
+	for (i = 0; i < ARRAY_SIZE(cpufreq->cpu_parents); i++)
+		cpufreq->cpu_parents[i].id = tegra_parent_clocks[i];
+
+	err = devm_clk_bulk_get(cpufreq->dev, ARRAY_SIZE(cpufreq->cpu_parents),
+				cpufreq->cpu_parents);
+	if (err) {
+		dev_err(cpufreq->dev, "failed to get parents: %d\n", err);
+		return err;
+	}
+
+	return 0;
+}
+
+static int tegra_cpu_init(struct cpufreq_policy *policy)
+{
+	struct tegra_cpufreq *cpufreq = cpufreq_get_driver_data();
+	struct device *cpu = cpufreq->cpu_dev;
+	int err;
+
+	err = tegra_cpu_setup_opp(cpufreq);
+	if (err)
+		return err;
+
+	cpufreq_generic_init(policy, cpufreq->freq_table,
+			     dev_pm_opp_get_max_clock_latency(cpu));
 	policy->clk = cpufreq->cpu_clk;
-	policy->suspend_freq = freq_table[0].frequency;
+	policy->suspend_freq = dev_pm_opp_get_suspend_opp_freq(cpu) / 1000;
+
 	return 0;
 }
 
 static int tegra_cpu_exit(struct cpufreq_policy *policy)
 {
-	struct tegra20_cpufreq *cpufreq = cpufreq_get_driver_data();
+	struct tegra_cpufreq *cpufreq = cpufreq_get_driver_data();
+
+	flush_delayed_work(&cpufreq->work);
+	cpufreq_cooling_unregister(cpufreq->cdev);
+	tegra_cpu_release_opp(cpufreq);
+	tegra_unprepare_parent_clocks(cpufreq, true);
 
-	clk_disable_unprepare(cpufreq->cpu_clk);
 	return 0;
 }
 
-static int tegra20_cpufreq_probe(struct platform_device *pdev)
+static void tegra_cpu_ready(struct cpufreq_policy *policy)
 {
-	struct tegra20_cpufreq *cpufreq;
+	struct tegra_cpufreq *cpufreq = cpufreq_get_driver_data();
+
+	cpufreq->cdev = of_cpufreq_cooling_register(policy);
+}
+
+static int tegra_cpu_suspend(struct cpufreq_policy *policy)
+{
+	struct tegra_cpufreq *cpufreq = cpufreq_get_driver_data();
 	int err;
 
-	cpufreq = devm_kzalloc(&pdev->dev, sizeof(*cpufreq), GFP_KERNEL);
-	if (!cpufreq)
-		return -ENOMEM;
+	err = cpufreq_generic_suspend(policy);
+	if (err)
+		return err;
 
-	cpufreq->cpu_clk = clk_get_sys(NULL, "cclk");
-	if (IS_ERR(cpufreq->cpu_clk))
-		return PTR_ERR(cpufreq->cpu_clk);
+	flush_delayed_work(&cpufreq->work);
+	tegra_unprepare_parent_clocks(cpufreq, true);
 
-	cpufreq->pll_x_clk = clk_get_sys(NULL, "pll_x");
-	if (IS_ERR(cpufreq->pll_x_clk)) {
-		err = PTR_ERR(cpufreq->pll_x_clk);
-		goto put_cpu;
-	}
+	return 0;
+}
 
-	cpufreq->pll_p_clk = clk_get_sys(NULL, "pll_p");
-	if (IS_ERR(cpufreq->pll_p_clk)) {
-		err = PTR_ERR(cpufreq->pll_p_clk);
-		goto put_pll_x;
-	}
+static int tegra_cpufreq_probe(struct platform_device *pdev)
+{
+	struct tegra_cpufreq *cpufreq;
+	int err;
+
+	cpufreq = devm_kzalloc(&pdev->dev, sizeof(*cpufreq), GFP_KERNEL);
+	if (!cpufreq)
+		return -ENOMEM;
 
 	cpufreq->dev = &pdev->dev;
+	cpufreq->cpu_dev = get_cpu_device(0);
 	cpufreq->driver.get = cpufreq_generic_get;
 	cpufreq->driver.attr = cpufreq_generic_attr;
 	cpufreq->driver.init = tegra_cpu_init;
 	cpufreq->driver.exit = tegra_cpu_exit;
+	cpufreq->driver.ready = tegra_cpu_ready;
 	cpufreq->driver.flags = CPUFREQ_NEED_INITIAL_FREQ_CHECK;
 	cpufreq->driver.verify = cpufreq_generic_frequency_table_verify;
-	cpufreq->driver.suspend = cpufreq_generic_suspend;
+	cpufreq->driver.suspend = tegra_cpu_suspend;
 	cpufreq->driver.driver_data = cpufreq;
 	cpufreq->driver.target_index = tegra_target;
 	cpufreq->driver.get_intermediate = tegra_get_intermediate;
 	cpufreq->driver.target_intermediate = tegra_target_intermediate;
 	snprintf(cpufreq->driver.name, CPUFREQ_NAME_LEN, "tegra");
+	INIT_DELAYED_WORK(&cpufreq->work, tegra_cpu_deferred_voltage_drop);
+
+	err = tegra_cpu_get_clocks(cpufreq);
+	if (err)
+		return err;
 
 	err = cpufreq_register_driver(&cpufreq->driver);
 	if (err)
-		goto put_pll_p;
+		return err;
 
 	platform_set_drvdata(pdev, cpufreq);
 
 	return 0;
-
-put_pll_p:
-	clk_put(cpufreq->pll_p_clk);
-put_pll_x:
-	clk_put(cpufreq->pll_x_clk);
-put_cpu:
-	clk_put(cpufreq->cpu_clk);
-
-	return err;
 }
 
-static int tegra20_cpufreq_remove(struct platform_device *pdev)
+static int tegra_cpufreq_remove(struct platform_device *pdev)
 {
-	struct tegra20_cpufreq *cpufreq = platform_get_drvdata(pdev);
+	struct tegra_cpufreq *cpufreq = platform_get_drvdata(pdev);
 
 	cpufreq_unregister_driver(&cpufreq->driver);
 
-	clk_put(cpufreq->pll_p_clk);
-	clk_put(cpufreq->pll_x_clk);
-	clk_put(cpufreq->cpu_clk);
-
 	return 0;
 }
 
-static struct platform_driver tegra20_cpufreq_driver = {
-	.probe		= tegra20_cpufreq_probe,
-	.remove		= tegra20_cpufreq_remove,
-	.driver		= {
-		.name	= "tegra20-cpufreq",
+static struct platform_driver tegra_cpufreq_driver = {
+	.probe = tegra_cpufreq_probe,
+	.remove = tegra_cpufreq_remove,
+	.driver = {
+		.name = "tegra20-cpufreq",
 	},
 };
-module_platform_driver(tegra20_cpufreq_driver);
+module_platform_driver(tegra_cpufreq_driver);
+module_param(voltage_drop_interval_ms, uint, 0644);
 
 MODULE_ALIAS("platform:tegra20-cpufreq");
 MODULE_AUTHOR("Colin Cross <ccross@android.com>");
+MODULE_AUTHOR("Dmitry Osipenko <digetx@gmail.com>");
 MODULE_DESCRIPTION("NVIDIA Tegra20 cpufreq driver");
 MODULE_LICENSE("GPL");
diff --git a/drivers/opp/core.c b/drivers/opp/core.c
index f3433bf..3c7c5c5 100644
--- a/drivers/opp/core.c
+++ b/drivers/opp/core.c
@@ -1298,6 +1298,7 @@ static void _free_set_opp_data(struct opp_table *opp_table)
  * @dev: Device for which regulator name is being set.
  * @names: Array of pointers to the names of the regulator.
  * @count: Number of regulators.
+ * @allow_stub_regulator: Some or all regulators can be missed.
  *
  * In order to support OPP switching, OPP layer needs to know the name of the
  * device's regulators, as the core would be required to switch voltages as
@@ -1307,7 +1308,8 @@ static void _free_set_opp_data(struct opp_table *opp_table)
  */
 struct opp_table *dev_pm_opp_set_regulators(struct device *dev,
 					    const char * const names[],
-					    unsigned int count)
+ 						unsigned int count,
+					    bool allow_stub_regulator)
 {
 	struct opp_table *opp_table;
 	struct regulator *reg;
@@ -1336,7 +1338,10 @@ struct opp_table *dev_pm_opp_set_regulators(struct device *dev,
 	}
 
 	for (i = 0; i < count; i++) {
-		reg = regulator_get_optional(dev, names[i]);
+		if (allow_stub_regulator)
+			reg = regulator_get(dev, names[i]);
+		else
+			reg = regulator_get_optional(dev, names[i]);
 		if (IS_ERR(reg)) {
 			ret = PTR_ERR(reg);
 			if (ret != -EPROBE_DEFER)
diff --git a/drivers/soc/tegra/fuse/tegra-apbmisc.c b/drivers/soc/tegra/fuse/tegra-apbmisc.c
index e5a4d8f..c94dccf 100644
--- a/drivers/soc/tegra/fuse/tegra-apbmisc.c
+++ b/drivers/soc/tegra/fuse/tegra-apbmisc.c
@@ -51,6 +51,7 @@ u8 tegra_get_chip_id(void)
 {
 	return (tegra_read_chipid() >> 8) & 0xff;
 }
+EXPORT_SYMBOL_GPL(tegra_get_chip_id);
 
 u32 tegra_read_straps(void)
 {
diff --git a/include/linux/pm_opp.h b/include/linux/pm_opp.h
index 099b319..ea770de 100644
--- a/include/linux/pm_opp.h
+++ b/include/linux/pm_opp.h
@@ -119,7 +119,7 @@ struct opp_table *dev_pm_opp_set_supported_hw(struct device *dev, const u32 *ver
 void dev_pm_opp_put_supported_hw(struct opp_table *opp_table);
 struct opp_table *dev_pm_opp_set_prop_name(struct device *dev, const char *name);
 void dev_pm_opp_put_prop_name(struct opp_table *opp_table);
-struct opp_table *dev_pm_opp_set_regulators(struct device *dev, const char * const names[], unsigned int count);
+struct opp_table *dev_pm_opp_set_regulators(struct device *dev, const char * const names[], unsigned int count, bool allow_stub_regulator);
 void dev_pm_opp_put_regulators(struct opp_table *opp_table);
 struct opp_table *dev_pm_opp_set_clkname(struct device *dev, const char * name);
 void dev_pm_opp_put_clkname(struct opp_table *opp_table);
@@ -252,7 +252,7 @@ static inline struct opp_table *dev_pm_opp_set_prop_name(struct device *dev, con
 
 static inline void dev_pm_opp_put_prop_name(struct opp_table *opp_table) {}
 
-static inline struct opp_table *dev_pm_opp_set_regulators(struct device *dev, const char * const names[], unsigned int count)
+static inline struct opp_table *dev_pm_opp_set_regulators(struct device *dev, const char * const names[], unsigned int count, bool allow_stub_regulator)
 {
 	return ERR_PTR(-ENOTSUPP);
 }
-- 
2.7.4
