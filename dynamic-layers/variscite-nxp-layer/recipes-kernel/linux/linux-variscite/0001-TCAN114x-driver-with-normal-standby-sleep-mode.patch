From 2ff6c5cb8ceb53dc4778f6234a6f4d3a78056025 Mon Sep 17 00:00:00 2001
From: Rikardo-hm <rikard.olander@hostmobility.com>
Date: Mon, 3 Feb 2025 13:56:06 +0000
Subject: [PATCH 1/1] tcan114x driver with normal/standby/sleep mode

v1. First version
v2. Fix tcan114x_mode_store for sleep/standby
v3. Write register SWE_DIS to disable sleep timeout
v.4 Adapt to Linux 6.6
---
 drivers/misc/Kconfig    |   7 +
 drivers/misc/Makefile   |   1 +
 drivers/misc/tcan114x.c | 606 ++++++++++++++++++++++++++++++++++++++++
 3 files changed, 614 insertions(+)
 create mode 100644 drivers/misc/tcan114x.c

diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index cadd4a820c03..fc565342f87e 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -120,6 +120,13 @@ config TIFM_CORE
 	  To compile this driver as a module, choose M here: the module will
 	  be called tifm_core.
 
+config TCAN114X
+	tristate "Ti TCAN114x CAN-Transceiver driver"
+	select REGMAP_SPI
+	depends on SPI_MASTER
+	help
+	  This driver controls the ti tcan1145/tcan114x CAN transceiver.
+
 config TIFM_7XX1
 	tristate "TI Flash Media PCI74xx/PCI76xx host adapter support"
 	depends on PCI && TIFM_CORE
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index f2a4d1ff65d4..84be21aa3b48 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -35,6 +35,7 @@ obj-$(CONFIG_SENSORS_TSL2550)	+= tsl2550.o
 obj-$(CONFIG_DS1682)		+= ds1682.o
 obj-$(CONFIG_C2PORT)		+= c2port/
 obj-$(CONFIG_HMC6352)		+= hmc6352.o
+obj-$(CONFIG_TCAN114X)	        += tcan114x.o
 obj-y				+= eeprom/
 obj-y				+= cb710/
 obj-$(CONFIG_VMWARE_BALLOON)	+= vmw_balloon.o
diff --git a/drivers/misc/tcan114x.c b/drivers/misc/tcan114x.c
new file mode 100644
index 000000000000..af620cc6f8a8
--- /dev/null
+++ b/drivers/misc/tcan114x.c
@@ -0,0 +1,606 @@
+/*
+ * Copyright (C) 2022 Host Mobility AB
+ *
+ * This library is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free 
+ * Software Foundation; either version 2.1 of the License, or (at your option) 
+ * any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU  General Public License
+ * along with this library; if not, write to the Free Software Foundation, 
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110, USA
+ */
+
+#include <linux/module.h>
+#include <linux/spi/spi.h>
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/mutex.h>
+
+#define TCAN114X_REG_ID 0x0
+#define TCAN114X_ID 0x54
+#define TCAN114X_REG_MODE_CTRL 0x10
+#define TCAN114X_MODE_SLEEP 0x01
+#define TCAN114X_MODE_STANDBY 0x04
+#define TCAN114X_MODE_NORMAL 0x07
+
+#define TCAN114X_REG_SWE_DIS 0x1c
+#define TCAN114X_REG_SWE_DIS_FIELD_SWE_DIS 0x80
+
+struct tcan114x_priv {
+	struct device *dev;
+	struct regmap *regmap;
+};
+
+struct regmap_config tcan114x_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.read_flag_mask = 0x00,
+	.write_flag_mask = 0x01,
+};
+
+static int tcan114x_read_reg(struct device *dev, unsigned int reg, unsigned int *rval)
+{
+	struct tcan114x_priv *data = dev_get_drvdata(dev);
+	int ret;
+
+	reg = reg << 1;
+	ret = regmap_read(data->regmap, reg, rval);
+	if (reg < 0) {
+		return ret;
+	}
+
+	return 0;
+}
+
+static int tcan114x_write_reg(struct device *dev, unsigned int reg, unsigned int val)
+{
+	struct tcan114x_priv *data = dev_get_drvdata(dev);
+	unsigned int write_reg;
+	int ret;
+
+	write_reg = reg;
+	write_reg = (write_reg << 1);
+
+	ret = regmap_write(data->regmap, write_reg, val);
+	if (ret < 0) {
+		return ret;
+	}
+
+	return 0;
+}
+
+static int tcan114x_update_reg(struct device *dev, unsigned int reg,
+			      unsigned int mask, unsigned int val)
+{
+	unsigned int cur_val;
+	unsigned int new_val;
+	int ret;
+
+	dev_info(dev, "Writing new val 0x%02x to reg 0x%02x", val, reg);
+
+	ret = tcan114x_read_reg(dev, reg, &cur_val);
+	if (ret < 0) {
+		return ret;
+	}
+
+	cur_val = cur_val & (~mask);
+	new_val = cur_val | val;
+	dev_info(dev, "Writing new value 0x%02x\n", new_val);
+	ret = tcan114x_write_reg(dev, reg, new_val);
+	if (reg < 0) {
+		return ret;
+	}
+
+	return 0;
+}
+
+static int tcan114x_is_bit_set(unsigned int val, unsigned int mask)
+{
+	return (val & mask) == mask;
+}
+
+static int tcan114x_reset_event_status(struct device *dev)
+{
+	int ret;
+
+	// The event status registers will be cleard by writing a 1 to the
+	// corresponding bit.
+	ret = tcan114x_write_reg(dev, REG_GLOBAL_EVENT_STATUS, 0xff);
+	if (ret < 0) {
+		return ret;
+	}
+
+	ret = tcan114x_write_reg(dev, REG_SYS_EVENT_STATUS, 0xff);
+	if (ret < 0) {
+		return ret;
+	}
+
+	ret = tcan114x_write_reg(dev, REG_TRANSCEIVER_EVENT_STATUS, 0xff);
+	if (ret < 0) {
+		return ret;
+	}
+
+	ret = tcan114x_write_reg(dev, REG_WAKE_EVENT_STATUS, 0xff);
+
+	return ret;
+}
+
+static ssize_t tcan114x_version_show(struct device *dev, 
+					struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "Version: 1.0.0\n");
+}
+static DEVICE_ATTR(version, S_IRUGO, tcan114x_version_show, NULL);
+
+ssize_t tcan114x_mode_store(struct device *dev,
+						   struct device_attribute *attr,
+						   const char *buf,
+						   size_t count)
+{
+	int ret;
+	char mode[15];
+
+	strncpy(mode, buf, count -1);
+
+	if (!strncmp(buf, "normal", count - 1)) {
+		ret = tcan114x_write_reg(dev, TCAN114X_REG_MODE_CTRL, TCAN114X_MODE_NORMAL);
+		if (ret) {
+			dev_err(dev, "Cannot set operation mode to normal\n");
+			return ret;
+		}
+		dev_dbg(dev, "Switched to normal mode\n");
+	} else if (!strncmp(buf, "sleep", count - 1)) {
+		ret = tcan114x_write_reg(dev, TCAN114X_REG_MODE_CTRL, TCAN114X_MODE_SLEEP);
+		if (ret) {
+			dev_err(dev, "Cannot set operation mode to sleep\n");
+			return ret;
+		}
+		dev_dbg(dev, "Switch to normal sleep\n");
+	} else if (!strncmp(buf, "standby", count - 1)) {
+		ret = tcan114x_write_reg(dev, TCAN114X_REG_MODE_CTRL, TCAN114X_MODE_STANDBY);
+		if (ret) {
+			dev_err(dev, "Cannot set operation mode to standby\n");
+			return ret;
+		}
+		dev_dbg(dev, "Switch to normal standby\n");
+	} else {
+		dev_err(dev, "Unsupported mode\n");
+		return -EINVAL;
+	}
+
+	return count;
+}
+
+ssize_t tcan114x_mode_show(struct device *dev,
+						  struct device_attribute *attr,
+						  char *buf)
+{
+	unsigned int mode;
+	int ret;
+
+	ret = tcan114x_read_reg(dev, TCAN114X_REG_MODE_CTRL, &mode);
+	if (ret < 0) {
+		dev_err(dev, "Can't read mode ctrl register\n");
+		return -EBUSY;
+	}
+
+	switch (mode) {
+	case TCAN114X_MODE_STANDBY:
+		return sprintf(buf, "normal sleep [standby]\n");
+	case TCAN114X_MODE_SLEEP:
+		return sprintf(buf, "normal [sleep] standby\n");
+	case TCAN114X_MODE_NORMAL:
+		return sprintf(buf, "[normal] sleep standby\n");
+	}
+
+	
+	return sprintf(buf, "Unsupported Operation mode\n");
+}
+
+static DEVICE_ATTR(tcan114x_mode, S_IWUSR | S_IRUGO, tcan114x_mode_show, tcan114x_mode_store);
+
+ssize_t tcan114x_canctrl_store(struct device *dev, struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+	int ret;
+	unsigned int new_val;
+
+	if (!strncmp(buf, "active_det", strlen("active_det"))) {
+		new_val = CAN_ACTIVE_DET;
+	} else if (!strncmp(buf, "active", strlen("active"))) {
+		new_val = CAN_ACTIVE;
+	} else if (!strncmp(buf, "offline", strlen("active"))) {
+		new_val = CAN_OFFLINE;
+	} else if (!strncmp(buf, "listen_only", strlen("listen_only"))) {
+		new_val = CAN_LISTEN_ONLY;
+	} else {
+		dev_err(dev, "Unsupported CAN control\n");
+		return -EINVAL;
+	}
+
+	ret = tcan114x_update_reg(dev, REG_CAN_CTRL, CMC, new_val);
+	if (ret < 0) {
+		return ret;
+	}
+
+	return count;
+}
+
+ssize_t tcan114x_canctrl_show(struct device *dev, struct device_attribute *attr,
+			     char *buf)
+{
+	int ret;
+	unsigned int rval;
+	ssize_t count;
+
+	ret = tcan114x_read_reg(dev, REG_CAN_CTRL, &rval);
+	if (ret < 0) {
+		return ret;
+	}
+
+	rval = rval & CMC;
+	switch (rval) {
+	case CAN_OFFLINE:
+		count =
+		    sprintf(buf, "active active_det listen_only [offline]\n");
+		break;
+	case CAN_LISTEN_ONLY:
+		count =
+		    sprintf(buf, "active active_det [listen_only] offline\n");
+		break;
+	case CAN_ACTIVE_DET:
+		count =
+		    sprintf(buf, "active [active_det] listen_only offline\n");
+		break;
+	case CAN_ACTIVE:
+		count =
+		    sprintf(buf, "[active] active_det listen_only offline\n");
+		break;
+	default:
+		dev_err(dev, "Invalid value\n");
+		return -EINVAL;
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(canctrl, S_IWUSR | S_IRUGO, tcan114x_canctrl_show,
+		   tcan114x_canctrl_store);
+
+ssize_t tcan114x_main_status_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	int ret;
+	unsigned int rval;
+
+	ret = tcan114x_read_reg(dev, REG_MAIN_STATUS, &rval);
+	if (ret < 0) {
+		return ret;
+	}
+
+	if (tcan114x_is_bit_set(rval, FSMS)) {
+		strcat(buf, "FSMS");
+	} else {
+		strcat(buf, "~FSMS");
+	}
+
+	if (tcan114x_is_bit_set(rval, OTWS)) {
+		strcat(buf, " OTWS");
+	} else {
+		strcat(buf, " ~OTWS");
+	}
+
+	if (tcan114x_is_bit_set(rval, NMS)) {
+		strcat(buf, " NMS\n");
+	} else {
+		strcat(buf, " ~NMS\n");
+	}
+
+	return strlen(buf);
+}
+
+static DEVICE_ATTR(main_status, S_IRUGO, tcan114x_main_status_show, NULL);
+
+ssize_t tcan114x_transcevier_status_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	int ret;
+	unsigned int rval;
+
+	ret = tcan114x_read_reg(dev, REG_TRANSCEIVER_STATUS, &rval);
+	if (ret < 0) {
+		return ret;
+	}
+
+	if (tcan114x_is_bit_set(rval, CTS)) {
+		strcat(buf, "CTS");
+	} else {
+		strcat(buf, "~CTS");
+	}
+
+	if (tcan114x_is_bit_set(rval, CPNERR)) {
+		strcat(buf, " CPNERR");
+	} else {
+		strcat(buf, " ~CPNERR");
+	}
+
+	if (tcan114x_is_bit_set(rval, CPNS)) {
+		strcat(buf, " CPNS");
+	} else {
+		strcat(buf, " ~CPNS");
+	}
+
+	if (tcan114x_is_bit_set(rval, COSCS)) {
+		strcat(buf, " COSCS");
+	} else {
+		strcat(buf, " ~COSCS");
+	}
+
+	if (tcan114x_is_bit_set(rval, CBSS)) {
+		strcat(buf, " CBSS");
+	} else {
+		strcat(buf, " ~CBSS");
+	}
+
+	if (tcan114x_is_bit_set(rval, VCS)) {
+		strcat(buf, " VCS");
+	} else {
+		strcat(buf, " ~VCS");
+	}
+
+	if (tcan114x_is_bit_set(rval, CFS)) {
+		strcat(buf, " CFS\n");
+	} else {
+		strcat(buf, " ~CFS\n");
+	}
+
+	return strlen(buf);
+}
+
+static DEVICE_ATTR(transceiver_status, S_IRUGO, tcan114x_transcevier_status_show,
+		   NULL);
+
+ssize_t tcan114x_event_show(struct device *dev, struct device_attribute *attr,
+			   char *buf)
+{
+	int ret;
+	unsigned int rval;
+
+	ret = tcan114x_read_reg(dev, REG_SYS_EVENT_STATUS, &rval);
+	if (ret < 0) {
+		return ret;
+	}
+
+	if (tcan114x_is_bit_set(rval, OTW)) {
+		strcat(buf, "OTW");
+	} else {
+		strcat(buf, "~OTW");
+	}
+
+	if (tcan114x_is_bit_set(rval, SPIF)) {
+		strcat(buf, " SPIF");
+	} else {
+		strcat(buf, " ~SPIF");
+	}
+
+	ret = tcan114x_read_reg(dev, REG_TRANSCEIVER_EVENT_STATUS, &rval);
+	if (ret < 0) {
+		return ret;
+	}
+
+	if (tcan114x_is_bit_set(rval, PNFDE)) {
+		strcat(buf, " PNFDE");
+	} else {
+		strcat(buf, " ~PNFDE");
+	}
+
+	if (tcan114x_is_bit_set(rval, CBS)) {
+		strcat(buf, " CBS");
+	} else {
+		strcat(buf, " ~CBS");
+	}
+
+	if (tcan114x_is_bit_set(rval, CF)) {
+		strcat(buf, " CF");
+	} else {
+		strcat(buf, " ~CF");
+	}
+
+	if (tcan114x_is_bit_set(rval, CW)) {
+		strcat(buf, " CW\n");
+	} else {
+		strcat(buf, " ~CW\n");
+	}
+
+	ret = tcan114x_reset_event_status(dev);
+	if (ret < 0) {
+		return ret;
+	}
+
+	return strlen(buf);
+}
+
+static DEVICE_ATTR(event, S_IRUGO, tcan114x_event_show, NULL);
+
+static struct attribute *tcan114x_attributes[] = {
+    &dev_attr_version.attr,
+    &dev_attr_tcan114x_mode.attr,
+    &dev_attr_main_status.attr,
+    &dev_attr_modectrl.attr,
+    &dev_attr_canctrl.attr,
+    &dev_attr_transceiver_status.attr,
+    &dev_attr_event.attr,
+    NULL
+};
+
+
+static const struct attribute_group tcan114x_attr_group = {
+	.attrs = tcan114x_attributes,
+};
+
+static int tcan114x_check_devid(struct device *dev)
+{
+	unsigned int id;
+	int ret;
+
+	ret = tcan114x_read_reg(dev, TCAN114X_REG_ID, &id);
+	if (ret < 0) {
+		return ret;
+	}
+
+	dev_info(dev, "Read ID 0x%2X\n", id);
+	if (id != TCAN114X_ID) {
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static int tcan114x_init(struct device *dev)
+{
+	int ret;
+	unsigned int rval;
+
+	ret = tcan114x_write_reg(dev, TCAN114X_REG_MODE_CTRL, TCAN114X_MODE_NORMAL);
+	if (ret < 0) {
+		return ret;
+	}
+
+	ret = tcan114x_write_reg(dev, TCAN114X_REG_SWE_DIS, TCAN114X_REG_SWE_DIS_FIELD_SWE_DIS);
+	if (ret < 0) {
+		return ret;
+	}
+
+	ret = tcan114x_read_reg(dev, TCAN114X_REG_MODE_CTRL, &rval);
+	if (ret < 0) {
+		return ret;
+	}
+
+	if (rval != TCAN114X_MODE_NORMAL) {
+		dev_err(dev, "Device is not in Normal mode, but it should be\n");
+		return -EINVAL;
+	}
+
+	/*
+	ret = tcan114x_read_reg(dev, TCAN114X_REG_MAIN_STATUS, &rval);
+	if (ret < 0) {
+		return ret;
+	}
+	*/
+
+	return 0;
+}
+
+static int tcan114x_probe(struct spi_device *client)
+{
+	struct tcan114x_priv *data;
+	struct regmap *regmap;
+	struct device *dev;
+	int err = 0;
+
+	dev_info(&client->dev, "Begin Init\n");
+	err = spi_setup(client);
+	if (err < 0) {
+		dev_err(&client->dev, "Can't setup SPI\n");
+		goto exit;
+	}
+
+	regmap = devm_regmap_init_spi(client, &tcan114x_regmap_config);
+	if (IS_ERR(regmap)) {
+		err = PTR_ERR(regmap);
+		dev_err(&client->dev, "Failed to init the regmap for the device\n");
+		goto exit;
+	}
+
+	data = kzalloc(sizeof(struct tcan114x_priv), GFP_KERNEL);
+	if (!data) {
+		dev_err(&client->dev, "Not enough memory\n");
+		err = -ENOMEM;
+		goto exit;
+	}
+
+	dev_set_drvdata(&client->dev, data);
+	data->dev = &client->dev;
+	dev = data->dev;
+	data->regmap = regmap;
+
+	err = tcan114x_check_devid(dev);
+	if (err) {
+		if (err == -ENODEV) {
+			dev_err(dev, "Can't find tcan114x on SPI bus\n");
+			goto exit_free;
+		} else {
+			dev_err(dev, "Can't read device id\n");
+			goto exit_free;
+		}
+	}
+
+	err = tcan114x_init(dev);
+	if (err) {
+		dev_err(dev, "Can't initialize TCAN114X\n");
+		goto exit_free;
+	}
+
+	err = sysfs_create_group(&dev->kobj, &tcan114x_attr_group);
+	if (err) {
+		dev_err(dev, "Can't create sysfs entries\n");
+		goto exit_free;
+	}
+
+	return 0;
+
+exit_free:
+	kfree(data);
+
+exit:
+	return err;
+}
+
+static void tcan114x_remove(struct spi_device *client)
+{
+	struct tcan114x_priv *data = dev_get_drvdata(&client->dev);
+
+	sysfs_remove_group(&data->dev->kobj, &tcan114x_attr_group);
+	kfree(data);
+
+}
+
+static const struct of_device_id tcan114x_of_match[] = {
+	{ .compatible = "ti,tcan114x", },
+	{ },
+};
+
+MODULE_DEVICE_TABLE(of, tcan114x_of_match);
+
+static const struct spi_device_id tcan114x_id[] = {
+	{ "tcan114x", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, tcan114x_id);
+
+static struct spi_driver tcan114x_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "tcan114x",
+		.of_match_table = tcan114x_of_match,
+	},
+	.id_table = tcan114x_id,
+	.probe = tcan114x_probe,
+	.remove = tcan114x_remove,
+};
+
+module_spi_driver(tcan114x_spi_driver);
+
+MODULE_AUTHOR("Mattias Busck<mattias.busck@hostmobility.com");
+MODULE_DESCRIPTION("ti tcan114x CAN transceiver SPI driver");
+MODULE_LICENSE("GPL");
-- 
2.25.1

