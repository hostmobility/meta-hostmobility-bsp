From 832df50f45a2a275acb46a42dc886a51b5381cc9 Mon Sep 17 00:00:00 2001
From: rikardo <rikard.olander@hostmobility.com>
Date: Mon, 2 Dec 2019 10:23:40 +0100
Subject: [PATCH] Add asix driver version 4.23 with mac addresses from device tree

---
 drivers/net/usb/Makefile       |    2 -
 drivers/net/usb/asix.c         | 4346 ++++++++++++++++++++++++++++++++++++++++
 drivers/net/usb/asix.h         |  718 +++++--
 drivers/net/usb/asix_common.c  |  776 -------
 drivers/net/usb/asix_devices.c | 1401 -------------
 drivers/net/usb/ax88172a.c     |  387 ----
 drivers/net/usb/ax88179_178a.c | 1795 -----------------
 drivers/net/usb/axusbnet.c     | 1480 ++++++++++++++
 drivers/net/usb/axusbnet.h     |  211 ++
 9 files changed, 6556 insertions(+), 4560 deletions(-)
 create mode 100644 drivers/net/usb/asix.c
 delete mode 100644 drivers/net/usb/asix_common.c
 delete mode 100644 drivers/net/usb/asix_devices.c
 delete mode 100644 drivers/net/usb/ax88172a.c
 delete mode 100644 drivers/net/usb/ax88179_178a.c
 create mode 100644 drivers/net/usb/axusbnet.c
 create mode 100644 drivers/net/usb/axusbnet.h

diff --git a/drivers/net/usb/Makefile b/drivers/net/usb/Makefile
index 27307a4..3240d56 100644
--- a/drivers/net/usb/Makefile
+++ b/drivers/net/usb/Makefile
@@ -11,8 +11,6 @@ obj-$(CONFIG_USB_RTL8152)	+= r8152.o
 obj-$(CONFIG_USB_HSO)		+= hso.o
 obj-$(CONFIG_USB_LAN78XX)	+= lan78xx.o
 obj-$(CONFIG_USB_NET_AX8817X)	+= asix.o
-asix-y := asix_devices.o asix_common.o ax88172a.o
-obj-$(CONFIG_USB_NET_AX88179_178A)      += ax88179_178a.o
 obj-$(CONFIG_USB_NET_CDCETHER)	+= cdc_ether.o
 obj-$(CONFIG_USB_NET_CDC_EEM)	+= cdc_eem.o
 obj-$(CONFIG_USB_NET_DM9601)	+= dm9601.o
diff --git a/drivers/net/usb/asix.c b/drivers/net/usb/asix.c
new file mode 100644
index 00000000..5d90e2c
--- /dev/null
+++ b/drivers/net/usb/asix.c
@@ -0,0 +1,4346 @@
+/*
+ * ASIX AX8817X based USB 2.0 Ethernet Devices
+ * Copyright (C) 2003-2005 David Hollis <dhollis@davehollis.com>
+ * Copyright (C) 2005 Phil Chang <pchang23@sbcglobal.net>
+ * Copyright (c) 2002-2003 TiVo Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/* debug messages, extra info */
+/* #define	DEBUG */
+
+#include <linux/version.h>
+/* #include <linux/config.h> */
+#ifdef	CONFIG_USB_DEBUG
+#   define DEBUG
+#endif
+#include <linux/module.h>
+#include <linux/kmod.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/ethtool.h>
+#include <linux/workqueue.h>
+#include <linux/mii.h>
+#include <linux/usb.h>
+#include <linux/crc32.h>
+
+#include "axusbnet.c"
+#include "asix.h"
+
+#define DRV_VERSION	"4.23.0"
+
+static char version[] =
+KERN_INFO "ASIX USB Ethernet Adapter:v" DRV_VERSION
+	"    http://www.asix.com.tw\n";
+
+/* configuration of maximum bulk in size */
+static int bsize = AX88772B_MAX_BULKIN_16K;
+module_param(bsize, int, 0);
+MODULE_PARM_DESC(bsize, "Maximum transfer size per bulk");
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20)
+static void ax88772b_link_reset(void *data);
+static void ax88772a_link_reset(void *data);
+static void ax88772_link_reset(void *data);
+#else
+static void ax88772b_link_reset(struct work_struct *work);
+static void ax88772a_link_reset(struct work_struct *work);
+static void ax88772_link_reset(struct work_struct *work);
+#endif
+static int ax88772a_phy_powerup(struct usbnet *dev);
+static void ax8817x_mdio_write_le(struct net_device *netdev, int phy_id,
+				  int loc, int val);
+static int ax8817x_mdio_read_le(struct net_device *netdev, int phy_id, int loc);
+static int ax88772b_set_csums(struct usbnet *dev);
+static int ax88772b_external_phyinit(struct usbnet *dev);
+
+/* ASIX AX8817X based USB 2.0 Ethernet Devices */
+
+static int ax8817x_read_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,
+			    u16 size, void *data)
+{
+	return usb_control_msg(
+		dev->udev,
+		usb_rcvctrlpipe(dev->udev, 0),
+		cmd,
+		USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+		value,
+		index,
+		data,
+		size,
+		USB_CTRL_GET_TIMEOUT);
+}
+
+static int ax8817x_write_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,
+			     u16 size, void *data)
+{
+	return usb_control_msg(
+		dev->udev,
+		usb_sndctrlpipe(dev->udev, 0),
+		cmd,
+		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+		value,
+		index,
+		data,
+		size,
+		USB_CTRL_SET_TIMEOUT);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20)
+static void ax8817x_async_cmd_callback(struct urb *urb, struct pt_regs *regs)
+#else
+static void ax8817x_async_cmd_callback(struct urb *urb)
+#endif
+{
+	struct usb_ctrlrequest *req = (struct usb_ctrlrequest *)urb->context;
+
+	if (urb->status < 0)
+		printk(KERN_DEBUG "ax8817x_async_cmd_callback() failed with %d",
+			urb->status);
+
+	kfree(req);
+	usb_free_urb(urb);
+}
+
+static int ax8817x_set_mac_addr(struct net_device *net, void *p)
+{
+	struct usbnet *dev = netdev_priv(net);
+	struct sockaddr *addr = p;
+	int ret;
+
+	memcpy(net->dev_addr, addr->sa_data, ETH_ALEN);
+
+	/* Set the MAC address */
+	ret = ax8817x_write_cmd(dev, AX88772_CMD_WRITE_NODE_ID,
+				 0, 0, ETH_ALEN, net->dev_addr);
+	if (ret < 0)
+		return ret;
+	
+	return 0;
+}
+
+static void ax88178_status(struct usbnet *dev, struct urb *urb)
+{
+	struct ax88172_int_data *event;
+	struct ax88178_data *ax178dataptr = (struct ax88178_data *)dev->priv;
+	int link;
+
+	if (urb->actual_length < 8)
+		return;
+
+	if (ax178dataptr->EepromData == PHY_MODE_MAC_TO_MAC_GMII)
+		return;
+
+	event = urb->transfer_buffer;
+	link = event->link & 0x01;
+	if (netif_carrier_ok(dev->net) != link) {
+		if (link) {
+			netif_carrier_on(dev->net);
+			axusbnet_defer_kevent(dev, EVENT_LINK_RESET);
+		} else
+			netif_carrier_off(dev->net);
+		devwarn(dev, "ax88178 - Link status is: %d", link);
+	}
+}
+
+static void ax8817x_status(struct usbnet *dev, struct urb *urb)
+{
+	struct ax88172_int_data *event;
+	int link;
+
+	if (urb->actual_length < 8)
+		return;
+
+	event = urb->transfer_buffer;
+	link = event->link & 0x01;
+	if (netif_carrier_ok(dev->net) != link) {
+		if (link) {
+			netif_carrier_on(dev->net);
+			axusbnet_defer_kevent(dev, EVENT_LINK_RESET);
+		} else
+			netif_carrier_off(dev->net);
+		devwarn(dev, "ax8817x - Link status is: %d", link);
+	}
+}
+
+static void ax88772_status(struct usbnet *dev, struct urb *urb)
+{
+	struct ax88172_int_data *event;
+	struct ax88772_data *ax772_data = (struct ax88772_data *)dev->priv;
+	int link;
+
+	if (urb->actual_length < 8)
+		return;
+
+	event = urb->transfer_buffer;
+	link = event->link & 0x01;
+
+	if (netif_carrier_ok(dev->net) != link) {
+		if (link) {
+			netif_carrier_on(dev->net);
+			ax772_data->Event = AX_SET_RX_CFG;
+		} else {
+			netif_carrier_off(dev->net);
+			if (ax772_data->Event == AX_NOP) {
+				ax772_data->Event = PHY_POWER_DOWN;
+				ax772_data->TickToExpire = 25;
+			}
+		}
+
+		devwarn(dev, "ax88772 - Link status is: %d", link);
+	}
+
+	if (ax772_data->Event)
+		queue_work(ax772_data->ax_work, &ax772_data->check_link);
+}
+
+static void ax88772a_status(struct usbnet *dev, struct urb *urb)
+{
+	struct ax88172_int_data *event;
+	struct ax88772a_data *ax772a_data = (struct ax88772a_data *)dev->priv;
+	int link;
+	int powsave = (ax772a_data->EepromData >> 14);
+
+	if (urb->actual_length < 8)
+		return;
+
+	event = urb->transfer_buffer;
+	link = event->link & 0x01;
+
+	if (netif_carrier_ok(dev->net) != link) {
+
+		if (link) {
+			netif_carrier_on(dev->net);
+			ax772a_data->Event = AX_SET_RX_CFG;
+		} else if ((powsave == 0x3) || (powsave == 0x1)) {
+			netif_carrier_off(dev->net);
+			if (ax772a_data->Event == AX_NOP) {
+				ax772a_data->Event = CHK_CABLE_EXIST;
+				ax772a_data->TickToExpire = 14;
+			}
+		} else {
+			netif_carrier_off(dev->net);
+			ax772a_data->Event = AX_NOP;
+		}
+
+		devwarn(dev, "ax88772a - Link status is: %d", link);
+	}
+
+	if (ax772a_data->Event)
+		queue_work(ax772a_data->ax_work, &ax772a_data->check_link);
+}
+
+static int ax88772b_stop(struct usbnet *dev)
+{
+	u16 *medium;
+
+	medium = kmalloc(2, GFP_ATOMIC);
+	if (medium) {
+		ax8817x_read_cmd(dev, AX_CMD_READ_MEDIUM_MODE, 0, 0, 2, medium);
+		ax8817x_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE,
+				  (*medium & ~AX88772_MEDIUM_RX_ENABLE),
+				  0, 0, NULL);
+
+		kfree(medium);
+		return 0;
+	}
+	return -EINVAL;
+}
+
+static int ax88772b_reset(struct usbnet *dev)
+{
+	int ret;
+
+	/* Set the MAC address */
+	ret = ax8817x_write_cmd(dev, AX88772_CMD_WRITE_NODE_ID,
+				0, 0, ETH_ALEN, dev->net->dev_addr);
+	if (ret < 0)
+		deverr(dev, "set MAC address failed: %d", ret);
+
+	/* stop MAC operation */
+	ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL, AX_RX_CTL_STOP,
+				0, 0, NULL);
+	if (ret < 0)
+		deverr(dev, "Reset RX_CTL failed: %d", ret);
+
+	ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE,
+				AX88772_MEDIUM_DEFAULT, 0, 0,
+				NULL);
+	if (ret < 0)
+		deverr(dev, "Write medium mode register: %d", ret);
+
+	return ret;
+}
+
+static void ax88772b_status(struct usbnet *dev, struct urb *urb)
+{
+	struct ax88772b_data *ax772b_data = (struct ax88772b_data *)dev->priv;
+	struct ax88172_int_data *event;
+	int link;
+
+	if (urb->actual_length < 8)
+		return;
+
+	if (ax772b_data->OperationMode == OPERATION_PHY_MODE)
+		return;
+
+	event = urb->transfer_buffer;
+	if (ax772b_data->PhySelect == 0 &&
+	    ax772b_data->OperationMode == OPERATION_MAC_MODE)
+		link = (event->link & AX_INT_SPLS_LINK) >> 1;
+	else
+		link = event->link & AX_INT_PPLS_LINK;
+
+	if (netif_carrier_ok(dev->net) != link) {
+		if (link) {
+			netif_carrier_on(dev->net);
+			ax772b_data->Event = AX_SET_RX_CFG;
+		} else {
+			netif_carrier_off(dev->net);
+			ax772b_data->time_to_chk = jiffies;
+		}
+		devwarn(dev, "ax88772b - Link status is: %d", link);
+	}
+
+	if (!link) {
+
+		int no_cable = (event->link & AX_INT_CABOFF_UNPLUG) ? 1 : 0;
+
+		if (no_cable) {
+			if ((ax772b_data->psc &
+			    (AX_SWRESET_IPPSL_0 | AX_SWRESET_IPPSL_1)) &&
+			     !ax772b_data->pw_enabled) {
+				/*
+				 * AX88772B already entered power saving state
+				 */
+				ax772b_data->pw_enabled = 1;
+			}
+			if (ax772b_data->psc & AX_SWRESET_AUTODETACH)
+				ax772b_data->Event = AX_CHK_AUTODETACH;
+
+		} else {
+			/* AX88772B resumed from power saving state */
+			if (ax772b_data->pw_enabled ||
+				(jiffies > (ax772b_data->time_to_chk +
+				 AX88772B_WATCHDOG))) {
+				if (ax772b_data->pw_enabled)
+					ax772b_data->pw_enabled = 0;
+				ax772b_data->Event = PHY_POWER_UP;
+				ax772b_data->time_to_chk = jiffies;
+			}
+		}
+	}
+
+	if (ax772b_data->Event)
+		queue_work(ax772b_data->ax_work, &ax772b_data->check_link);
+}
+
+static void ax88772c_status(struct usbnet *dev, struct urb *urb)
+{
+	struct ax88772b_data *ax772b_data = (struct ax88772b_data *)dev->priv;
+	struct ax88172_int_data *event;
+	int link;
+
+	if (urb->actual_length < 8)
+		return;
+
+	if (ax772b_data->OperationMode == OPERATION_PHY_MODE)
+		return;
+
+	event = urb->transfer_buffer;
+	if (ax772b_data->PhySelect == 0 &&
+	    ax772b_data->OperationMode == OPERATION_MAC_MODE)
+		link = (event->link & AX_INT_SPLS_LINK) >> 1;
+	else
+		link = event->link & AX_INT_PPLS_LINK;
+
+	if (netif_carrier_ok(dev->net) != link) {
+		if (link) {
+			netif_carrier_on(dev->net);
+			ax772b_data->Event = AX_SET_RX_CFG;
+		} else {
+			netif_carrier_off(dev->net);
+			ax772b_data->time_to_chk = jiffies;
+		}
+		devwarn(dev, "ax88772c - Link status is: %d", link);
+	}
+
+	if (!link) {
+
+		int no_cable = (event->link & AX_INT_CABOFF_UNPLUG) ? 1 : 0;
+
+		if (no_cable) {
+			if ((ax772b_data->psc &
+			    (AX_SWRESET_IPPSL_0 | AX_SWRESET_IPPSL_1)) &&
+			     !ax772b_data->pw_enabled) {
+				/*
+				 * AX88772B already entered power saving state
+				 */
+				ax772b_data->pw_enabled = 1;
+			}
+			if (ax772b_data->psc & AX_SWRESET_AUTODETACH)
+				ax772b_data->Event = AX_CHK_AUTODETACH;
+		} else {
+			/* AX88772B resumed from power saving state */
+			if (ax772b_data->pw_enabled ||
+				(jiffies > (ax772b_data->time_to_chk +
+				 AX88772B_WATCHDOG))) {
+				if (ax772b_data->pw_enabled)
+					ax772b_data->pw_enabled = 0;
+				ax772b_data->Event = PHY_POWER_UP;
+				ax772b_data->time_to_chk = jiffies;
+			}
+		}
+	}
+
+	if (ax772b_data->Event)
+		queue_work(ax772b_data->ax_work, &ax772b_data->check_link);
+}
+
+void
+ax8817x_write_cmd_async(struct usbnet *dev, u8 cmd, u16 value, u16 index,
+				    u16 size, void *data)
+{
+	struct usb_ctrlrequest *req;
+	int status;
+	struct urb *urb;
+
+	urb = usb_alloc_urb(0, GFP_ATOMIC);
+	if (urb == NULL) {
+		deverr(dev, "Error allocating URB in write_cmd_async!");
+		return;
+	}
+
+	req = kmalloc(sizeof(struct usb_ctrlrequest), GFP_ATOMIC);
+	if (req == NULL) {
+		deverr(dev, "Failed to allocate memory for control request");
+		usb_free_urb(urb);
+		return;
+	}
+
+	req->bRequestType = USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE;
+	req->bRequest = cmd;
+	req->wValue = cpu_to_le16(value);
+	req->wIndex = cpu_to_le16(index);
+	req->wLength = cpu_to_le16(size);
+
+	usb_fill_control_urb(urb, dev->udev,
+			     usb_sndctrlpipe(dev->udev, 0),
+			     (void *)req, data, size,
+			     ax8817x_async_cmd_callback, req);
+
+	status = usb_submit_urb(urb, GFP_ATOMIC);
+	if (status < 0) {
+		deverr(dev, "Error submitting the control message: status=%d",
+				status);
+		kfree(req);
+		usb_free_urb(urb);
+	}
+}
+
+static void ax8817x_set_multicast(struct net_device *net)
+{
+	struct usbnet *dev = netdev_priv(net);
+	struct ax8817x_data *data = (struct ax8817x_data *)&dev->data;
+	u8 rx_ctl = AX_RX_CTL_START | AX_RX_CTL_AB;
+	int mc_count;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 35)
+	mc_count = net->mc_count;
+#else
+	mc_count = netdev_mc_count(net);
+#endif
+
+	if (net->flags & IFF_PROMISC) {
+		rx_ctl |= AX_RX_CTL_PRO;
+	} else if (net->flags & IFF_ALLMULTI
+		   || mc_count > AX_MAX_MCAST) {
+		rx_ctl |= AX_RX_CTL_AMALL;
+	} else if (mc_count == 0) {
+		/* just broadcast and directed */
+	} else {
+		/* We use the 20 byte dev->data
+		 * for our 8 byte filter buffer
+		 * to avoid allocating memory that
+		 * is tricky to free later */
+		u32 crc_bits;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 35)
+		struct dev_mc_list *mc_list = net->mc_list;
+		int i;
+
+		memset(data->multi_filter, 0, AX_MCAST_FILTER_SIZE);
+
+		/* Build the multicast hash filter. */
+		for (i = 0; i < net->mc_count; i++) {
+			crc_bits =
+			    ether_crc(ETH_ALEN,
+				      mc_list->dmi_addr) >> 26;
+			data->multi_filter[crc_bits >> 3] |=
+			    1 << (crc_bits & 7);
+			mc_list = mc_list->next;
+		}
+#else
+		struct netdev_hw_addr *ha = NULL;
+		memset(data->multi_filter, 0, AX_MCAST_FILTER_SIZE);
+		netdev_for_each_mc_addr(ha, net) {
+			crc_bits = ether_crc(ETH_ALEN, ha->addr) >> 26;
+			data->multi_filter[crc_bits >> 3] |=
+				1 << (crc_bits & 7);
+		}
+#endif
+		ax8817x_write_cmd_async(dev, AX_CMD_WRITE_MULTI_FILTER, 0, 0,
+				   AX_MCAST_FILTER_SIZE, data->multi_filter);
+
+		rx_ctl |= AX_RX_CTL_AM;
+	}
+
+	ax8817x_write_cmd_async(dev, AX_CMD_WRITE_RX_CTL, rx_ctl, 0, 0, NULL);
+}
+
+static void ax88178_set_multicast(struct net_device *net)
+{
+	struct usbnet *dev = netdev_priv(net);
+	struct ax8817x_data *data = (struct ax8817x_data *)&dev->data;
+	u16 rx_ctl = (AX_RX_CTL_START | AX_RX_CTL_AB |  AX_RX_CTL_MFB);
+	int mc_count;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 35)
+	mc_count = net->mc_count;
+#else
+	mc_count = netdev_mc_count(net);
+#endif
+
+	if (net->flags & IFF_PROMISC) {
+		rx_ctl |= AX_RX_CTL_PRO;
+	} else if (net->flags & IFF_ALLMULTI
+		   || mc_count > AX_MAX_MCAST) {
+		rx_ctl |= AX_RX_CTL_AMALL;
+	} else if (mc_count == 0) {
+		/* just broadcast and directed */
+	} else {
+		/* We use the 20 byte dev->data
+		 * for our 8 byte filter buffer
+		 * to avoid allocating memory that
+		 * is tricky to free later */
+		u32 crc_bits;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 35)
+		struct dev_mc_list *mc_list = net->mc_list;
+		int i;
+
+		memset(data->multi_filter, 0, AX_MCAST_FILTER_SIZE);
+
+		/* Build the multicast hash filter. */
+		for (i = 0; i < net->mc_count; i++) {
+			crc_bits =
+			    ether_crc(ETH_ALEN,
+				      mc_list->dmi_addr) >> 26;
+			data->multi_filter[crc_bits >> 3] |=
+			    1 << (crc_bits & 7);
+			mc_list = mc_list->next;
+		}
+#else
+		struct netdev_hw_addr *ha = NULL;
+		memset(data->multi_filter, 0, AX_MCAST_FILTER_SIZE);
+		netdev_for_each_mc_addr(ha, net) {
+			crc_bits = ether_crc(ETH_ALEN, ha->addr) >> 26;
+			data->multi_filter[crc_bits >> 3] |=
+				1 << (crc_bits & 7);
+		}
+#endif
+		ax8817x_write_cmd_async(dev, AX_CMD_WRITE_MULTI_FILTER, 0, 0,
+				   AX_MCAST_FILTER_SIZE, data->multi_filter);
+
+		rx_ctl |= AX_RX_CTL_AM;
+	}
+
+	ax8817x_write_cmd_async(dev, AX_CMD_WRITE_RX_CTL, rx_ctl, 0, 0, NULL);
+}
+
+static void ax88772b_set_multicast(struct net_device *net)
+{
+	struct usbnet *dev = netdev_priv(net);
+	struct ax8817x_data *data = (struct ax8817x_data *)&dev->data;
+	u16 rx_ctl = (AX_RX_CTL_START | AX_RX_CTL_AB | AX_RX_HEADER_DEFAULT);
+	int mc_count;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 35)
+	mc_count = net->mc_count;
+#else
+	mc_count = netdev_mc_count(net);
+#endif
+
+	if (net->flags & IFF_PROMISC) {
+		rx_ctl |= AX_RX_CTL_PRO;
+	} else if (net->flags & IFF_ALLMULTI
+		   || mc_count > AX_MAX_MCAST) {
+		rx_ctl |= AX_RX_CTL_AMALL;
+	} else if (mc_count == 0) {
+		/* just broadcast and directed */
+	} else {
+		/* We use the 20 byte dev->data
+		 * for our 8 byte filter buffer
+		 * to avoid allocating memory that
+		 * is tricky to free later */
+		u32 crc_bits;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 35)
+		struct dev_mc_list *mc_list = net->mc_list;
+		int i;
+
+		memset(data->multi_filter, 0, AX_MCAST_FILTER_SIZE);
+
+		/* Build the multicast hash filter. */
+		for (i = 0; i < net->mc_count; i++) {
+			crc_bits =
+			    ether_crc(ETH_ALEN,
+				      mc_list->dmi_addr) >> 26;
+			data->multi_filter[crc_bits >> 3] |=
+			    1 << (crc_bits & 7);
+			mc_list = mc_list->next;
+		}
+#else
+		struct netdev_hw_addr *ha = NULL;
+		memset(data->multi_filter, 0, AX_MCAST_FILTER_SIZE);
+		netdev_for_each_mc_addr(ha, net) {
+			crc_bits = ether_crc(ETH_ALEN, ha->addr) >> 26;
+			data->multi_filter[crc_bits >> 3] |=
+				1 << (crc_bits & 7);
+		}
+#endif
+		ax8817x_write_cmd_async(dev, AX_CMD_WRITE_MULTI_FILTER, 0, 0,
+				   AX_MCAST_FILTER_SIZE, data->multi_filter);
+
+		rx_ctl |= AX_RX_CTL_AM;
+	}
+
+	ax8817x_write_cmd_async(dev, AX_CMD_WRITE_RX_CTL, rx_ctl, 0, 0, NULL);
+}
+
+static int ax8817x_mdio_read(struct net_device *netdev, int phy_id, int loc)
+{
+	struct usbnet *dev = netdev_priv(netdev);
+	u16 *res, ret;
+	u8* smsr;
+	int i = 0;
+
+	res = kmalloc(2, GFP_ATOMIC);
+	if (!res)
+		return 0;
+
+	do {
+		ax8817x_write_cmd(dev, AX_CMD_SET_SW_MII, 0, 0, 0, NULL);
+		
+		msleep(1);
+
+		smsr = (u8*) res;
+		ax8817x_read_cmd(dev, AX_CMD_READ_STATMNGSTS_REG, 0, 0, 1, smsr);
+	} while (!(*smsr & AX_HOST_EN) && (i++ < 30));
+	
+	ax8817x_read_cmd(dev, AX_CMD_READ_MII_REG, phy_id, (__u16)loc, 2, res);
+	ax8817x_write_cmd(dev, AX_CMD_SET_HW_MII, 0, 0, 0, NULL);
+
+	ret = *res & 0xffff;
+	kfree(res);
+
+	return ret;
+}
+
+static int
+ax8817x_swmii_mdio_read(struct net_device *netdev, int phy_id, int loc)
+{
+	struct usbnet *dev = netdev_priv(netdev);
+	u16 *res;
+	u16 ret;
+
+	res = kmalloc(2, GFP_ATOMIC);
+	if (!res)
+		return 0;
+
+	ax8817x_read_cmd(dev, AX_CMD_READ_MII_REG, phy_id,
+				(__u16)loc, 2, res);
+
+	ret = *res & 0xffff;
+	kfree(res);
+
+	return ret;
+}
+
+/* same as above, but converts resulting value to cpu byte order */
+static int ax8817x_mdio_read_le(struct net_device *netdev, int phy_id, int loc)
+{
+	return le16_to_cpu(ax8817x_mdio_read(netdev, phy_id, loc));
+}
+
+static int
+ax8817x_swmii_mdio_read_le(struct net_device *netdev, int phy_id, int loc)
+{
+	return le16_to_cpu(ax8817x_swmii_mdio_read(netdev, phy_id, loc));
+}
+
+static void
+ax8817x_mdio_write(struct net_device *netdev, int phy_id, int loc, int val)
+{
+	struct usbnet *dev = netdev_priv(netdev);
+	u16 *res;
+	u8* smsr;
+	int i = 0;
+
+	res = kmalloc(2, GFP_ATOMIC);
+	if (!res)
+		return;
+	smsr = (u8 *) res;
+
+	do {
+		ax8817x_write_cmd(dev, AX_CMD_SET_SW_MII, 0, 0, 0, NULL);
+
+		msleep(1);
+
+		ax8817x_read_cmd(dev, AX_CMD_READ_STATMNGSTS_REG, 0, 0, 1, smsr);
+	} while (!(*smsr & AX_HOST_EN) && (i++ < 30));	
+	
+	*res = val;
+
+	ax8817x_write_cmd(dev, AX_CMD_WRITE_MII_REG, phy_id,
+			  (__u16)loc, 2, res);
+	ax8817x_write_cmd(dev, AX_CMD_SET_HW_MII, 0, 0, 0, NULL);
+
+	kfree(res);
+}
+
+static void ax8817x_swmii_mdio_write(struct net_device *netdev, int phy_id,
+				     int loc, int val)
+{
+	struct usbnet *dev = netdev_priv(netdev);
+	u16 *res;
+
+	res = kmalloc(2, GFP_ATOMIC);
+	if (!res)
+		return;
+	*res = val;
+
+	ax8817x_write_cmd(dev, AX_CMD_WRITE_MII_REG, phy_id,
+				(__u16)loc, 2, res);
+
+	kfree(res);
+}
+
+static void
+ax88772b_mdio_write(struct net_device *netdev, int phy_id, int loc, int val)
+{
+	struct usbnet *dev = netdev_priv(netdev);
+	u16 *res;
+
+	res = kmalloc(2, GFP_ATOMIC);
+	if (!res)
+		return;
+	*res = val;
+
+	ax8817x_write_cmd(dev, AX_CMD_SET_SW_MII, 0, 0, 0, NULL);
+	ax8817x_write_cmd(dev, AX_CMD_WRITE_MII_REG, phy_id,
+				(__u16)loc, 2, res);
+
+	if (loc == MII_ADVERTISE) {
+		*res = cpu_to_le16(BMCR_ANENABLE | BMCR_ANRESTART);
+		ax8817x_write_cmd(dev, AX_CMD_WRITE_MII_REG, phy_id,
+				(__u16)MII_BMCR, 2, res);
+	}
+
+	ax8817x_write_cmd(dev, AX_CMD_SET_HW_MII, 0, 0, 0, NULL);
+
+	kfree(res);
+}
+
+/* same as above, but converts new value to le16 byte order before writing */
+static void
+ax8817x_mdio_write_le(struct net_device *netdev, int phy_id, int loc, int val)
+{
+	ax8817x_mdio_write(netdev, phy_id, loc, cpu_to_le16(val));
+}
+
+static void ax8817x_swmii_mdio_write_le(struct net_device *netdev,
+			int phy_id, int loc, int val)
+{
+	ax8817x_swmii_mdio_write(netdev, phy_id, loc, cpu_to_le16(val));
+}
+
+static void
+ax88772b_mdio_write_le(struct net_device *netdev, int phy_id, int loc, int val)
+{
+	ax88772b_mdio_write(netdev, phy_id, loc, cpu_to_le16(val));
+}
+
+static int ax88772_suspend(struct usb_interface *intf,
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 10)
+			   pm_message_t message)
+#else
+			   u32 message)
+#endif
+{
+	struct usbnet *dev = usb_get_intfdata(intf);
+	u16 *medium;
+
+	medium = kmalloc(2, GFP_ATOMIC);
+	if (!medium)
+		return axusbnet_suspend(intf, message);
+
+	ax8817x_read_cmd(dev, AX_CMD_READ_MEDIUM_MODE, 0, 0, 2, medium);
+	ax8817x_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE,
+			(*medium & ~AX88772_MEDIUM_RX_ENABLE), 0, 0, NULL);
+
+	kfree(medium);
+	return axusbnet_suspend(intf, message);
+}
+
+static int ax88772b_suspend(struct usb_interface *intf,
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 10)
+			    pm_message_t message)
+#else
+			    u32 message)
+#endif
+{
+	struct usbnet *dev = usb_get_intfdata(intf);
+	struct ax88772b_data *ax772b_data = (struct ax88772b_data *)dev->priv;
+	u16 *tmp16;
+	u8 *opt;
+
+	tmp16 = kmalloc(2, GFP_ATOMIC);
+	if (!tmp16)
+		return axusbnet_suspend(intf, message);
+	opt = (u8 *)tmp16;
+#if 0
+	/* Read Wake-up Frame Array Register (Mask Wakeup Timer) */
+	ax8817x_read_cmd(dev, AX_CMD_READ_WKFARY, 0x11, 0, 4, &tmp32);
+	tmp32 &= 0xFFF0FFFF;
+	/* 8 second */
+	tmp32 |= 0x00020000;
+	ax8817x_write_cmd(dev, AX_CMD_WRITE_WKFARY, 0x11, 0, 4, &tmp32);
+#endif
+	/* Preserve BMCR for restoring */
+	ax772b_data->presvd_phy_bmcr = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, MII_BMCR);
+
+	/* Preserve Advertisement control reg for restoring */
+	ax772b_data->presvd_phy_advertise = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, MII_ADVERTISE);
+
+	ax8817x_read_cmd(dev, AX_CMD_READ_MEDIUM_MODE, 0, 0, 2, tmp16);
+	ax8817x_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE,
+			  (*tmp16 & ~AX88772_MEDIUM_RX_ENABLE),
+			  0, 0, NULL);
+
+	ax8817x_read_cmd(dev, AX_CMD_READ_MONITOR_MODE, 0, 0, 1, opt);
+	if (!(*opt & AX_MONITOR_LINK) && !(*opt & AX_MONITOR_MAGIC)) {
+		ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
+				  AX_SWRESET_IPRL | AX_SWRESET_IPPD,
+				  0, 0, NULL);
+				  
+	} else {
+
+		if (ax772b_data->psc & AX_SWRESET_WOLLP) {
+			*tmp16 = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id,
+						      MII_BMCR);
+			ax8817x_mdio_write_le(dev->net, dev->mii.phy_id,
+					      MII_BMCR, *tmp16 | BMCR_ANENABLE);
+
+			ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
+					  AX_SWRESET_IPRL | ax772b_data->psc,
+					  0, 0, NULL);
+		}
+
+		if (ax772b_data->psc &
+		    (AX_SWRESET_IPPSL_0 | AX_SWRESET_IPPSL_1)) {
+			*opt |= AX_MONITOR_LINK;
+			ax8817x_write_cmd(dev, AX_CMD_WRITE_MONITOR_MODE, *opt,
+					  0, 0, NULL);
+		}
+	}
+
+	kfree(tmp16);
+	return axusbnet_suspend(intf, message);
+}
+
+static int ax88772_resume(struct usb_interface *intf)
+{
+	struct usbnet *dev = usb_get_intfdata(intf);
+
+	netif_carrier_off(dev->net);
+
+	return axusbnet_resume(intf);
+}
+
+static int ax88772b_resume(struct usb_interface *intf)
+{
+	struct usbnet *dev = usb_get_intfdata(intf);
+	struct ax88772b_data *ax772b_data = (struct ax88772b_data *)dev->priv;
+
+	if (ax772b_data->psc & AX_SWRESET_WOLLP) {
+		ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
+				  AX_SWRESET_IPRL | (ax772b_data->psc & 0x7FFF),
+				  0, 0, NULL);
+	}
+
+	if (ax772b_data->psc & (AX_SWRESET_IPPSL_0 | AX_SWRESET_IPPSL_1))
+		ax88772a_phy_powerup(dev);
+
+	netif_carrier_off(dev->net);
+
+	if (ax772b_data->OperationMode == OPERATION_PHY_MODE)
+		netif_carrier_on(dev->net);
+
+	return axusbnet_resume(intf);
+}
+
+static int ax88172_link_reset(struct usbnet *dev)
+{
+	u16 lpa;
+	u16 adv;
+	u16 res;
+	u8 mode;
+
+	mode = AX_MEDIUM_TX_ABORT_ALLOW | AX_MEDIUM_FLOW_CONTROL_EN;
+	lpa = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, MII_LPA);
+	adv = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, MII_ADVERTISE);
+	res = mii_nway_result(lpa|adv);
+	if (res & LPA_DUPLEX)
+		mode |= AX_MEDIUM_FULL_DUPLEX;
+	ax8817x_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE, mode, 0, 0, NULL);
+
+	return 0;
+}
+
+static void
+ax8817x_get_wol(struct net_device *net, struct ethtool_wolinfo *wolinfo)
+{
+	struct usbnet *dev = netdev_priv(net);
+	u8 *opt;
+
+	wolinfo->supported = 0;
+	wolinfo->wolopts = 0;
+
+	opt = kmalloc(1, GFP_KERNEL);
+	if (!opt)
+		return;
+
+	if (ax8817x_read_cmd(dev, AX_CMD_READ_MONITOR_MODE, 0, 0, 1, opt) < 0) {
+		kfree(opt);
+		return;
+	}
+
+	wolinfo->supported = WAKE_PHY | WAKE_MAGIC;
+
+	if (*opt & AX_MONITOR_LINK)
+		wolinfo->wolopts |= WAKE_PHY;
+	if (*opt & AX_MONITOR_MAGIC)
+		wolinfo->wolopts |= WAKE_MAGIC;
+
+	kfree(opt);
+}
+
+static int
+ax8817x_set_wol(struct net_device *net, struct ethtool_wolinfo *wolinfo)
+{
+	struct usbnet *dev = netdev_priv(net);
+	u8 *opt;
+
+	opt = kmalloc(1, GFP_KERNEL);
+	if (!opt)
+		return -ENOMEM;
+
+	*opt = 0;
+	if (wolinfo->wolopts & WAKE_PHY)
+		*opt |= AX_MONITOR_LINK;
+	if (wolinfo->wolopts & WAKE_MAGIC)
+		*opt |= AX_MONITOR_MAGIC;
+
+	ax8817x_write_cmd(dev, AX_CMD_WRITE_MONITOR_MODE, *opt, 0, 0, NULL);
+
+	kfree(opt);
+	return 0;
+}
+
+static int ax8817x_get_eeprom_len(struct net_device *net)
+{
+	return AX_EEPROM_LEN;
+}
+
+static int ax8817x_get_eeprom(struct net_device *net,
+			      struct ethtool_eeprom *eeprom, u8 *data)
+{
+	struct usbnet *dev = netdev_priv(net);
+	u16 *ebuf = (u16 *)data;
+	int i;
+
+	/* Crude hack to ensure that we don't overwrite memory
+	 * if an odd length is supplied
+	 */
+	if (eeprom->len % 2)
+		return -EINVAL;
+
+	eeprom->magic = AX_EEPROM_MAGIC;
+
+	/* ax8817x returns 2 bytes from eeprom on read */
+	for (i = 0; i < eeprom->len / 2; i++) {
+		if (ax8817x_read_cmd(dev, AX_CMD_READ_EEPROM,
+				     eeprom->offset + i, 0, 2,
+				     &ebuf[i]) < 0)
+			return -EINVAL;
+	}
+	return 0;
+}
+
+static void ax8817x_get_drvinfo(struct net_device *net,
+				struct ethtool_drvinfo *info)
+{
+	/* Inherit standard device info */
+	axusbnet_get_drvinfo(net, info);
+	info->eedump_len = 0x3e;
+}
+
+static int ax8817x_get_settings(struct net_device *net, struct ethtool_cmd *cmd)
+{
+	struct usbnet *dev = netdev_priv(net);
+	return mii_ethtool_gset(&dev->mii, cmd);
+}
+
+static int ax8817x_set_settings(struct net_device *net, struct ethtool_cmd *cmd)
+{
+	struct usbnet *dev = netdev_priv(net);
+	return mii_ethtool_sset(&dev->mii, cmd);
+}
+
+/* We need to override some ethtool_ops so we require our
+   own structure so we don't interfere with other usbnet
+   devices that may be connected at the same time. */
+static struct ethtool_ops ax8817x_ethtool_ops = {
+	.get_drvinfo		= ax8817x_get_drvinfo,
+	.get_link		= ethtool_op_get_link,
+	.get_msglevel		= axusbnet_get_msglevel,
+	.set_msglevel		= axusbnet_set_msglevel,
+	.get_wol		= ax8817x_get_wol,
+	.set_wol		= ax8817x_set_wol,
+	.get_eeprom_len	= ax8817x_get_eeprom_len,
+	.get_eeprom		= ax8817x_get_eeprom,
+	.get_settings		= ax8817x_get_settings,
+	.set_settings		= ax8817x_set_settings,
+};
+
+static int ax8817x_ioctl(struct net_device *net, struct ifreq *rq, int cmd)
+{
+	struct usbnet *dev = netdev_priv(net);
+
+	return generic_mii_ioctl(&dev->mii, if_mii(rq), cmd, NULL);
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 29)
+static const struct net_device_ops ax88x72_netdev_ops = {
+	.ndo_open			= axusbnet_open,
+	.ndo_stop			= axusbnet_stop,
+	.ndo_start_xmit	= axusbnet_start_xmit,
+	.ndo_tx_timeout	= axusbnet_tx_timeout,
+	.ndo_change_mtu	= axusbnet_change_mtu,
+	.ndo_get_stats		= axusbnet_get_stats,
+	.ndo_do_ioctl		= ax8817x_ioctl,
+	.ndo_set_mac_address		= ax8817x_set_mac_addr,
+	.ndo_validate_addr		= eth_validate_addr,
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(3, 2, 0)
+	.ndo_set_multicast_list	= ax8817x_set_multicast,
+#else
+	.ndo_set_rx_mode	= ax8817x_set_multicast,
+#endif
+};
+#endif
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 29)
+static const struct net_device_ops ax88178_netdev_ops = {
+	.ndo_open			= axusbnet_open,
+	.ndo_stop			= axusbnet_stop,
+	.ndo_start_xmit	= axusbnet_start_xmit,
+	.ndo_tx_timeout	= axusbnet_tx_timeout,
+	.ndo_change_mtu	= axusbnet_change_mtu,
+	.ndo_get_stats		= axusbnet_get_stats,
+	.ndo_do_ioctl		= ax8817x_ioctl,
+	.ndo_set_mac_address		= ax8817x_set_mac_addr,
+	.ndo_validate_addr		= eth_validate_addr,
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(3, 2, 0)
+	.ndo_set_multicast_list	= ax88178_set_multicast,
+#else
+	.ndo_set_rx_mode	= ax88178_set_multicast,
+#endif
+};
+#endif
+
+static int access_eeprom_mac(struct usbnet *dev, u8 *buf, u8 offset, bool wflag)
+{
+	int ret = 0, i;
+	u16* tmp = (u16*)buf;
+
+	if (wflag) {
+		ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_EEPROM_EN,
+						0, 0, 0, NULL);
+		if (ret < 0)
+			 return ret;
+
+		mdelay(15);
+	}
+
+	for (i = 0; i < (ETH_ALEN >> 1); i++) {
+		if (wflag) {
+			u16 wd = cpu_to_le16(*(tmp + i));
+			ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_EEPROM, offset + i,
+						wd, 0, NULL);
+			if (ret < 0)
+				break;
+
+			mdelay(15);
+		}
+		else {
+			ret = ax8817x_read_cmd(dev, AX_CMD_READ_EEPROM,
+					       offset + i, 0, 2, tmp + i);
+			if (ret < 0)
+				break;
+		}
+	}
+
+	if (!wflag) {
+		if (ret < 0) {
+			#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 34)
+				netdev_dbg(dev->net, "Failed to read MAC address from EEPROM: %d\n", ret);
+			#else
+				devdbg(dev, "Failed to read MAC address from EEPROM: %d\n", ret);
+			#endif
+			return ret;
+		}
+		memcpy(dev->net->dev_addr, buf, ETH_ALEN);
+	}
+	else {
+		ax8817x_write_cmd(dev, AX_CMD_WRITE_EEPROM_DIS,
+				  0, 0, 0, NULL);
+		if (ret < 0)
+			 return ret;
+
+		/* reload eeprom data */
+		ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS,
+					AXGPIOS_RSE, 0, 0, NULL);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int ax8817x_check_ether_addr(struct usbnet *dev)
+{
+	unsigned char *tmp = (unsigned char*)dev->net->dev_addr;
+	u8 default_mac[6] = {0, 0x0e, 0xc6, 0x87, 0x72, 0x01};
+
+	if (((*((u8*)tmp) == 0) && (*((u8*)tmp + 1) == 0) && (*((u8*)tmp + 2) == 0)) ||
+	    !is_valid_ether_addr((u8*)tmp) ||
+	    !memcmp(dev->net->dev_addr, default_mac, ETH_ALEN)) {
+		int i;
+
+		printk("Found invalid EEPROM MAC address value ");
+
+		for (i = 0; i < ETH_ALEN; i++) {
+			printk("%02X", *((u8*)tmp + i));
+			if (i != 5)
+				printk("-");
+		}
+		printk("\n");
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
+		eth_hw_addr_random(dev->net);
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36)
+		dev->net->addr_assign_type |= NET_ADDR_RANDOM;
+#endif
+		random_ether_addr(dev->net->dev_addr); 
+#endif
+		*tmp = 0;
+		*(tmp + 1) = 0x0E;
+		*(tmp + 2) = 0xC6;
+		*(tmp + 3) = 0x8F;
+
+		return -EADDRNOTAVAIL;	
+	} 
+	return 0;
+}
+
+static int ax8817x_get_mac(struct usbnet *dev, u8* buf)
+{
+	int ret = 0;
+	int err, i;
+
+	err = eth_platform_get_mac_address(&dev->udev->dev, buf);
+
+	if (err == 0)
+	{
+		netif_dbg(dev, ifup, dev->net, "MAC address read from Device Tree");
+
+		ret = is_valid_ether_addr((u8*)buf);
+		if(!ret) {
+			devwarn(dev, "MAC address read from Device Tree not valid.");
+		} else {
+			memcpy(dev->net->dev_addr, buf, ETH_ALEN);
+			}
+	}
+
+	if (err != 0 || ret != 1 ) {
+
+		ret = access_eeprom_mac(dev, buf, 0x04, 0);
+		if (ret < 0)
+			goto out;
+
+		if (ax8817x_check_ether_addr(dev)) {
+			ret = access_eeprom_mac(dev, dev->net->dev_addr, 0x04, 1);
+			if (ret < 0) {
+				deverr(dev, "Failed to write MAC to EEPROM: %d", ret);
+				goto out;
+			}
+
+			msleep(5);
+
+			ret = ax8817x_read_cmd(dev, AX88772_CMD_READ_NODE_ID,
+						0, 0, ETH_ALEN, buf);
+			if (ret < 0) {
+				deverr(dev, "Failed to read MAC address: %d", ret);
+				goto out;
+			}
+
+			for (i = 0; i < ETH_ALEN; i++)
+				if (*(dev->net->dev_addr + i) != *((u8*)buf + i)) {
+					devwarn(dev, "Found invalid EEPROM part or non-EEPROM");
+					break;
+				}
+		}
+	}
+
+	memcpy(dev->net->perm_addr, dev->net->dev_addr, ETH_ALEN);
+
+	/* Set the MAC address */
+	ax8817x_write_cmd (dev, AX88772_CMD_WRITE_NODE_ID, 0, 0,
+			   ETH_ALEN, dev->net->dev_addr);
+	
+	if (ret < 0) {
+		deverr(dev, "Failed to write MAC address: %d", ret);
+		goto out;
+	}
+
+	return 0;
+out:
+	return ret;
+}
+
+static int ax8817x_bind(struct usbnet *dev, struct usb_interface *intf)
+{
+	int ret = 0;
+	void *buf;
+	int i;
+	unsigned long gpio_bits = dev->driver_info->data;
+	struct ax8817x_data *data = (struct ax8817x_data *)&dev->data;
+
+	axusbnet_get_endpoints(dev, intf);
+
+	buf = kmalloc(ETH_ALEN, GFP_KERNEL);
+	if (!buf) {
+		ret = -ENOMEM;
+		goto out1;
+	}
+
+	/* Toggle the GPIOs in a manufacturer/model specific way */
+	for (i = 2; i >= 0; i--) {
+		ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS,
+					(gpio_bits >> (i * 8)) & 0xff,
+					0, 0, NULL);
+		if (ret < 0)
+			goto out2;
+
+		msleep(5);
+	}
+
+	ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL, 0x80, 0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "send AX_CMD_WRITE_RX_CTL failed: %d", ret);
+		goto out2;
+	}
+
+	/* Get the MAC address */
+	memset(buf, 0, ETH_ALEN);
+	ret = ax8817x_read_cmd(dev, AX_CMD_READ_NODE_ID, 0, 0, 6, buf);
+	if (ret < 0) {
+		deverr(dev, "read AX_CMD_READ_NODE_ID failed: %d", ret);
+		goto out2;
+	}
+	memcpy(dev->net->dev_addr, buf, ETH_ALEN);
+
+	/* Get the PHY id */
+	ret = ax8817x_read_cmd(dev, AX_CMD_READ_PHY_ID, 0, 0, 2, buf);
+	if (ret < 0) {
+		deverr(dev, "error on read AX_CMD_READ_PHY_ID: %02x", ret);
+		goto out2;
+	} else if (ret < 2) {
+		/* this should always return 2 bytes */
+		deverr(dev, "Read PHYID returned less than 2 bytes: ret=%02x",
+				ret);
+		ret = -EIO;
+		goto out2;
+	}
+
+	/* Initialize MII structure */
+	dev->mii.dev = dev->net;
+	dev->mii.mdio_read = ax8817x_mdio_read_le;
+	dev->mii.mdio_write = ax8817x_mdio_write_le;
+	dev->mii.phy_id_mask = 0x3f;
+	dev->mii.reg_num_mask = 0x1f;
+	dev->mii.phy_id = *((u8 *)buf + 1);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 30)
+	dev->net->do_ioctl = ax8817x_ioctl;
+	dev->net->set_multicast_list = ax8817x_set_multicast;
+	dev->net->set_mac_address = ax8817x_set_mac_addr;
+#else
+	dev->net->netdev_ops = &ax88x72_netdev_ops;
+#endif
+
+	dev->net->ethtool_ops = &ax8817x_ethtool_ops;
+
+	/* Register suspend and resume functions */
+	data->suspend = axusbnet_suspend;
+	data->resume = axusbnet_resume;
+
+	ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, MII_BMCR, BMCR_RESET);
+	ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, MII_ADVERTISE,
+		ADVERTISE_ALL | ADVERTISE_CSMA | ADVERTISE_PAUSE_CAP);
+	mii_nway_restart(&dev->mii);
+
+	printk(version);
+
+	return 0;
+out2:
+	kfree(buf);
+out1:
+	return ret;
+}
+
+static struct ethtool_ops ax88772_ethtool_ops = {
+	.get_drvinfo		= ax8817x_get_drvinfo,
+	.get_link		= ethtool_op_get_link,
+	.get_msglevel		= axusbnet_get_msglevel,
+	.set_msglevel		= axusbnet_set_msglevel,
+	.get_wol		= ax8817x_get_wol,
+	.set_wol		= ax8817x_set_wol,
+	.get_eeprom_len		= ax8817x_get_eeprom_len,
+	.get_eeprom		= ax8817x_get_eeprom,
+	.get_settings		= ax8817x_get_settings,
+	.set_settings		= ax8817x_set_settings,
+};
+
+static int ax88772_bind(struct usbnet *dev, struct usb_interface *intf)
+{
+	int ret;
+	void *buf;
+	struct ax8817x_data *data = (struct ax8817x_data *)&dev->data;
+	struct ax88772_data *ax772_data = NULL;
+
+	axusbnet_get_endpoints(dev, intf);
+
+	buf = kmalloc(6, GFP_KERNEL);
+	if (!buf) {
+		deverr(dev, "Cannot allocate memory for buffer");
+		ret = -ENOMEM;
+		goto out1;
+	}
+
+	ax772_data = kmalloc(sizeof(*ax772_data), GFP_KERNEL);
+	if (!ax772_data) {
+		deverr(dev, "Cannot allocate memory for AX88772 data");
+		kfree(buf);
+		return -ENOMEM;
+	}
+
+	memset(ax772_data, 0, sizeof(*ax772_data));
+	dev->priv = ax772_data;
+
+	ax772_data->ax_work = create_singlethread_workqueue("ax88772");
+	if (!ax772_data->ax_work) {
+		kfree(ax772_data);
+		kfree(buf);
+		return -ENOMEM;
+	}
+
+	ax772_data->dev = dev;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20)
+	INIT_WORK(&ax772_data->check_link, ax88772_link_reset, dev);
+#else
+	INIT_WORK(&ax772_data->check_link, ax88772_link_reset);
+#endif
+
+	/* reload eeprom data */
+	ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS, 0x00B0, 0, 0, NULL);
+	if (ret < 0)
+		goto out2;
+
+	msleep(5);
+
+	/* Initialize MII structure */
+	dev->mii.dev = dev->net;
+	dev->mii.mdio_read = ax8817x_mdio_read_le;
+	dev->mii.mdio_write = ax8817x_mdio_write_le;
+	dev->mii.phy_id_mask = 0xff;
+	dev->mii.reg_num_mask = 0xff;
+
+	/* Get the PHY id */
+	ret = ax8817x_read_cmd(dev, AX_CMD_READ_PHY_ID, 0, 0, 2, buf);
+	if (ret < 0) {
+		deverr(dev, "Error reading PHY ID: %02x", ret);
+		goto out2;
+	} else if (ret < 2) {
+		/* this should always return 2 bytes */
+		deverr(dev, "Read PHYID returned less than 2 bytes: ret=%02x",
+		    ret);
+		ret = -EIO;
+		goto out2;
+	}
+	dev->mii.phy_id = *((u8 *)buf + 1);
+
+	if (dev->mii.phy_id == 0x10) {
+		ret = ax8817x_write_cmd(dev, AX_CMD_SW_PHY_SELECT,
+					0x0001, 0, 0, NULL);
+		if (ret < 0) {
+			deverr(dev, "Select PHY #1 failed: %d", ret);
+			goto out2;
+		}
+
+		ret = ax8817x_write_cmd(dev, AX_CMD_SW_RESET, AX_SWRESET_IPPD,
+					0, 0, NULL);
+		if (ret < 0) {
+			deverr(dev, "Failed to power down PHY: %d", ret);
+			goto out2;
+		}
+
+		msleep(150);
+
+		ret = ax8817x_write_cmd(dev, AX_CMD_SW_RESET, AX_SWRESET_CLEAR,
+					0, 0, NULL);
+		if (ret < 0) {
+			deverr(dev, "Failed to perform software reset: %d",
+			       ret);
+			goto out2;
+		}
+
+		msleep(150);
+
+		ret = ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
+					AX_SWRESET_IPRL | AX_SWRESET_PRL,
+					0, 0, NULL);
+		if (ret < 0) {
+			deverr(dev,
+			      "Failed to set PHY reset control: %d", ret);
+			goto out2;
+		}
+	} else {
+		ret = ax8817x_write_cmd(dev, AX_CMD_SW_PHY_SELECT,
+					0x0000, 0, 0, NULL);
+		if (ret < 0) {
+			deverr(dev, "Select PHY #1 failed: %d", ret);
+			goto out2;
+		}
+
+		ret = ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
+					AX_SWRESET_IPPD | AX_SWRESET_PRL,
+					0, 0, NULL);
+		if (ret < 0) {
+			deverr(dev, "Failed to power down internal PHY: %d",
+			       ret);
+			goto out2;
+		}
+	}
+
+	msleep(150);
+
+	ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL,
+				0x0000, 0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Failed to reset RX_CTL: %d", ret);
+		goto out2;
+	}
+
+	/* Get the MAC address */
+	memset(buf, 0, ETH_ALEN);
+	ret = ax8817x_get_mac(dev, buf);
+	if (ret < 0) {
+		deverr(dev, "Get HW address failed: %d", ret);
+		goto out2;
+	}
+
+	ret = ax8817x_write_cmd(dev, AX_CMD_SET_SW_MII, 0, 0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Enabling software MII failed: %d", ret);
+		goto out2;
+	}
+
+	if (dev->mii.phy_id == 0x10) {
+		ret = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, 2);
+		if (ret != 0x003b) {
+			deverr(dev, "Read PHY register 2 must be 0x3b00: %d",
+			       ret);
+			goto out2;
+		}
+
+		ret = ax8817x_write_cmd(dev, AX_CMD_SW_RESET, AX_SWRESET_PRL,
+					0, 0, NULL);
+		if (ret < 0) {
+			deverr(dev, "Set external PHY reset pin level: %d",
+			       ret);
+			goto out2;
+		}
+		msleep(150);
+
+		ret = ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
+					AX_SWRESET_IPRL | AX_SWRESET_PRL,
+					0, 0, NULL);
+		if (ret < 0) {
+			deverr(dev,
+			       "Set Internal/External PHY reset control: %d",
+			       ret);
+			goto out2;
+		}
+		msleep(150);
+	}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 30)
+	dev->net->do_ioctl = ax8817x_ioctl;
+	dev->net->set_multicast_list = ax8817x_set_multicast;
+	dev->net->set_mac_address = ax8817x_set_mac_addr;
+#else
+	dev->net->netdev_ops = &ax88x72_netdev_ops;
+#endif
+
+	dev->net->ethtool_ops = &ax88772_ethtool_ops;
+
+	/* Register suspend and resume functions */
+	data->suspend = ax88772_suspend;
+	data->resume = ax88772_resume;
+
+	ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, MII_BMCR, BMCR_RESET);
+	ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, MII_ADVERTISE,
+			ADVERTISE_ALL | ADVERTISE_CSMA);
+
+	mii_nway_restart(&dev->mii);
+	ax772_data->autoneg_start = jiffies;
+	ax772_data->Event = WAIT_AUTONEG_COMPLETE;
+
+	ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE, 0, 0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Write medium mode register: %d", ret);
+		goto out2;
+	}
+
+	ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_IPG0,
+				AX88772_IPG0_DEFAULT |
+				(AX88772_IPG1_DEFAULT << 8),
+				AX88772_IPG2_DEFAULT, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Write IPG,IPG1,IPG2 failed: %d", ret);
+		goto out2;
+	}
+
+	ret = ax8817x_write_cmd(dev, AX_CMD_SET_HW_MII, 0, 0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Failed to set hardware MII: %02x", ret);
+		goto out2;
+	}
+
+	/* Set RX_CTL to default values with 2k buffer, and enable cactus */
+	ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL, 0x0088, 0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Reset RX_CTL failed: %d", ret);
+		goto out2;
+	}
+
+	/* Asix framing packs multiple eth frames into a 2K usb bulk transfer */
+	if (dev->driver_info->flags & FLAG_FRAMING_AX) {
+		/* hard_mtu  is still the default - the device does not support
+		   jumbo eth frames */
+		dev->rx_urb_size = 2048;
+	}
+
+	kfree(buf);
+	printk(version);
+	return 0;
+
+out2:
+	destroy_workqueue(ax772_data->ax_work);
+	kfree(ax772_data);
+	kfree(buf);
+out1:
+	return ret;
+}
+
+static void ax88772_unbind(struct usbnet *dev, struct usb_interface *intf)
+{
+	struct ax88772_data *ax772_data = (struct ax88772_data *)dev->priv;
+
+	if (ax772_data) {
+		flush_workqueue(ax772_data->ax_work);
+		destroy_workqueue(ax772_data->ax_work);
+
+		/* stop MAC operation */
+		ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL, AX_RX_CTL_STOP,
+				  0, 0, NULL);
+
+		/* Power down PHY */
+		ax8817x_write_cmd(dev, AX_CMD_SW_RESET, AX_SWRESET_IPPD,
+				  0, 0, NULL);
+
+		kfree(ax772_data);
+	}
+}
+
+static int ax88772a_phy_powerup(struct usbnet *dev)
+{
+	int ret;
+	/* set the embedded Ethernet PHY in power-down state */
+	ret = ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
+				AX_SWRESET_IPPD | AX_SWRESET_IPRL, 0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Failed to power down PHY: %d", ret);
+		return ret;
+	}
+
+	msleep(10);
+
+	/* set the embedded Ethernet PHY in power-up state */
+	ret = ax8817x_write_cmd(dev, AX_CMD_SW_RESET, AX_SWRESET_IPRL,
+				0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Failed to reset PHY: %d", ret);
+		return ret;
+	}
+
+	msleep(600);
+
+	/* set the embedded Ethernet PHY in reset state */
+	ret = ax8817x_write_cmd(dev, AX_CMD_SW_RESET, AX_SWRESET_CLEAR,
+				0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Failed to power up PHY: %d", ret);
+		return ret;
+	}
+
+	/* set the embedded Ethernet PHY in power-up state */
+	ret = ax8817x_write_cmd(dev, AX_CMD_SW_RESET, AX_SWRESET_IPRL,
+				0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Failed to reset PHY: %d", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int ax88772a_bind(struct usbnet *dev, struct usb_interface *intf)
+{
+	int ret = -EIO;
+	void *buf;
+	struct ax8817x_data *data = (struct ax8817x_data *)&dev->data;
+	struct ax88772a_data *ax772a_data = NULL;
+
+	printk(version);
+
+	axusbnet_get_endpoints(dev, intf);
+
+	buf = kmalloc(6, GFP_KERNEL);
+	if (!buf) {
+		deverr(dev, "Cannot allocate memory for buffer");
+		ret = -ENOMEM;
+		goto out1;
+	}
+
+	ax772a_data = kmalloc(sizeof(*ax772a_data), GFP_KERNEL);
+	if (!ax772a_data) {
+		deverr(dev, "Cannot allocate memory for AX88772A data");
+		kfree(buf);
+		return -ENOMEM;
+	}
+	memset(ax772a_data, 0, sizeof(*ax772a_data));
+	dev->priv = ax772a_data;
+
+	ax772a_data->ax_work = create_singlethread_workqueue("ax88772a");
+	if (!ax772a_data->ax_work) {
+		kfree(ax772a_data);
+		kfree(buf);
+		return -ENOMEM;
+	}
+
+	ax772a_data->dev = dev;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20)
+	INIT_WORK(&ax772a_data->check_link, ax88772a_link_reset, dev);
+#else
+	INIT_WORK(&ax772a_data->check_link, ax88772a_link_reset);
+#endif
+
+	/* Get the EEPROM data*/
+	ret = ax8817x_read_cmd(dev, AX_CMD_READ_EEPROM, 0x0017, 0, 2,
+			       (void *)&ax772a_data->EepromData);
+	if (ret < 0) {
+		deverr(dev, "read SROM address 17h failed: %d", ret);
+		goto out2;
+	}
+	le16_to_cpus(&ax772a_data->EepromData);
+	/* End of get EEPROM data */
+
+	/* reload eeprom data */
+	ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS,
+				AXGPIOS_RSE, 0, 0, NULL);
+	if (ret < 0)
+		goto out2;
+
+	msleep(5);
+
+	/* Initialize MII structure */
+	dev->mii.dev = dev->net;
+	dev->mii.mdio_read = ax8817x_mdio_read_le;
+	dev->mii.mdio_write = ax8817x_mdio_write_le;
+	dev->mii.phy_id_mask = 0xff;
+	dev->mii.reg_num_mask = 0xff;
+
+	/* Get the PHY id */
+	ret = ax8817x_read_cmd(dev, AX_CMD_READ_PHY_ID, 0, 0, 2, buf);
+	if (ret < 0) {
+		deverr(dev, "Error reading PHY ID: %02x", ret);
+		goto out2;
+	} else if (ret < 2) {
+		/* this should always return 2 bytes */
+		deverr(dev, "Read PHYID returned less than 2 bytes: ret=%02x",
+			ret);
+		goto out2;
+	}
+	dev->mii.phy_id = *((u8 *)buf + 1);
+
+	if (dev->mii.phy_id != 0x10) {
+		deverr(dev, "Got wrong PHY ID: %02x", dev->mii.phy_id);
+		goto out2;
+	}
+
+	/* select the embedded 10/100 Ethernet PHY */
+	ret = ax8817x_write_cmd(dev, AX_CMD_SW_PHY_SELECT,
+			AX_PHYSEL_SSEN | AX_PHYSEL_PSEL | AX_PHYSEL_SSMII,
+			0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Select PHY #1 failed: %d", ret);
+		goto out2;
+	}
+
+	ret = ax88772a_phy_powerup(dev);
+	if (ret < 0)
+		goto out2;
+
+	/* stop MAC operation */
+	ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL, AX_RX_CTL_STOP,
+				0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Reset RX_CTL failed: %d", ret);
+		goto out2;
+	}
+
+	/* Get the MAC address */
+	memset(buf, 0, ETH_ALEN);
+	ret = ax8817x_get_mac(dev, buf);
+	if (ret < 0) {
+		deverr(dev, "Get HW address failed: %d", ret);
+		goto out2;
+	}	
+
+	/* make sure the driver can enable sw mii operation */
+	ret = ax8817x_write_cmd(dev, AX_CMD_SET_SW_MII, 0, 0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Enabling software MII failed: %d", ret);
+		goto out2;
+	}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 30)
+	dev->net->do_ioctl = ax8817x_ioctl;
+	dev->net->set_multicast_list = ax8817x_set_multicast;
+	dev->net->set_mac_address = ax8817x_set_mac_addr;
+#else
+	dev->net->netdev_ops = &ax88x72_netdev_ops;
+#endif
+
+	dev->net->ethtool_ops = &ax88772_ethtool_ops;
+
+	/* Register suspend and resume functions */
+	data->suspend = ax88772_suspend;
+	data->resume = ax88772_resume;
+
+	ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, MII_BMCR, BMCR_RESET);
+	ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, MII_ADVERTISE,
+			ADVERTISE_ALL | ADVERTISE_CSMA | ADVERTISE_PAUSE_CAP);
+
+	mii_nway_restart(&dev->mii);
+	ax772a_data->autoneg_start = jiffies;
+	ax772a_data->Event = WAIT_AUTONEG_COMPLETE;
+
+	ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE,
+				0, 0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Write medium mode register: %d", ret);
+		goto out2;
+	}
+
+	ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_IPG0,
+			AX88772A_IPG0_DEFAULT | AX88772A_IPG1_DEFAULT << 8,
+			AX88772A_IPG2_DEFAULT, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Write IPG,IPG1,IPG2 failed: %d", ret);
+		goto out2;
+	}
+
+	memset(buf, 0, 4);
+	ret = ax8817x_read_cmd(dev, AX_CMD_READ_IPG012, 0, 0, 3, buf);
+	*((u8 *)buf + 3) = 0x00;
+	if (ret < 0) {
+		deverr(dev, "Failed to read IPG,IPG1,IPG2 failed: %d", ret);
+		goto out2;
+	} else {
+		__u32 tmp32 = *((u32*)buf);
+		le32_to_cpus(&tmp32);
+		if (tmp32 != (AX88772A_IPG2_DEFAULT << 16 |
+			AX88772A_IPG1_DEFAULT << 8 | AX88772A_IPG0_DEFAULT)) {
+			printk("Non-authentic ASIX product\nASIX does not support it\n");
+			ret = -ENODEV;		
+			goto out2;
+		}
+	}
+
+	/* Set RX_CTL to default values with 2k buffer, and enable cactus */
+	ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL,
+			(AX_RX_CTL_START | AX_RX_CTL_AB),
+			0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Reset RX_CTL failed: %d", ret);
+		goto out2;
+	}
+
+	/* Asix framing packs multiple eth frames into a 2K usb bulk transfer */
+	if (dev->driver_info->flags & FLAG_FRAMING_AX) {
+		/* hard_mtu  is still the default - the device does not support
+		   jumbo eth frames */
+		dev->rx_urb_size = 2048;
+	}
+
+	kfree(buf);
+
+	return ret;
+out2:
+	destroy_workqueue(ax772a_data->ax_work);
+	kfree(ax772a_data);
+	kfree(buf);
+out1:
+	return ret;
+}
+
+static void ax88772a_unbind(struct usbnet *dev, struct usb_interface *intf)
+{
+	struct ax88772a_data *ax772a_data = (struct ax88772a_data *)dev->priv;
+
+	if (ax772a_data) {
+
+		flush_workqueue(ax772a_data->ax_work);
+		destroy_workqueue(ax772a_data->ax_work);
+
+		/* stop MAC operation */
+		ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL,
+					AX_RX_CTL_STOP, 0, 0, NULL);
+
+		/* Power down PHY */
+		ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
+					AX_SWRESET_IPPD, 0, 0, NULL);
+
+		kfree(ax772a_data);
+	}
+}
+
+static int ax88772b_set_csums(struct usbnet *dev)
+{
+	struct ax88772b_data *ax772b_data = (struct ax88772b_data *)dev->priv;
+	u16 checksum;
+
+	if (ax772b_data->checksum & AX_RX_CHECKSUM)
+		checksum = AX_RXCOE_DEF_CSUM;
+	else
+		checksum = 0;
+
+	ax8817x_write_cmd(dev, AX_CMD_WRITE_RXCOE_CTL,
+				 checksum, 0, 0, NULL);
+
+	if (ax772b_data->checksum & AX_TX_CHECKSUM)
+		checksum = AX_TXCOE_DEF_CSUM;
+	else
+		checksum = 0;
+
+	ax8817x_write_cmd(dev, AX_CMD_WRITE_TXCOE_CTL,
+				 checksum, 0, 0, NULL);
+
+	return 0;
+}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 3, 0)
+static u32 ax88772b_get_tx_csum(struct net_device *netdev)
+{
+	struct usbnet *dev = netdev_priv(netdev);
+	struct ax88772b_data *ax772b_data = (struct ax88772b_data *)dev->priv;
+
+	return ax772b_data->checksum & AX_TX_CHECKSUM;
+}
+
+static u32 ax88772b_get_rx_csum(struct net_device *netdev)
+{
+	struct usbnet *dev = netdev_priv(netdev);
+	struct ax88772b_data *ax772b_data = (struct ax88772b_data *)dev->priv;
+
+	return ax772b_data->checksum & AX_RX_CHECKSUM;
+}
+
+static int ax88772b_set_rx_csum(struct net_device *netdev, u32 val)
+{
+	struct usbnet *dev = netdev_priv(netdev);
+	struct ax88772b_data *ax772b_data = (struct ax88772b_data *)dev->priv;
+
+	if (val)
+		ax772b_data->checksum |= AX_RX_CHECKSUM;
+	else
+		ax772b_data->checksum &= ~AX_RX_CHECKSUM;
+
+	return ax88772b_set_csums(dev);
+}
+
+static int ax88772b_set_tx_csum(struct net_device *netdev, u32 val)
+{
+	struct usbnet *dev = netdev_priv(netdev);
+	struct ax88772b_data *ax772b_data = (struct ax88772b_data *)dev->priv;
+
+	if (val)
+		ax772b_data->checksum |= AX_TX_CHECKSUM;
+	else
+		ax772b_data->checksum &= ~AX_TX_CHECKSUM;
+
+	ethtool_op_set_tx_csum(netdev, val);
+
+	return ax88772b_set_csums(dev);
+}
+#endif
+static struct ethtool_ops ax88772b_ethtool_ops = {
+	.get_drvinfo		= ax8817x_get_drvinfo,
+	.get_link		= ethtool_op_get_link,
+	.get_msglevel		= axusbnet_get_msglevel,
+	.set_msglevel		= axusbnet_set_msglevel,
+	.get_wol		= ax8817x_get_wol,
+	.set_wol		= ax8817x_set_wol,
+	.get_eeprom_len		= ax8817x_get_eeprom_len,
+	.get_eeprom		= ax8817x_get_eeprom,
+	.get_settings		= ax8817x_get_settings,
+	.set_settings		= ax8817x_set_settings,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 3, 0)
+	.set_tx_csum		= ax88772b_set_tx_csum,
+	.get_tx_csum		= ax88772b_get_tx_csum,
+	.get_rx_csum		= ax88772b_get_rx_csum,
+	.set_rx_csum		= ax88772b_set_rx_csum,
+#endif
+};
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 29)
+static const struct net_device_ops ax88772b_netdev_ops = {
+	.ndo_open		= axusbnet_open,
+	.ndo_stop		= axusbnet_stop,
+	.ndo_start_xmit		= axusbnet_start_xmit,
+	.ndo_tx_timeout		= axusbnet_tx_timeout,
+	.ndo_change_mtu		= axusbnet_change_mtu,
+	.ndo_do_ioctl		= ax8817x_ioctl,
+	.ndo_get_stats		= axusbnet_get_stats,
+	.ndo_set_mac_address	= ax8817x_set_mac_addr,
+	.ndo_validate_addr	= eth_validate_addr,
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(3, 2, 0)
+	.ndo_set_multicast_list	= ax88772b_set_multicast,
+#else
+	.ndo_set_rx_mode	= ax88772b_set_multicast,
+#endif
+};
+#endif
+
+static int ax88772b_bind(struct usbnet *dev, struct usb_interface *intf)
+{
+	int ret;
+	void *buf;
+	struct ax8817x_data *data = (struct ax8817x_data *)&dev->data;
+	struct ax88772b_data *ax772b_data;
+	u16 *tmp16;
+	u8  *tmp8;
+	u8 tempphyselect;
+	bool internalphy;
+
+	printk(version);
+	axusbnet_get_endpoints(dev, intf);
+	buf = kmalloc(6, GFP_KERNEL);
+	if (!buf) {
+		deverr(dev, "Cannot allocate memory for buffer");
+		return -ENOMEM;
+	}
+	tmp16 = (u16 *)buf;
+	ax772b_data = kmalloc(sizeof(*ax772b_data), GFP_KERNEL);
+	if (!ax772b_data) {
+		deverr(dev, "Cannot allocate memory for AX88772B data");
+		kfree(buf);
+		return -ENOMEM;
+	}
+	memset(ax772b_data, 0, sizeof(*ax772b_data));
+	dev->priv = ax772b_data;
+	ax772b_data->ax_work = create_singlethread_workqueue("ax88772b");
+	if (!ax772b_data->ax_work) {
+		kfree(buf);
+		kfree(ax772b_data);
+		return -ENOMEM;
+	}
+
+	ax772b_data->dev = dev;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20)
+	INIT_WORK(&ax772b_data->check_link, ax88772b_link_reset, dev);
+#else
+	INIT_WORK(&ax772b_data->check_link, ax88772b_link_reset);
+#endif
+
+	tmp8 = (u8 *)buf;
+	ret = ax8817x_read_cmd(dev, AX_CMD_SW_PHY_STATUS,
+			       0, 0, 1, tmp8);
+
+	if (ret < 0) {
+		deverr(dev,
+		       "read SW interface selection status register failed: %d\n",
+		       ret);
+		goto err_out;
+	}
+	tempphyselect = *tmp8;
+	tempphyselect &= 0x0C;
+
+	if (tempphyselect == AX_PHYSEL_SSRMII) {
+		internalphy = false;
+		ax772b_data->OperationMode = OPERATION_MAC_MODE;
+		ax772b_data->PhySelect = 0x00;
+	} else if (tempphyselect == AX_PHYSEL_SSRRMII) {
+		internalphy = true;
+		ax772b_data->OperationMode = OPERATION_PHY_MODE;
+		ax772b_data->PhySelect = 0x00;
+	} else if (tempphyselect == AX_PHYSEL_SSMII) {
+		internalphy = true;
+		ax772b_data->OperationMode = OPERATION_MAC_MODE;
+		ax772b_data->PhySelect = 0x01;
+	} else {
+		deverr(dev, "Unknown MII type\n");
+		goto err_out;
+	}
+
+	/* reload eeprom data */
+	ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS, AXGPIOS_RSE,
+				0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Failed to enable GPIO function: %d", ret);
+		goto err_out;
+	}
+	msleep(5);
+
+	/* Get the EEPROM data*/
+	ret = ax8817x_read_cmd(dev, AX_CMD_READ_EEPROM, 0x18, 0, 2,
+			       (void *)tmp16);
+	if (ret < 0) {
+		deverr(dev, "read SROM address 18h failed: %d", ret);
+		goto err_out;
+	}
+	le16_to_cpus(tmp16);
+	ax772b_data->psc = *tmp16 & 0xFF00;
+	/* End of get EEPROM data */
+
+	/* Get the MAC address */
+	memset(buf, 0, ETH_ALEN);
+	ret = ax8817x_get_mac(dev, buf);
+	if (ret < 0) {
+		deverr(dev, "Get HW address failed: %d", ret);
+		goto err_out;
+	}
+
+	/* Initialize MII structure */
+	dev->mii.dev = dev->net;
+	dev->mii.mdio_read = ax8817x_mdio_read_le;
+	dev->mii.mdio_write = ax88772b_mdio_write_le;
+	dev->mii.phy_id_mask = 0xff;
+	dev->mii.reg_num_mask = 0xff;
+
+	/* Get the PHY id */
+	ret = ax8817x_read_cmd(dev, AX_CMD_READ_PHY_ID, 0, 0, 2, buf);
+	if (ret < 0) {
+		deverr(dev, "Error reading PHY ID: %02x", ret);
+		goto err_out;
+	} else if (ret < 2) {
+		/* this should always return 2 bytes */
+		deverr(dev, "Read PHYID returned less than 2 bytes: ret=%02x",
+		    ret);
+		ret = -EIO;
+		goto err_out;
+	}
+
+	if (internalphy)
+		dev->mii.phy_id = *((u8 *)buf + 1);
+	else
+		dev->mii.phy_id = *((u8 *)buf);
+
+	ret = ax8817x_write_cmd(dev, AX_CMD_SW_PHY_SELECT,
+				ax772b_data->PhySelect, 0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Select PHY #1 failed: %d", ret);
+		goto err_out;
+	}
+
+#if 0
+	/* select the embedded 10/100 Ethernet PHY */
+	ret = ax8817x_write_cmd(dev, AX_CMD_SW_PHY_SELECT,
+			AX_PHYSEL_SSEN | AX_PHYSEL_PSEL | AX_PHYSEL_SSMII,
+			0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Select PHY #1 failed: %d", ret);
+		goto err_out;
+	}
+
+	if (dev->mii.phy_id != 0x10) {
+		deverr(dev, "Got wrong PHY ID: %02x", dev->mii.phy_id);
+		ret = -EIO;
+		goto err_out;
+	}
+#endif
+	ret = ax88772a_phy_powerup(dev);
+	if (ret < 0)
+		goto err_out;
+
+	/* stop MAC operation */
+	ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL,
+				AX_RX_CTL_STOP, 0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Reset RX_CTL failed: %d", ret);
+		goto err_out;
+	}
+
+	/* make sure the driver can enable sw mii operation */
+	ret = ax8817x_write_cmd(dev, AX_CMD_SET_SW_MII, 0, 0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Enabling software MII failed: %d", ret);
+		goto err_out;
+	}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 30)
+	dev->net->do_ioctl = ax8817x_ioctl;
+	dev->net->set_multicast_list = ax88772b_set_multicast;
+	dev->net->set_mac_address = ax8817x_set_mac_addr;
+#else
+	dev->net->netdev_ops = &ax88772b_netdev_ops;
+#endif
+
+	dev->net->ethtool_ops = &ax88772b_ethtool_ops;
+
+	/* Register suspend and resume functions */
+	data->suspend = ax88772b_suspend;
+	data->resume = ax88772b_resume;
+
+	if ((ax772b_data->OperationMode == OPERATION_MAC_MODE) &&
+	    (ax772b_data->PhySelect == 0x00)) {
+		if (ax88772b_external_phyinit(dev) != 0x00) {
+			deverr(dev, "Failed to initial the external phy");
+			goto err_out;
+		}
+	}
+
+	if (ax772b_data->OperationMode == OPERATION_PHY_MODE)
+		ax8817x_mdio_write_le(dev->net, dev->mii.phy_id
+						, MII_BMCR, 0x3900);
+
+	if (dev->mii.phy_id != 0x10)
+		ax8817x_mdio_write_le(dev->net, 0x10, MII_BMCR, 0x3900);
+
+	if (dev->mii.phy_id == 0x10 && ax772b_data->OperationMode
+						!= OPERATION_PHY_MODE) {
+
+		*tmp16 = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, 0x12);
+		ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, 0x12,
+					((*tmp16 & 0xFF9F) | 0x0040));
+	}	
+
+	ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, MII_ADVERTISE,
+			ADVERTISE_ALL | ADVERTISE_CSMA | ADVERTISE_PAUSE_CAP);
+
+	mii_nway_restart(&dev->mii);
+
+	ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE,
+				0, 0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Failed to write medium mode: %d", ret);
+		goto err_out;
+	}
+
+	ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_IPG0,
+			AX88772A_IPG0_DEFAULT | AX88772A_IPG1_DEFAULT << 8,
+			AX88772A_IPG2_DEFAULT, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Failed to write interframe gap: %d", ret);
+		goto err_out;
+	}
+
+	memset(buf, 0, 4);
+	ret = ax8817x_read_cmd(dev, AX_CMD_READ_IPG012, 0, 0, 3, buf);
+	*((u8 *)buf + 3) = 0x00;
+	if (ret < 0) {
+		deverr(dev, "Failed to read IPG,IPG1,IPG2 failed: %d", ret);
+		goto err_out;
+	} else {
+		__u32 tmp32 = *((u32*)buf);
+		le32_to_cpus(&tmp32);
+		if (tmp32 != (AX88772A_IPG2_DEFAULT << 16 |
+			AX88772A_IPG1_DEFAULT << 8 | AX88772A_IPG0_DEFAULT)) {
+			printk("Non-authentic ASIX product\nASIX does not support it\n");
+			ret = -ENODEV;		
+			goto err_out;
+		}
+	}
+
+	dev->net->features |= NETIF_F_IP_CSUM;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 22)
+	dev->net->features |= NETIF_F_IPV6_CSUM;
+#endif
+
+	ax772b_data->checksum = AX_RX_CHECKSUM | AX_TX_CHECKSUM;
+	ret = ax88772b_set_csums(dev);
+	if (ret < 0) {
+		deverr(dev, "Write RX_COE/TX_COE failed: %d", ret);
+		goto err_out;
+	}
+
+	dev->rx_size = bsize & 0x07;
+	if (dev->udev->speed == USB_SPEED_HIGH) {
+
+		ret = ax8817x_write_cmd(dev, 0x2A,
+				AX88772B_BULKIN_SIZE[dev->rx_size].byte_cnt,
+				AX88772B_BULKIN_SIZE[dev->rx_size].threshold,
+				0, NULL);
+		if (ret < 0) {
+			deverr(dev, "Reset RX_CTL failed: %d", ret);
+			goto err_out;
+		}
+
+		dev->rx_urb_size = AX88772B_BULKIN_SIZE[dev->rx_size].size;
+	} else {
+		ret = ax8817x_write_cmd(dev, 0x2A,
+				0x8000, 0x8001, 0, NULL);
+		if (ret < 0) {
+			deverr(dev, "Reset RX_CTL failed: %d", ret);
+			goto err_out;
+		}
+		dev->rx_urb_size = 2048;
+	}
+
+	/* Configure RX header type */
+	ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL,
+		      (AX_RX_CTL_START | AX_RX_CTL_AB | AX_RX_HEADER_DEFAULT),
+		      0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Reset RX_CTL failed: %d", ret);
+		goto err_out;
+	}
+
+	/* Overwrite power saving configuration from eeprom */
+	ret = ax8817x_write_cmd(dev, AX_CMD_SW_RESET, AX_SWRESET_IPRL |
+				(ax772b_data->psc & 0x7FFF), 0, 0, NULL);
+
+	if (ret < 0) {
+		deverr(dev, "Failed to configure PHY power saving: %d", ret);
+		goto err_out;
+	}
+
+	if (ax772b_data->OperationMode == OPERATION_PHY_MODE)
+		netif_carrier_on(dev->net);
+
+	kfree(buf);
+
+	return ret;
+err_out:
+	destroy_workqueue(ax772b_data->ax_work);
+	kfree(buf);
+	kfree(ax772b_data);
+	return ret;
+}
+
+static int ax88772b_external_phyinit(struct usbnet *dev) {
+	struct ax88772b_data *ax772b_data = (struct ax88772b_data *)dev->priv;
+	u16 phyid1, phyid2;
+
+	phyid1 = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, 0x02);
+	phyid2 = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, 0x03);
+	ax772b_data->ext_phy_oui = EXTPHY_ID_MASK_OUI(phyid1, phyid2);
+	ax772b_data->ext_phy_model = EXTPHY_ID_MASK_MODEL(phyid2);
+
+	if (ax772b_data->ext_phy_oui == EXTPHY_BROADCOM_OUI) { 
+		if(ax772b_data->ext_phy_model == EXTPHY_BCM89811_MODEL) {			
+			ax88772b_mdio_write_le(dev->net, dev->mii.phy_id, 0x0, 0x8000);
+			ax88772b_mdio_write_le(dev->net, dev->mii.phy_id, 0x1e, 0x0028);
+			ax88772b_mdio_write_le(dev->net, dev->mii.phy_id, 0x1e, 0x0028);
+			ax88772b_mdio_write_le(dev->net, dev->mii.phy_id, 0x1e, 0x0028);
+			ax88772b_mdio_write_le(dev->net, dev->mii.phy_id, 0x1e, 0x0028);
+			ax88772b_mdio_write_le(dev->net, dev->mii.phy_id, 0x1e, 0x0028);
+			ax88772b_mdio_write_le(dev->net, dev->mii.phy_id, 0x1e, 0x0028);
+			ax88772b_mdio_write_le(dev->net, dev->mii.phy_id, 0x1F, 0x0c00);
+			ax88772b_mdio_write_le(dev->net, dev->mii.phy_id, 0x1E, 0x030A);
+			ax88772b_mdio_write_le(dev->net, dev->mii.phy_id, 0x1F, 0x3440);
+			ax88772b_mdio_write_le(dev->net, dev->mii.phy_id, 0x1E, 0x0166);
+			ax88772b_mdio_write_le(dev->net, dev->mii.phy_id, 0x1F, 0x0020);
+			ax88772b_mdio_write_le(dev->net, dev->mii.phy_id, 0x1e, 0x012D);
+			ax88772b_mdio_write_le(dev->net, dev->mii.phy_id, 0x1f, 0x9B52);
+			ax88772b_mdio_write_le(dev->net, dev->mii.phy_id, 0x1e, 0x012E);
+			ax88772b_mdio_write_le(dev->net, dev->mii.phy_id, 0x1f, 0xA04D);
+			ax88772b_mdio_write_le(dev->net, dev->mii.phy_id, 0x1e, 0x0123);
+			ax88772b_mdio_write_le(dev->net, dev->mii.phy_id, 0x1f, 0x00c0);
+			ax88772b_mdio_write_le(dev->net, dev->mii.phy_id, 0x1e, 0x0154);
+			ax88772b_mdio_write_le(dev->net, dev->mii.phy_id, 0x1f, 0x81C4);
+			ax88772b_mdio_write_le(dev->net, dev->mii.phy_id, 0x1e, 0x0811);
+			ax88772b_mdio_write_le(dev->net, dev->mii.phy_id, 0x1f, 0x0000);
+			ax88772b_mdio_write_le(dev->net, dev->mii.phy_id, 0x1e, 0x01D3);
+			ax88772b_mdio_write_le(dev->net, dev->mii.phy_id, 0x1f, 0x0064);
+			ax88772b_mdio_write_le(dev->net, dev->mii.phy_id, 0x1e, 0x01C1);
+			ax88772b_mdio_write_le(dev->net, dev->mii.phy_id, 0x1f, 0xA5F7);
+			ax88772b_mdio_write_le(dev->net, dev->mii.phy_id, 0x1e, 0x0028);
+			ax88772b_mdio_write_le(dev->net, dev->mii.phy_id, 0x1f, 0x0400);
+			ax88772b_mdio_write_le(dev->net, dev->mii.phy_id, 0x1e, 0x001D);
+			ax88772b_mdio_write_le(dev->net, dev->mii.phy_id, 0x1f, 0x3411);
+			ax88772b_mdio_write_le(dev->net, dev->mii.phy_id, 0x1e, 0x0820);
+			ax88772b_mdio_write_le(dev->net, dev->mii.phy_id, 0x1f, 0x0401);
+			ax88772b_mdio_write_le(dev->net, dev->mii.phy_id, 0x1e, 0x002F);
+			ax88772b_mdio_write_le(dev->net, dev->mii.phy_id, 0x1f, 0xF167);
+			ax88772b_mdio_write_le(dev->net, dev->mii.phy_id, 0x1e, 0x0045);
+			ax88772b_mdio_write_le(dev->net, dev->mii.phy_id, 0x1f, 0x0500);
+			return 0;
+		}
+	}
+
+	return 0;
+}
+
+static void ax88772b_unbind(struct usbnet *dev, struct usb_interface *intf)
+{
+	struct ax88772b_data *ax772b_data = (struct ax88772b_data *)dev->priv;
+
+	if (ax772b_data) {
+
+		flush_workqueue(ax772b_data->ax_work);
+		destroy_workqueue(ax772b_data->ax_work);
+
+		/* stop MAC operation */
+		ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL,
+					AX_RX_CTL_STOP, 0, 0, NULL);
+
+		/* Power down PHY */
+		ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
+					AX_SWRESET_IPPD, 0, 0, NULL);
+
+		kfree(ax772b_data);
+	}
+}
+
+static int
+ax88178_media_check(struct usbnet *dev, struct ax88178_data *ax178dataptr)
+{
+	int fullduplex, i = 0;
+	u16 tempshort = 0;
+	u16 media;
+	u16 advertise, lpa, result, stat1000, _lpa, _stat1000, delay = 5 * HZ;
+	unsigned long jtimeout;
+
+	jtimeout = jiffies + delay;
+	do {
+		_lpa = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, MII_LPA);
+		_stat1000 = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id,
+						  MII_STAT1000);
+
+		lpa = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, MII_LPA);
+		stat1000 = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id,
+						MII_STAT1000);
+
+		if (time_after(jiffies, jtimeout))
+			break;
+
+	} while ((_lpa != lpa) || (_stat1000 != stat1000) || i++ < 3);
+
+	advertise = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id,
+					 MII_ADVERTISE);
+	result = advertise & lpa;
+
+	if ((ax178dataptr->PhyMode == PHY_MODE_MARVELL) &&
+	    (ax178dataptr->LedMode == 1)) {
+		tempshort = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id,
+						 MARVELL_MANUAL_LED) & 0xfc0f;
+	}
+
+	fullduplex = 1;
+	if (stat1000 & LPA_1000FULL) {
+		media = MEDIUM_GIGA_MODE | MEDIUM_FULL_DUPLEX_MODE |
+			MEDIUM_ENABLE_125MHZ | MEDIUM_ENABLE_RECEIVE;
+		if ((ax178dataptr->PhyMode == PHY_MODE_MARVELL) &&
+		    (ax178dataptr->LedMode == 1))
+			tempshort |= 0x3e0;
+	} else if (result & LPA_100FULL) {
+		media = MEDIUM_FULL_DUPLEX_MODE | MEDIUM_ENABLE_RECEIVE |
+			MEDIUM_MII_100M_MODE;
+		if ((ax178dataptr->PhyMode == PHY_MODE_MARVELL) &&
+		    (ax178dataptr->LedMode == 1))
+			tempshort |= 0x3b0;
+	} else if (result & LPA_100HALF) {
+		fullduplex = 0;
+		media = MEDIUM_ENABLE_RECEIVE | MEDIUM_MII_100M_MODE;
+		if ((ax178dataptr->PhyMode == PHY_MODE_MARVELL) &&
+		    (ax178dataptr->LedMode == 1))
+			tempshort |= 0x3b0;
+	} else if (result & LPA_10FULL) {
+		media = MEDIUM_FULL_DUPLEX_MODE | MEDIUM_ENABLE_RECEIVE;
+		if ((ax178dataptr->PhyMode == PHY_MODE_MARVELL) &&
+		    (ax178dataptr->LedMode == 1))
+			tempshort |= 0x2f0;
+	} else {
+		media = MEDIUM_ENABLE_RECEIVE;
+		fullduplex = 0;
+		if ((ax178dataptr->PhyMode == PHY_MODE_MARVELL) &&
+		    (ax178dataptr->LedMode == 1))
+				tempshort |= 0x02f0;
+	}
+
+	if ((ax178dataptr->PhyMode == PHY_MODE_MARVELL) &&
+	    (ax178dataptr->LedMode == 1)) {
+		ax8817x_mdio_write_le(dev->net,
+			dev->mii.phy_id, MARVELL_MANUAL_LED, tempshort);
+	}
+
+	media |= 0x0004;
+	if (ax178dataptr->UseRgmii)
+		media |= 0x0008;
+	if (fullduplex) {
+		media |= 0x0020;  /* ebable tx flow control as default; */
+		media |= 0x0010;  /* ebable rx flow control as default; */
+	}
+
+	return media;
+}
+
+static void Vitess_8601_Init(struct usbnet *dev, int state)
+{
+	u16 reg;
+
+	switch (state) {
+	case 0:	/* tx, rx clock skew */
+		ax8817x_swmii_mdio_write_le(dev->net, dev->mii.phy_id, 31, 1);
+		ax8817x_swmii_mdio_write_le(dev->net, dev->mii.phy_id, 28, 0);
+		ax8817x_swmii_mdio_write_le(dev->net, dev->mii.phy_id, 31, 0);
+		break;
+
+	case 1:
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 31, 0x52B5);
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 18, 0x009E);
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 17, 0xDD39);
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 16, 0x87AA);
+
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 16, 0xA7B4);
+
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 18,
+				ax8817x_swmii_mdio_read_le(dev->net,
+						dev->mii.phy_id, 18));
+
+		reg = (ax8817x_swmii_mdio_read_le(dev->net,
+				dev->mii.phy_id, 17) & ~0x003f) | 0x003c;
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 17, reg);
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 16, 0x87B4);
+
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 16, 0xa794);
+
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 18,
+				ax8817x_swmii_mdio_read_le(dev->net,
+					dev->mii.phy_id, 18));
+
+		reg = (ax8817x_swmii_mdio_read_le(dev->net,
+				dev->mii.phy_id, 17) & ~0x003f) | 0x003e;
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 17, reg);
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 16, 0x8794);
+
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 18, 0x00f7);
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 17, 0xbe36);
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 16, 0x879e);
+
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 16, 0xa7a0);
+
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 18,
+				ax8817x_swmii_mdio_read_le(dev->net,
+						dev->mii.phy_id, 18));
+
+		reg = (ax8817x_swmii_mdio_read_le(dev->net,
+				dev->mii.phy_id, 17) & ~0x003f) | 0x0034;
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 17, reg);
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 16, 0x87a0);
+
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 18, 0x003c);
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 17, 0xf3cf);
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 16, 0x87a2);
+
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 18, 0x003c);
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 17, 0xf3cf);
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 16, 0x87a4);
+
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 18, 0x003c);
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 17, 0xd287);
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 16, 0x87a6);
+
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 16, 0xa7a8);
+
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 18,
+				ax8817x_swmii_mdio_read_le(dev->net,
+						dev->mii.phy_id, 18));
+
+		reg = (ax8817x_swmii_mdio_read_le(dev->net,
+				dev->mii.phy_id, 17) & ~0x0fff) | 0x0125;
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 17, reg);
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 16, 0x87a8);
+
+		/* Enable Smart Pre-emphasis */
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 16, 0xa7fa);
+
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 18,
+				ax8817x_swmii_mdio_read_le(dev->net,
+						dev->mii.phy_id, 18));
+
+		reg = (ax8817x_swmii_mdio_read_le(dev->net,
+				dev->mii.phy_id, 17) & ~0x0008) | 0x0008;
+
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 17, reg);
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 16, 0x87fa);
+
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 31, 0);
+
+		break;
+	}
+}
+
+static void
+marvell_88E1510_magic_init(struct usbnet *dev)
+{
+	ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 22, 0xff);
+	ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 17, 0x214b);
+	ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 16, 0x2144);
+	ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 17, 0x0c28);
+	ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 16, 0x2146);
+	ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 17, 0xb233);
+	ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 16, 0x214d);
+	ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 17, 0xcc0c);
+	ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 16, 0x2159);
+	ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 22, 0x00fb);
+	ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 7, 0xc00d);
+	ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 22, 0);
+}
+
+static int
+ax88178_phy_init(struct usbnet *dev, struct ax88178_data *ax178dataptr)
+{
+	int i;
+	u16 phyanar, phyauxctrl, phyctrl, tempshort, phyid1;
+	u16 phyreg = 0;
+
+	/* Disable MII operation of AX88178 Hardware */
+	ax8817x_write_cmd(dev, AX_CMD_SET_SW_MII, 0x0000, 0, 0, NULL);
+
+
+	/* Read SROM - MiiPhy Address (ID) */
+	ax8817x_read_cmd(dev, AX_CMD_READ_PHY_ID, 0, 0, 2, &dev->mii.phy_id);
+	le32_to_cpus(&dev->mii.phy_id);
+
+	/* Initialize MII structure */
+	dev->mii.phy_id >>= 8;
+	dev->mii.phy_id &= PHY_ID_MASK;
+	dev->mii.dev = dev->net;
+	dev->mii.mdio_read = ax8817x_mdio_read_le;
+	dev->mii.mdio_write = ax8817x_mdio_write_le;
+	dev->mii.phy_id_mask = 0x3f;
+	dev->mii.reg_num_mask = 0x1f;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 11)
+	dev->mii.supports_gmii = 1;
+#endif
+
+	if (ax178dataptr->PhyMode == PHY_MODE_MAC_TO_MAC_GMII) {
+		ax178dataptr->UseRgmii = 0;
+		ax178dataptr->MediaLink = MEDIUM_GIGA_MODE |
+					  MEDIUM_FULL_DUPLEX_MODE |
+					  MEDIUM_ENABLE_125MHZ |
+					  MEDIUM_ENABLE_RECEIVE |
+					  MEDIUM_ENABLE_RX_FLOWCTRL |
+					  MEDIUM_ENABLE_TX_FLOWCTRL;
+		goto SKIPPHYSETTING;
+	}
+
+	/* test read phy register 2 */
+	if (!ax178dataptr->UseGpio0) {
+		i = 1000;
+		while (i--) {
+			phyid1 = ax8817x_swmii_mdio_read_le(dev->net,
+						dev->mii.phy_id, GMII_PHY_OUI);
+			if ((phyid1 == 0x000f) || (phyid1 == 0x0141) ||
+			    (phyid1 == 0x0282) || (phyid1 == 0x004d) ||
+			    (phyid1 == 0x0243) || (phyid1 == 0x001C) ||
+			    (phyid1 == 0x0007))
+				break;
+			msleep(5);
+		}
+		if (i < 0)
+			return -EIO;
+	}
+
+	ax178dataptr->UseRgmii = 0;
+	if (ax178dataptr->PhyMode == PHY_MODE_MARVELL) {
+		phyreg = ax8817x_swmii_mdio_read_le(dev->net,
+					dev->mii.phy_id, 27);
+		if (!(phyreg & 4) && !(ax178dataptr->LedMode & 0x10)) {
+			ax178dataptr->UseRgmii = 1;
+			ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 20, 0x82);
+			ax178dataptr->MediaLink |= MEDIUM_ENABLE_125MHZ;
+		} else if (ax178dataptr->LedMode & 0x10) {
+
+			ax178dataptr->UseRgmii = 1;
+			ax178dataptr->MediaLink |= MEDIUM_ENABLE_125MHZ;
+			marvell_88E1510_magic_init(dev);
+
+			ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 22, 2);
+
+			phyreg = ax8817x_swmii_mdio_read_le(dev->net,
+					dev->mii.phy_id, 21);
+
+			ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 21, phyreg | 0x30);
+
+			ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 22, 0);
+		}
+	} else if ((ax178dataptr->PhyMode == PHY_MODE_AGERE_V0) ||
+		 (ax178dataptr->PhyMode == PHY_MODE_AGERE_V0_GMII)) {
+		if (ax178dataptr->PhyMode == PHY_MODE_AGERE_V0) {
+			ax178dataptr->UseRgmii = 1;
+			ax178dataptr->MediaLink |= MEDIUM_ENABLE_125MHZ;
+		}
+	} else if (ax178dataptr->PhyMode == PHY_MODE_CICADA_V1) {
+		/* not Cameo */
+		if (!ax178dataptr->UseGpio0 || ax178dataptr->LedMode) {
+			ax178dataptr->UseRgmii = 1;
+			ax178dataptr->MediaLink |= MEDIUM_ENABLE_125MHZ;
+		}
+
+		for (i = 0; i < (sizeof(CICADA_FAMILY_HWINIT) /
+				 sizeof(CICADA_FAMILY_HWINIT[0])); i++) {
+			ax8817x_swmii_mdio_write_le(dev->net,
+						    dev->mii.phy_id,
+					CICADA_FAMILY_HWINIT[i].offset,
+					CICADA_FAMILY_HWINIT[i].value);
+		}
+
+	} else if (ax178dataptr->PhyMode == PHY_MODE_CICADA_V2) {
+		/* not Cameo */
+		if (!ax178dataptr->UseGpio0 || ax178dataptr->LedMode) {
+			ax178dataptr->UseRgmii = 1;
+			ax178dataptr->MediaLink |= MEDIUM_ENABLE_125MHZ;
+		}
+
+		for (i = 0; i < (sizeof(CICADA_V2_HWINIT) /
+				 sizeof(CICADA_V2_HWINIT[0])); i++) {
+			ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, CICADA_V2_HWINIT[i].offset,
+				CICADA_V2_HWINIT[i].value);
+		}
+	} else if (ax178dataptr->PhyMode == PHY_MODE_CICADA_V2_ASIX) {
+		/* not Cameo */
+		if (!ax178dataptr->UseGpio0 || ax178dataptr->LedMode) {
+			ax178dataptr->UseRgmii = 1;
+			ax178dataptr->MediaLink |= MEDIUM_ENABLE_125MHZ;
+		}
+
+		for (i = 0; i < (sizeof(CICADA_V2_HWINIT) /
+				 sizeof(CICADA_V2_HWINIT[0])); i++) {
+			ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, CICADA_V2_HWINIT[i].offset,
+				CICADA_V2_HWINIT[i].value);
+		}
+	} else if (ax178dataptr->PhyMode == PHY_MODE_RTL8211CL) {
+		ax178dataptr->UseRgmii = 1;
+		ax178dataptr->MediaLink |= MEDIUM_ENABLE_125MHZ;
+	} else if (ax178dataptr->PhyMode == PHY_MODE_RTL8211BN) {
+		ax178dataptr->UseRgmii = 1;
+		ax178dataptr->MediaLink |= MEDIUM_ENABLE_125MHZ;
+	} else if (ax178dataptr->PhyMode == PHY_MODE_RTL8251CL) {
+		ax178dataptr->UseRgmii = 1;
+		ax178dataptr->MediaLink |= MEDIUM_ENABLE_125MHZ;
+	} else if (ax178dataptr->PhyMode == PHY_MODE_VSC8601) {
+		ax178dataptr->UseRgmii = 1;
+		ax178dataptr->MediaLink |= MEDIUM_ENABLE_125MHZ;
+		/* Vitess_8601_Init (dev, 0); */
+	}
+
+	if (ax178dataptr->PhyMode != PHY_MODE_ATTANSIC_V0) {
+		/* software reset */
+		ax8817x_swmii_mdio_write_le(
+			dev->net, dev->mii.phy_id, GMII_PHY_CONTROL,
+			ax8817x_swmii_mdio_read_le(
+				dev->net, dev->mii.phy_id, GMII_PHY_CONTROL)
+				| GMII_CONTROL_RESET);
+		msleep(1);
+	}
+
+	if ((ax178dataptr->PhyMode == PHY_MODE_AGERE_V0) ||
+	    (ax178dataptr->PhyMode == PHY_MODE_AGERE_V0_GMII)) {
+		if (ax178dataptr->PhyMode == PHY_MODE_AGERE_V0) {
+			i = 1000;
+			while (i--) {
+				ax8817x_swmii_mdio_write_le(dev->net,
+						dev->mii.phy_id, 21, 0x1001);
+
+				phyreg = ax8817x_swmii_mdio_read_le(dev->net,
+						dev->mii.phy_id, 21);
+				if ((phyreg & 0xf00f) == 0x1001)
+					break;
+			}
+			if (i < 0)
+				return -EIO;
+		}
+
+		if (ax178dataptr->LedMode == 4) {
+			ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 28, 0x7417);
+		} else if (ax178dataptr->LedMode == 9) {
+			ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 28, 0x7a10);
+		} else if (ax178dataptr->LedMode == 10) {
+			ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 28, 0x7a13);
+		}
+
+		for (i = 0; i < (sizeof(AGERE_FAMILY_HWINIT) /
+				 sizeof(AGERE_FAMILY_HWINIT[0])); i++) {
+			ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, AGERE_FAMILY_HWINIT[i].offset,
+				AGERE_FAMILY_HWINIT[i].value);
+		}
+	} else if (ax178dataptr->PhyMode == PHY_MODE_RTL8211CL) {
+
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 0x1f, 0x0005);
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 0x0c, 0);
+
+		ax8817x_swmii_mdio_write_le(dev->net, dev->mii.phy_id, 0x01,
+					(ax8817x_swmii_mdio_read_le(dev->net,
+					dev->mii.phy_id, 0x01) | 0x0080));
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 0x1f, 0);
+
+		if (ax178dataptr->LedMode == 12) {
+			ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 0x1f, 0x0002);
+			ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 0x1a, 0x00cb);
+			ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 0x1f, 0);
+		}
+	} else if (ax178dataptr->PhyMode == PHY_MODE_VSC8601) {
+		Vitess_8601_Init(dev, 1);
+	}
+
+	/* read phy register 0 */
+	phyctrl = ax8817x_swmii_mdio_read_le(dev->net,
+				dev->mii.phy_id, GMII_PHY_CONTROL);
+	tempshort = phyctrl;
+	phyctrl &= ~(GMII_CONTROL_POWER_DOWN | GMII_CONTROL_ISOLATE);
+	if (phyctrl != tempshort) {
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, GMII_PHY_CONTROL, phyctrl);
+	}
+
+	/* LED */
+	if (ax178dataptr->PhyMode == PHY_MODE_MARVELL) {
+		if (ax178dataptr->LedMode == 1)	{
+
+			phyreg = (ax8817x_swmii_mdio_read_le(dev->net,
+				dev->mii.phy_id, 24) & 0xf8ff) | (1 + 0x100);
+			ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 24, phyreg);
+			phyreg = ax8817x_swmii_mdio_read_le(dev->net,
+					dev->mii.phy_id, 25) & 0xfc0f;
+		} else if (ax178dataptr->LedMode == 2) {
+
+			phyreg = (ax8817x_swmii_mdio_read_le(dev->net,
+					dev->mii.phy_id, 24) & 0xf886) |
+					(1 + 0x10 + 0x300);
+			ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 24, phyreg);
+		} else if (ax178dataptr->LedMode == 5) {
+
+			phyreg = (ax8817x_swmii_mdio_read_le(dev->net,
+					dev->mii.phy_id, 24) & 0xf8be) |
+					(1 + 0x40 + 0x300);
+			ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 24, phyreg);
+		} else if (ax178dataptr->LedMode == 7) {
+
+			phyreg = (ax8817x_swmii_mdio_read_le(dev->net,
+						dev->mii.phy_id, 24) & 0xf8ff) |
+						(1 + 0x100);
+			ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 24, phyreg);
+
+		} else if (ax178dataptr->LedMode == 8) {
+
+			phyreg = (ax8817x_swmii_mdio_read_le(dev->net,
+					dev->mii.phy_id, 24) & 0xf8be) |
+					(1 + 0x40 + 0x100);
+			ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 24, phyreg);
+
+		} else if (ax178dataptr->LedMode == 11) {
+
+			phyreg = ax8817x_swmii_mdio_read_le(dev->net,
+					dev->mii.phy_id, 24) & 0x4106;
+			ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 24, phyreg);
+		} else if (ax178dataptr->LedMode == 0x10) {
+			/* MARVEL 88e1510 use default led setting */
+		}
+
+	} else if ((ax178dataptr->PhyMode == PHY_MODE_CICADA_V1) ||
+		   (ax178dataptr->PhyMode == PHY_MODE_CICADA_V2) ||
+		   (ax178dataptr->PhyMode == PHY_MODE_CICADA_V2_ASIX)) {
+
+		if (ax178dataptr->LedMode == 3) {
+
+			phyreg = (ax8817x_swmii_mdio_read_le(dev->net,
+					dev->mii.phy_id, 27) & 0xFCFF) | 0x0100;
+			ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 27, phyreg);
+		}
+
+	}
+
+	if (ax178dataptr->PhyMode == PHY_MODE_MARVELL) {
+		if (ax178dataptr->LedMode == 1)
+			phyreg |= 0x3f0;
+	}
+
+	phyanar = 1 | (GMII_ANAR_PAUSE | GMII_ANAR_100TXFD | GMII_ANAR_100TX |
+		       GMII_ANAR_10TFD | GMII_ANAR_10T | GMII_ANAR_ASYM_PAUSE);
+
+	phyauxctrl = GMII_1000_AUX_CTRL_FD_CAPABLE;
+
+	ax8817x_swmii_mdio_write_le(dev->net,
+			dev->mii.phy_id, GMII_PHY_ANAR, phyanar);
+	ax8817x_swmii_mdio_write_le(dev->net,
+			dev->mii.phy_id, GMII_PHY_1000BT_CONTROL, phyauxctrl);
+
+	if (ax178dataptr->PhyMode == PHY_MODE_VSC8601) {
+		ax8817x_swmii_mdio_write_le(dev->net, dev->mii.phy_id,
+					    31, 0x52B5);
+		ax8817x_swmii_mdio_write_le(dev->net, dev->mii.phy_id,
+					    16, 0xA7F8);
+
+		tempshort = ax8817x_swmii_mdio_read_le(dev->net,
+					dev->mii.phy_id, 17) & (~0x0018);
+
+		ax8817x_swmii_mdio_write_le(dev->net, dev->mii.phy_id,
+					    17, tempshort);
+
+		tempshort = ax8817x_swmii_mdio_read_le(dev->net,
+						       dev->mii.phy_id, 18);
+
+		ax8817x_swmii_mdio_write_le(dev->net, dev->mii.phy_id, 18,
+					    tempshort);
+
+		ax8817x_swmii_mdio_write_le(dev->net, dev->mii.phy_id,
+					    16, 0x87F8);
+		ax8817x_swmii_mdio_write_le(dev->net, dev->mii.phy_id,
+					    31, 0);
+	}
+
+	if (ax178dataptr->PhyMode == PHY_MODE_ATTANSIC_V0) {
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, GMII_PHY_CONTROL, 0x9000);
+
+	} else {
+		phyctrl &= ~GMII_CONTROL_LOOPBACK;
+		phyctrl |= (GMII_CONTROL_ENABLE_AUTO | GMII_CONTROL_START_AUTO);
+
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, GMII_PHY_CONTROL, phyctrl);
+	}
+
+	if (ax178dataptr->PhyMode == PHY_MODE_MARVELL) {
+		if (ax178dataptr->LedMode == 1)
+			ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 25, phyreg);
+	}
+
+SKIPPHYSETTING:
+
+	ax8817x_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE,
+			ax178dataptr->MediaLink, 0, 0, NULL);
+
+	ax8817x_write_cmd(dev, AX_CMD_WRITE_IPG0,
+			AX88772_IPG0_DEFAULT | (AX88772_IPG1_DEFAULT << 8),
+			AX88772_IPG2_DEFAULT, 0, NULL);
+
+	msleep(1);
+
+	ax8817x_write_cmd(dev, AX_CMD_SET_HW_MII, 0, 0, 0, NULL);
+
+	return 0;
+}
+
+static int ax88178_bind(struct usbnet *dev, struct usb_interface *intf)
+{
+	int ret;
+	void *buf;
+	struct ax8817x_data *data = (struct ax8817x_data *)&dev->data;
+	struct ax88178_data *ax178dataptr = NULL;
+
+	axusbnet_get_endpoints(dev, intf);
+
+	buf = kmalloc(6, GFP_KERNEL);
+	if (!buf) {
+		deverr(dev, "Cannot allocate memory for buffer");
+		return -ENOMEM;
+	}
+
+	/* allocate 178 data */
+	ax178dataptr = kmalloc(sizeof(*ax178dataptr), GFP_KERNEL);
+	if (!ax178dataptr) {
+		deverr(dev, "Cannot allocate memory for AX88178 data");
+		ret = -ENOMEM;
+		goto error_out;
+	}
+	memset(ax178dataptr, 0, sizeof(struct ax88178_data));
+	dev->priv = ax178dataptr;
+	/* end of allocate 178 data */
+
+	/* Get the EEPROM data*/
+	ret = ax8817x_read_cmd(dev, AX_CMD_READ_EEPROM, 0x0017, 0, 2,
+			       (void *)(&ax178dataptr->EepromData));
+	if (ret < 0) {
+		deverr(dev, "read SROM address 17h failed: %d", ret);
+		goto error_out;
+	}
+	le16_to_cpus(&ax178dataptr->EepromData);
+	/* End of get EEPROM data */
+
+	if (ax178dataptr->EepromData == 0xffff) {
+		ax178dataptr->PhyMode  = PHY_MODE_MARVELL;
+		ax178dataptr->LedMode  = 0;
+		ax178dataptr->UseGpio0 = 1; /* True */
+	} else {
+		ax178dataptr->PhyMode = (u8)(ax178dataptr->EepromData &
+					     EEPROMMASK);
+		ax178dataptr->LedMode = (u8)(ax178dataptr->EepromData >> 8);
+
+		/* for buffalo new (use gpio2) */
+		if (ax178dataptr->LedMode == 6)
+			ax178dataptr->LedMode = 1;
+		else if (ax178dataptr->LedMode == 1)
+			ax178dataptr->BuffaloOld = 1;
+
+
+		if (ax178dataptr->EepromData & 0x80)
+			ax178dataptr->UseGpio0 = 0; /* MARVEL se and other */
+		else
+			ax178dataptr->UseGpio0 = 1; /* cameo */
+	}
+
+	if (ax178dataptr->UseGpio0) {
+
+		if (ax178dataptr->PhyMode == PHY_MODE_MARVELL) {
+			ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS,
+					AXGPIOS_GPO0EN | AXGPIOS_RSE,
+					0, 0, NULL);
+			if (ret < 0) {
+				deverr(dev, "write GPIO failed: %d", ret);
+				goto error_out;
+			}
+
+			msleep(25);
+
+			ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS,
+					(AXGPIOS_GPO2 | AXGPIOS_GPO2EN |
+					 AXGPIOS_GPO0EN), 0, 0, NULL);
+			if (ret < 0) {
+				deverr(dev, "write GPIO failed: %d", ret);
+				goto error_out;
+			}
+
+			msleep(15);
+
+			ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS,
+					AXGPIOS_GPO2EN | AXGPIOS_GPO0EN,
+					0, 0, NULL);
+			if (ret < 0) {
+				deverr(dev, "write GPIO failed: %d", ret);
+				goto error_out;
+			}
+
+			msleep(245);
+
+			ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS,
+					(AXGPIOS_GPO2 | AXGPIOS_GPO2EN |
+					 AXGPIOS_GPO0EN), 0, 0, NULL);
+			if (ret < 0) {
+				deverr(dev, "write GPIO failed: %d", ret);
+				goto error_out;
+			}
+
+		} else { /* vitesse */
+
+			ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS,
+					(AXGPIOS_RSE | AXGPIOS_GPO0EN |
+					 AXGPIOS_GPO0), 0, 0, NULL);
+			if (ret < 0) {
+				deverr(dev, "write GPIO failed: %d", ret);
+				goto error_out;
+			}
+
+			msleep(25);
+
+			ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS,
+					(AXGPIOS_GPO0EN | AXGPIOS_GPO0 |
+					 AXGPIOS_GPO2EN | AXGPIOS_GPO2),
+					0, 0, NULL);
+			if (ret < 0) {
+				deverr(dev, "write GPIO failed: %d", ret);
+				goto error_out;
+			}
+
+			msleep(25);
+
+			ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS,
+					(AXGPIOS_GPO0EN | AXGPIOS_GPO0 |
+					 AXGPIOS_GPO2EN), 0, 0, NULL);
+			if (ret < 0) {
+				deverr(dev, "write GPIO failed: %d", ret);
+				goto error_out;
+			}
+
+			msleep(245);
+
+			ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS,
+						(AXGPIOS_GPO0EN | AXGPIOS_GPO0 |
+						AXGPIOS_GPO2EN | AXGPIOS_GPO2),
+						0, 0, NULL);
+			if (ret < 0) {
+				deverr(dev, "write GPIO failed: %d", ret);
+				goto error_out;
+			}
+		}
+	} else {	/* use gpio1 */
+		ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS,
+					(AXGPIOS_GPO1 | AXGPIOS_GPO1EN |
+					AXGPIOS_RSE), 0, 0, NULL);
+		if (ret < 0) {
+			deverr(dev, "write GPIO failed: %d", ret);
+			goto error_out;
+		}
+
+		if (ax178dataptr->BuffaloOld) {
+			msleep(350);
+
+			ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS,
+						AXGPIOS_GPO1EN, 0, 0, NULL);
+			if (ret < 0) {
+				deverr(dev, "write GPIO failed: %d", ret);
+				goto error_out;
+			}
+
+			msleep(350);
+
+			ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS,
+						AXGPIOS_GPO1EN | AXGPIOS_GPO1,
+						0, 0, NULL);
+			if (ret < 0) {
+				deverr(dev, "write GPIO failed: %d", ret);
+				goto error_out;
+			}
+		} else {
+			msleep(25);
+
+			ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS,
+						(AXGPIOS_GPO1EN | AXGPIOS_GPO1 |
+						AXGPIOS_GPO2EN | AXGPIOS_GPO2),
+						0, 0, NULL);
+			if (ret < 0) {
+				deverr(dev, "write GPIO failed: %d", ret);
+				goto error_out;
+			}
+
+			msleep(25);
+
+			ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS,
+						(AXGPIOS_GPO1EN | AXGPIOS_GPO1 |
+						AXGPIOS_GPO2EN), 0, 0, NULL);
+			if (ret < 0) {
+				deverr(dev, "write GPIO failed: %d", ret);
+				goto error_out;
+			}
+
+			msleep(245);
+
+			ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS,
+						(AXGPIOS_GPO1EN | AXGPIOS_GPO1 |
+						AXGPIOS_GPO2EN | AXGPIOS_GPO2),
+						0, 0, NULL);
+			if (ret < 0) {
+				deverr(dev, "write GPIO failed: %d", ret);
+				goto error_out;
+			}
+		}
+	}
+
+	ret = ax8817x_write_cmd(dev, AX_CMD_SW_PHY_SELECT, 0, 0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Select PHY failed: %d", ret);
+		goto error_out;
+	}
+
+	ret = ax8817x_write_cmd(dev, AX_CMD_SW_RESET, AX_SWRESET_IPPD |
+				AX_SWRESET_PRL, 0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Issue sw reset failed: %d", ret);
+		goto error_out;
+	}
+
+	ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL, 0, 0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Issue rx ctrl failed: %d", ret);
+		goto error_out;
+	}
+
+	/* Get the MAC address */
+	memset(buf, 0, ETH_ALEN);
+	ax8817x_get_mac(dev, buf);
+	if (ret < 0)
+		goto error_out;
+	/* End of get MAC address */
+
+	ret = ax88178_phy_init(dev, ax178dataptr);
+	if (ret < 0)
+		goto error_out;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 30)
+	dev->net->do_ioctl = ax8817x_ioctl;
+	dev->net->set_multicast_list = ax88178_set_multicast;
+	dev->net->set_mac_address = ax8817x_set_mac_addr;
+#else
+	dev->net->netdev_ops = &ax88178_netdev_ops;
+#endif
+	dev->net->ethtool_ops = &ax8817x_ethtool_ops;
+
+	/* Register suspend and resume functions */
+	data->suspend = ax88772_suspend;
+	data->resume = ax88772_resume;
+
+	if (dev->driver_info->flags & FLAG_FRAMING_AX)
+		dev->rx_urb_size = 16384;
+
+	ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL, (AX_RX_CTL_MFB |
+				AX_RX_CTL_START | AX_RX_CTL_AB), 0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "write RX ctrl reg failed: %d", ret);
+		goto error_out;
+	}
+
+	kfree(buf);
+	printk(version);
+	return ret;
+
+error_out:
+	kfree(ax178dataptr);
+	kfree(buf);
+	return ret;
+}
+
+static void ax88178_unbind(struct usbnet *dev, struct usb_interface *intf)
+{
+	struct ax88178_data *ax178dataptr = (struct ax88178_data *)dev->priv;
+
+	if (ax178dataptr) {
+
+		/* stop MAC operation */
+		ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL,
+					AX_RX_CTL_STOP, 0, 0, NULL);
+
+		kfree(ax178dataptr);
+	}
+}
+
+static int ax88772_rx_fixup(struct usbnet *dev, struct sk_buff *skb)
+{
+	u8  *head;
+	u32  header;
+	char *packet;
+	struct sk_buff *ax_skb = NULL;
+	u16 size;
+
+	head = (u8 *) skb->data;
+	memcpy(&header, head, sizeof(header));
+	le32_to_cpus(&header);
+	packet = head + sizeof(header);
+
+	skb_pull(skb, 4);
+
+	while (skb->len > 0) {
+		if ((short)(header & 0x00007ff) !=
+		    ~((short)(((header & 0xffff0000) | 0xf8000000) >> 16))) {
+			deverr(dev, "header length data is error 0x%08x, %d\n",
+				header, skb->len);
+		}
+		/* get the packet length */
+		size = (u16) (header & 0x00007ff);
+
+		if ((skb->len) - ((size + 1) & 0xfffe) == 0) {
+
+			/* Make sure ip header is aligned on 32-bit boundary */
+			if (!((unsigned long)skb->data & 0x02)) {
+				memmove(skb->data - 2, skb->data, size);
+				skb->data -= 2;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 22)
+				skb->tail = skb->data + size;
+#else
+				skb_set_tail_pointer(skb, size);
+#endif
+			}
+			skb->truesize = size + sizeof(struct sk_buff);
+			skb->len = size;
+
+			return 2;
+		}
+
+		if (size > ETH_FRAME_LEN) {
+			deverr(dev, "invalid rx length %d", size);
+			return 0;
+		}
+#ifndef RX_SKB_COPY
+		ax_skb = skb_clone(skb, GFP_ATOMIC);
+#else
+		ax_skb = alloc_skb(size + NET_IP_ALIGN, GFP_ATOMIC);	
+		skb_reserve(ax_skb, NET_IP_ALIGN);
+#endif
+		if (ax_skb) {
+#ifndef RX_SKB_COPY
+			/* Make sure ip header is aligned on 32-bit boundary */
+			if (!((unsigned long)packet & 0x02)) {
+				memmove(packet - 2, packet, size);
+				packet -= 2;
+			}
+			ax_skb->data = packet;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 22)
+			ax_skb->tail = packet + size;
+#else
+			skb_set_tail_pointer(ax_skb, size);
+#endif
+
+#else
+			skb_put(ax_skb, size);
+			memcpy(ax_skb->data, packet , size);
+#endif
+			ax_skb->truesize = size + sizeof(struct sk_buff);
+			axusbnet_skb_return(dev, ax_skb);
+
+		} else {
+			return 0;
+		}
+
+		skb_pull(skb, (size + 1) & 0xfffe);
+
+		if (skb->len == 0)
+			break;
+
+		head = (u8 *) skb->data;
+		memcpy(&header, head, sizeof(header));
+		le32_to_cpus(&header);
+		packet = head + sizeof(header);
+		skb_pull(skb, 4);
+	}
+
+	if (skb->len < 0) {
+		deverr(dev, "invalid rx length %d", skb->len);
+		return 0;
+	}
+	return 1;
+}
+
+static struct sk_buff *ax88772_tx_fixup(struct usbnet *dev, struct sk_buff *skb,
+					gfp_t flags)
+{
+	int padlen = ((skb->len + 4) % 512) ? 0 : 4;
+	u32 packet_len;
+	u32 padbytes = 0xffff0000;
+
+#if (!AX_FORCE_BUFF_ALIGN)
+	int headroom = skb_headroom(skb);
+	int tailroom = skb_tailroom(skb);
+
+	if ((!skb_cloned(skb))
+	    && ((headroom + tailroom) >= (4 + padlen))) {
+		if ((headroom < 4) || (tailroom < padlen)) {
+			skb->data = memmove(skb->head + 4, skb->data, skb->len);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 22)
+		skb->tail = skb->data + skb->len;
+#else
+		skb_set_tail_pointer(skb, skb->len);
+#endif
+		}
+	} else
+#endif
+	{
+		struct sk_buff *skb2;
+		skb2 = skb_copy_expand(skb, 4, padlen, flags);
+		dev_kfree_skb_any(skb);
+		skb = skb2;
+		if (!skb)
+			return NULL;
+	}
+
+	skb_push(skb, 4);
+	packet_len = (((skb->len - 4) ^ 0x0000ffff) << 16) + (skb->len - 4);
+	cpu_to_le32s(&packet_len);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 22)
+	memcpy(skb->data, &packet_len, sizeof(packet_len));
+#else
+	skb_copy_to_linear_data(skb, &packet_len, sizeof(packet_len));
+#endif
+
+	if ((skb->len % 512) == 0) {
+		cpu_to_le32s(&padbytes);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 22)
+		memcpy(skb->tail, &padbytes, sizeof(padbytes));
+#else
+		memcpy(skb_tail_pointer(skb), &padbytes, sizeof(padbytes));
+#endif
+		skb_put(skb, sizeof(padbytes));
+	}
+	return skb;
+}
+
+static void
+ax88772b_rx_checksum(struct sk_buff *skb, struct ax88772b_rx_header *rx_hdr)
+{
+	skb->ip_summed = CHECKSUM_NONE;
+
+	/* checksum error bit is set */
+	if (rx_hdr->l3_csum_err || rx_hdr->l4_csum_err)
+		return;
+
+	/* It must be a TCP or UDP packet with a valid checksum */
+	if ((rx_hdr->l4_type == AX_RXHDR_L4_TYPE_TCP) ||
+	    (rx_hdr->l4_type == AX_RXHDR_L4_TYPE_UDP)) {
+		skb->ip_summed = CHECKSUM_UNNECESSARY;
+	}
+}
+
+static int ax88772b_rx_fixup(struct usbnet *dev, struct sk_buff *skb)
+{
+	struct ax88772b_rx_header rx_hdr;
+	struct sk_buff *ax_skb = NULL;
+	struct ax88772b_data *ax772b_data = (struct ax88772b_data *)dev->priv;
+
+	while (skb->len > 0) {
+
+		le16_to_cpus((u16 *)skb->data);
+		le16_to_cpus(((u16 *)skb->data) + 1);
+
+		memcpy(&rx_hdr, skb->data, sizeof(struct ax88772b_rx_header));
+
+		if ((short)rx_hdr.len != (~((short)rx_hdr.len_bar) & 0x7FF))
+			return 0;
+
+		if (rx_hdr.len > (ETH_FRAME_LEN + 4)) {
+			deverr(dev, "invalid rx length %d", rx_hdr.len);
+			return 0;
+		}
+
+		if (skb->len - ((rx_hdr.len +
+				 sizeof(struct ax88772b_rx_header) + 3) &
+				 0xfffc) == 0) {
+			skb_pull(skb, sizeof(struct ax88772b_rx_header));
+			skb->len = rx_hdr.len;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 22)
+			skb->tail = skb->data + rx_hdr.len;
+#else
+			skb_set_tail_pointer(skb, rx_hdr.len);
+#endif
+			skb->truesize = rx_hdr.len + sizeof(struct sk_buff);
+
+			if (ax772b_data->checksum & AX_RX_CHECKSUM)
+				ax88772b_rx_checksum(skb, &rx_hdr);
+
+			return 2;
+		}
+#ifndef RX_SKB_COPY
+		ax_skb = skb_clone(skb, GFP_ATOMIC);
+#else
+		ax_skb = alloc_skb(rx_hdr.len + NET_IP_ALIGN, GFP_ATOMIC);
+		skb_reserve(ax_skb, NET_IP_ALIGN);	
+#endif
+		if (ax_skb) {
+#ifndef RX_SKB_COPY
+			ax_skb->len = rx_hdr.len;
+			ax_skb->data = skb->data +
+				       sizeof(struct ax88772b_rx_header);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 22)
+			ax_skb->tail = ax_skb->data + rx_hdr.len;
+#else
+			skb_set_tail_pointer(ax_skb, rx_hdr.len);
+#endif
+
+#else
+			skb_put(ax_skb, rx_hdr.len);
+			memcpy(ax_skb->data, skb->data + sizeof(struct ax88772b_rx_header), rx_hdr.len); 
+#endif
+
+			ax_skb->truesize = rx_hdr.len + sizeof(struct sk_buff);
+
+			if (ax772b_data->checksum & AX_RX_CHECKSUM)
+				ax88772b_rx_checksum(ax_skb, &rx_hdr);
+
+			axusbnet_skb_return(dev, ax_skb);
+
+		} else {
+			return 0;
+		}
+
+		skb_pull(skb, ((rx_hdr.len +
+				sizeof(struct ax88772b_rx_header) + 3)
+				& 0xfffc));
+	}
+
+	if (skb->len < 0) {
+		deverr(dev, "invalid rx length %d", skb->len);
+		return 0;
+	}
+	return 1;
+}
+
+static struct sk_buff *
+ax88772b_tx_fixup(struct usbnet *dev, struct sk_buff *skb, gfp_t flags)
+{
+	int padlen = ((skb->len + 4) % 512) ? 0 : 4;
+	u32 packet_len;
+	u32 padbytes = 0xffff0000;
+
+#if (!AX_FORCE_BUFF_ALIGN)
+	int headroom = skb_headroom(skb);
+	int tailroom = skb_tailroom(skb);
+
+	if ((!skb_cloned(skb))
+	    && ((headroom + tailroom) >= (4 + padlen))) {
+		if ((headroom < 4) || (tailroom < padlen)) {
+			skb->data = memmove(skb->head + 4, skb->data, skb->len);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 22)
+			skb->tail = skb->data + skb->len;
+#else
+			skb_set_tail_pointer(skb, skb->len);
+#endif
+		}
+	} else
+#endif
+	{
+		struct sk_buff *skb2;
+		skb2 = skb_copy_expand(skb, 4, padlen, flags);
+		dev_kfree_skb_any(skb);
+		skb = skb2;
+		if (!skb)
+			return NULL;
+	}
+
+	skb_push(skb, 4);
+	packet_len = (((skb->len - 4) ^ 0x0000ffff) << 16) + (skb->len - 4);
+
+	cpu_to_le32s(&packet_len);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 22)
+	memcpy(skb->data, &packet_len, sizeof(packet_len));
+#else
+	skb_copy_to_linear_data(skb, &packet_len, sizeof(packet_len));
+#endif
+
+	if ((skb->len % 512) == 0) {
+		cpu_to_le32s(&padbytes);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 22)
+		memcpy(skb->tail, &padbytes, sizeof(padbytes));
+#else
+		memcpy(skb_tail_pointer(skb), &padbytes, sizeof(padbytes));
+#endif
+		skb_put(skb, sizeof(padbytes));
+	}
+
+	return skb;
+}
+
+static const u8 chkcntsel[6][3] = {
+	{12, 23, 31},
+	{12, 31, 23},
+	{23, 31, 12},
+	{23, 12, 31},
+	{31, 12, 23},
+	{31, 23, 12}
+};
+
+static void ax88772_save_bmcr_anar(struct usbnet *dev)
+{
+	struct ax88772_data *ax772_data = (struct ax88772_data *)dev->priv;
+
+	if (ax772_data) {
+		/* Preserve BMCR for restoring */
+		ax772_data->presvd_phy_bmcr =
+			ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, MII_BMCR);
+
+		/* Preserve Advertisement control reg for restoring */
+		ax772_data->presvd_phy_advertise =
+			ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, MII_ADVERTISE);
+	}
+}
+
+static void ax88772_restore_bmcr_anar(struct usbnet *dev)
+{
+	struct ax88772_data *ax772_data = (struct ax88772_data *)dev->priv;
+
+	if (ax772_data && ax772_data->presvd_phy_advertise && ax772_data->presvd_phy_bmcr) {
+		/* Restore Advertisement control reg */
+		ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, MII_ADVERTISE,
+				      ax772_data->presvd_phy_advertise);
+		/* Restore BMCR */
+		ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, MII_BMCR,
+				      ax772_data->presvd_phy_bmcr);
+		ax772_data->presvd_phy_advertise = 0;
+		ax772_data->presvd_phy_bmcr = 0;
+	}
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20)
+static void ax88772_link_reset(void *data)
+{
+	struct usbnet *dev = (struct usbnet *)data;
+	struct ax88772_data *ax772_data = (struct ax88772_data *)dev->priv;
+#else
+static void ax88772_link_reset(struct work_struct *work)
+{
+	struct ax88772_data *ax772_data = container_of(work,
+						       struct ax88772_data,
+						       check_link);
+	struct usbnet *dev = ax772_data->dev;
+#endif
+	if (ax772_data->Event == AX_SET_RX_CFG) {
+		u16 bmcr;
+		u16 mode;
+
+		ax772_data->Event = AX_NOP;
+
+		mode = AX88772_MEDIUM_DEFAULT;
+
+		bmcr = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id,
+					    MII_BMCR);
+		if (!(bmcr & BMCR_FULLDPLX))
+			mode &= ~AX88772_MEDIUM_FULL_DUPLEX;
+		if (!(bmcr & BMCR_SPEED100))
+			mode &= ~AX88772_MEDIUM_100MB;
+
+		ax8817x_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE,
+				  mode, 0, 0, NULL);
+		return;
+	}
+
+	switch (ax772_data->Event) {
+	case WAIT_AUTONEG_COMPLETE:
+		if (jiffies > (ax772_data->autoneg_start + 5 * HZ)) {
+			ax772_data->Event = PHY_POWER_DOWN;
+			ax772_data->TickToExpire = 23;
+		}
+		break;
+	case PHY_POWER_DOWN:
+		if (ax772_data->TickToExpire == 23) {
+			ax88772_save_bmcr_anar(dev);
+			/* Set Phy Power Down */
+			ax8817x_write_cmd(dev, AX_CMD_SW_RESET, AX_SWRESET_IPPD,
+					  0, 0, NULL);
+			--ax772_data->TickToExpire;
+		} else if (--ax772_data->TickToExpire == 0) {
+			/* Set Phy Power Up */
+			ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
+				AX_SWRESET_IPRL, 0, 0, NULL);
+			ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
+				AX_SWRESET_IPPD | AX_SWRESET_IPRL, 0, 0, NULL);
+			msleep(10);
+			ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
+				AX_SWRESET_IPRL, 0, 0, NULL);
+			msleep(60);
+			ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
+				AX_SWRESET_CLEAR, 0, 0, NULL);
+			ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
+				AX_SWRESET_IPRL, 0, 0, NULL);
+
+			if (ax772_data->presvd_phy_advertise && ax772_data->presvd_phy_bmcr) {
+				ax88772_restore_bmcr_anar(dev);
+				
+			} else {
+				ax8817x_mdio_write_le(dev->net, dev->mii.phy_id,
+						      MII_ADVERTISE,
+						      ADVERTISE_ALL | ADVERTISE_CSMA |
+						      ADVERTISE_PAUSE_CAP);
+				mii_nway_restart(&dev->mii);
+			}
+
+			ax772_data->Event = PHY_POWER_UP;
+			ax772_data->TickToExpire = 47;
+		}
+		break;
+	case PHY_POWER_UP:
+		if (--ax772_data->TickToExpire == 0) {
+			ax772_data->Event = PHY_POWER_DOWN;
+			ax772_data->TickToExpire = 23;
+		}
+		break;
+	default:
+		break;
+	}
+	return;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20)
+static void ax88772a_link_reset(void *data)
+{
+	struct usbnet *dev = (struct usbnet *)data;
+	struct ax88772a_data *ax772a_data = (struct ax88772a_data *)dev->priv;
+#else
+static void ax88772a_link_reset(struct work_struct *work)
+{
+	struct ax88772a_data *ax772a_data = container_of(work,
+							 struct ax88772a_data,
+							 check_link);
+	struct usbnet *dev = ax772a_data->dev;
+#endif
+	int powsave = (ax772a_data->EepromData >> 14);
+	u16 phy_reg;
+
+	if (ax772a_data->Event == AX_SET_RX_CFG) {
+		u16 bmcr;
+		u16 mode;
+
+		ax772a_data->Event = AX_NOP;
+
+		mode = AX88772_MEDIUM_DEFAULT;
+
+		bmcr = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id,
+					    MII_BMCR);
+		if (!(bmcr & BMCR_FULLDPLX))
+			mode &= ~AX88772_MEDIUM_FULL_DUPLEX;
+		if (!(bmcr & BMCR_SPEED100))
+			mode &= ~AX88772_MEDIUM_100MB;
+
+		ax8817x_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE, mode,
+				  0, 0, NULL);
+
+		if (ax772a_data->presvd_phy_advertise && ax772a_data->presvd_phy_bmcr) {
+
+			/* Restore Advertisement control reg */
+			ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, MII_ADVERTISE,
+					      ax772a_data->presvd_phy_advertise);
+			/* Restore BMCR */
+			ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, MII_BMCR,
+					      ax772a_data->presvd_phy_bmcr);
+			ax772a_data->presvd_phy_advertise = 0;
+			ax772a_data->presvd_phy_bmcr = 0;
+		}
+
+		return;
+	}
+
+	switch (ax772a_data->Event) {
+	case WAIT_AUTONEG_COMPLETE:
+		if (jiffies > (ax772a_data->autoneg_start + 5 * HZ)) {
+			ax772a_data->Event = CHK_CABLE_EXIST;
+			ax772a_data->TickToExpire = 14;
+		}
+		break;
+	case CHK_CABLE_EXIST:
+		phy_reg = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, 0x12);
+		if ((phy_reg != 0x8012) && (phy_reg != 0x8013)) {
+			ax8817x_mdio_write_le(dev->net,
+				dev->mii.phy_id, 0x16, 0x4040);
+			mii_nway_restart(&dev->mii);
+			ax772a_data->Event = CHK_CABLE_STATUS;
+			ax772a_data->TickToExpire = 31;
+		} else if (--ax772a_data->TickToExpire == 0) {
+			mii_nway_restart(&dev->mii);
+			ax772a_data->Event = CHK_CABLE_EXIST_AGAIN;
+			if (powsave == 0x03) {
+				ax772a_data->TickToExpire = 47;
+			} else if (powsave == 0x01) {
+				ax772a_data->DlyIndex = (u8)(jiffies % 6);
+				ax772a_data->DlySel = 0;
+				ax772a_data->TickToExpire =
+			chkcntsel[ax772a_data->DlyIndex][ax772a_data->DlySel];
+			}
+		}
+		break;
+	case CHK_CABLE_EXIST_AGAIN:
+		/* if cable disconnected */
+		phy_reg = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, 0x12);
+		if ((phy_reg != 0x8012) && (phy_reg != 0x8013)) {
+			mii_nway_restart(&dev->mii);
+			ax772a_data->Event = CHK_CABLE_STATUS;
+			ax772a_data->TickToExpire = 31;
+		} else if (--ax772a_data->TickToExpire == 0) {
+			if (!ax772a_data->presvd_phy_advertise && !ax772a_data->presvd_phy_bmcr) {
+				/* Preserve BMCR for restoring */
+				ax772a_data->presvd_phy_bmcr =
+					ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, MII_BMCR);
+
+				/* Preserve Advertisement control reg for restoring */
+				ax772a_data->presvd_phy_advertise =
+					ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, MII_ADVERTISE);
+			}
+
+
+			/* Power down PHY */
+			ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
+					  AX_SWRESET_IPPD,
+					  0, 0, NULL);
+			ax772a_data->Event = PHY_POWER_DOWN;
+			if (powsave == 0x03)
+				ax772a_data->TickToExpire = 23;
+			else if (powsave == 0x01)
+				ax772a_data->TickToExpire = 31;
+		}
+		break;
+	case PHY_POWER_DOWN:
+		if (--ax772a_data->TickToExpire == 0)
+			ax772a_data->Event = PHY_POWER_UP;
+		break;
+	case CHK_CABLE_STATUS:
+		if (--ax772a_data->TickToExpire == 0) {
+			ax8817x_mdio_write_le(dev->net,
+					dev->mii.phy_id, 0x16, 0x4040);
+			mii_nway_restart(&dev->mii);
+			ax772a_data->Event = CHK_CABLE_EXIST_AGAIN;
+			if (powsave == 0x03) {
+				ax772a_data->TickToExpire = 47;
+			} else if (powsave == 0x01) {
+				ax772a_data->DlyIndex = (u8)(jiffies % 6);
+				ax772a_data->DlySel = 0;
+				ax772a_data->TickToExpire =
+			chkcntsel[ax772a_data->DlyIndex][ax772a_data->DlySel];
+			}
+		}
+		break;
+	case PHY_POWER_UP:
+
+		if (!ax772a_data->presvd_phy_advertise && !ax772a_data->presvd_phy_bmcr) {
+			/* Preserve BMCR for restoring */
+			ax772a_data->presvd_phy_bmcr =
+				ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, MII_BMCR);
+
+			/* Preserve Advertisement control reg for restoring */
+			ax772a_data->presvd_phy_advertise =
+				ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, MII_ADVERTISE);
+		}
+
+		ax88772a_phy_powerup(dev);
+
+		ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, MII_ADVERTISE,
+			ADVERTISE_ALL | ADVERTISE_CSMA | ADVERTISE_PAUSE_CAP);
+
+		mii_nway_restart(&dev->mii);
+
+		ax772a_data->Event = CHK_CABLE_EXIST_AGAIN;
+
+		if (powsave == 0x03) {
+			ax772a_data->TickToExpire = 47;
+		} else if (powsave == 0x01) {
+			if (++ax772a_data->DlySel >= 3) {
+				ax772a_data->DlyIndex = (u8)(jiffies % 6);
+				ax772a_data->DlySel = 0;
+			}
+			ax772a_data->TickToExpire =
+			chkcntsel[ax772a_data->DlyIndex][ax772a_data->DlySel];
+		}
+		break;
+	default:
+		break;
+	}
+
+	return;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20)
+static void ax88772b_link_reset(void *data)
+{
+	struct usbnet *dev = (struct usbnet *)data;
+	struct ax88772b_data *ax772b_data = (struct ax88772b_data *)dev->priv;
+#else
+static void ax88772b_link_reset(struct work_struct *work)
+{
+	struct ax88772b_data *ax772b_data = container_of(work,
+							 struct ax88772b_data,
+							 check_link);
+	struct usbnet *dev = ax772b_data->dev;
+#endif
+
+	switch (ax772b_data->Event) {
+
+	case AX_SET_RX_CFG:
+	{
+		u16 bmcr = ax8817x_mdio_read_le(dev->net,
+					dev->mii.phy_id, MII_BMCR);
+		u16 mode = AX88772_MEDIUM_DEFAULT;
+
+		if (!(bmcr & BMCR_FULLDPLX))
+			mode &= ~AX88772_MEDIUM_FULL_DUPLEX;
+		if (!(bmcr & BMCR_SPEED100))
+			mode &= ~AX88772_MEDIUM_100MB;	
+
+		if (ax772b_data->ext_phy_oui == EXTPHY_BROADCOM_OUI) {
+			if(ax772b_data->ext_phy_model == EXTPHY_BCM89811_MODEL) {
+				mode = AX88772_MEDIUM_DEFAULT;
+			}
+		}
+
+		ax8817x_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE, mode,
+				  0, 0, NULL);
+		break;
+	}
+	case PHY_POWER_UP:
+	{
+		u16 tmp16;
+
+		if (!ax772b_data->presvd_phy_advertise && !ax772b_data->presvd_phy_bmcr) {
+			/* Preserve BMCR for restoring */
+			ax772b_data->presvd_phy_bmcr =
+				ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, MII_BMCR);
+
+			/* Preserve Advertisement control reg for restoring */
+			ax772b_data->presvd_phy_advertise =
+				ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, MII_ADVERTISE);
+		}
+
+		ax88772a_phy_powerup(dev);
+		tmp16 = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, 0x12);
+		ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, 0x12,
+				((tmp16 & 0xFF9F) | 0x0040));
+
+		/* Restore Advertisement control reg */
+		ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, MII_ADVERTISE,
+				      ax772b_data->presvd_phy_advertise);
+		/* Restore BMCR */
+		ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, MII_BMCR,
+				      ax772b_data->presvd_phy_bmcr);
+		ax772b_data->presvd_phy_advertise = 0;
+		ax772b_data->presvd_phy_bmcr = 0;
+
+		break;
+	}
+
+	case AX_CHK_AUTODETACH:
+	{
+		int ret;
+		ret = ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
+					AX_SWRESET_IPRL |
+					(ax772b_data->psc & 0x7FFF),
+					0, 0, NULL);
+		if (ret < 0) {
+			deverr(dev, "Failed to configure PHY power saving: %d",
+			       ret);
+		}
+
+		break;
+	}
+	default:
+		break;
+	}
+
+	ax772b_data->Event = AX_NOP;
+	
+	return;
+}
+
+static int ax88178_set_media(struct usbnet *dev)
+{
+	int	ret;
+	struct ax88178_data *ax178dataptr = (struct ax88178_data *)dev->priv;
+	int media;
+
+	media = ax88178_media_check(dev, ax178dataptr);
+	if (media < 0)
+		return media;
+
+	ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE, media, 0,
+				0, NULL);
+	if (ret < 0) {
+		deverr(dev, "write mode medium reg failed: %d", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int ax88178_link_reset(struct usbnet *dev)
+{
+	return ax88178_set_media(dev);
+}
+
+static int ax_suspend(struct usb_interface *intf,
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 10)
+			pm_message_t message)
+#else
+			u32 message)
+#endif
+{
+	struct usbnet *dev = usb_get_intfdata(intf);
+	struct ax8817x_data *data = (struct ax8817x_data *)&dev->data;
+
+	return data->suspend(intf, message);
+}
+
+static int ax_resume(struct usb_interface *intf)
+{
+	struct usbnet *dev = usb_get_intfdata(intf);
+	struct ax8817x_data *data = (struct ax8817x_data *)&dev->data;
+
+	return data->resume(intf);
+}
+
+static const struct driver_info ax88178_info = {
+	.description = "ASIX AX88178 USB 2.0 Ethernet",
+	.bind	= ax88178_bind,
+	.unbind = ax88178_unbind,
+	.status = ax88178_status,
+	.link_reset = ax88178_link_reset,
+	.reset	= ax88178_link_reset,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 32)
+	.stop	= ax88772b_stop,
+	.flags	= FLAG_ETHER | FLAG_FRAMING_AX | FLAG_AVOID_UNLINK_URBS,
+#else
+	.flags	= FLAG_ETHER | FLAG_FRAMING_AX,
+#endif
+	.rx_fixup = ax88772_rx_fixup,
+	.tx_fixup = ax88772_tx_fixup,
+};
+
+static const struct driver_info belkin178_info = {
+	.description = "Belkin Gigabit USB 2.0 Network Adapter",
+	.bind	= ax88178_bind,
+	.unbind	= ax88178_unbind,
+	.status	= ax88178_status,
+	.link_reset = ax88178_link_reset,
+	.reset	= ax88178_link_reset,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 32)
+	.stop	= ax88772b_stop,
+	.flags	= FLAG_ETHER | FLAG_FRAMING_AX | FLAG_AVOID_UNLINK_URBS,
+#else
+	.flags	= FLAG_ETHER | FLAG_FRAMING_AX,
+#endif
+	.rx_fixup = ax88772_rx_fixup,
+	.tx_fixup = ax88772_tx_fixup,
+};
+
+static const struct driver_info ax8817x_info = {
+	.description = "ASIX AX8817x USB 2.0 Ethernet",
+	.bind	= ax8817x_bind,
+	.status	= ax8817x_status,
+	.link_reset = ax88172_link_reset,
+	.reset	= ax88172_link_reset,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 32)
+	.stop	= ax88772b_stop,
+	.flags	= FLAG_ETHER | FLAG_AVOID_UNLINK_URBS,
+#else
+	.flags	= FLAG_ETHER,
+#endif
+};
+
+static const struct driver_info dlink_dub_e100_info = {
+	.description = "DLink DUB-E100 USB Ethernet",
+	.bind	= ax8817x_bind,
+	.status	= ax8817x_status,
+	.link_reset = ax88172_link_reset,
+	.reset	= ax88172_link_reset,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 32)
+	.stop	= ax88772b_stop,
+	.flags	= FLAG_ETHER | FLAG_AVOID_UNLINK_URBS,
+#else
+	.flags	= FLAG_ETHER,
+#endif
+};
+
+static const struct driver_info netgear_fa120_info = {
+	.description = "Netgear FA-120 USB Ethernet",
+	.bind	= ax8817x_bind,
+	.status = ax8817x_status,
+	.link_reset = ax88172_link_reset,
+	.reset	= ax88172_link_reset,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 32)
+	.stop	= ax88772b_stop,
+	.flags	= FLAG_ETHER | FLAG_AVOID_UNLINK_URBS,
+#else
+	.flags	= FLAG_ETHER,
+#endif
+};
+
+static const struct driver_info hawking_uf200_info = {
+	.description = "Hawking UF200 USB Ethernet",
+	.bind	= ax8817x_bind,
+	.status = ax8817x_status,
+	.link_reset = ax88172_link_reset,
+	.reset	= ax88172_link_reset,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 32)
+	.stop	= ax88772b_stop,
+	.flags	= FLAG_ETHER | FLAG_AVOID_UNLINK_URBS,
+#else
+	.flags	= FLAG_ETHER,
+#endif
+};
+
+static const struct driver_info ax88772_info = {
+	.description = "ASIX AX88772 USB 2.0 Ethernet",
+	.bind	= ax88772_bind,
+	.unbind = ax88772_unbind,
+	.status = ax88772_status,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 32)
+	.stop	= ax88772b_stop,
+	.flags	= FLAG_ETHER | FLAG_FRAMING_AX | FLAG_AVOID_UNLINK_URBS,
+#else
+	.flags	= FLAG_ETHER | FLAG_FRAMING_AX,
+#endif
+	.rx_fixup = ax88772_rx_fixup,
+	.tx_fixup = ax88772_tx_fixup,
+	.reset	= ax88772b_reset,
+};
+
+static const struct driver_info dlink_dub_e100b_info = {
+	.description = "D-Link DUB-E100 USB 2.0 Fast Ethernet Adapter",
+	.bind	= ax88772_bind,
+	.unbind = ax88772_unbind,
+	.status = ax88772_status,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 32)
+	.stop	= ax88772b_stop,
+	.flags	= FLAG_ETHER | FLAG_FRAMING_AX | FLAG_AVOID_UNLINK_URBS,
+#else
+	.flags	= FLAG_ETHER | FLAG_FRAMING_AX,
+#endif
+	.rx_fixup = ax88772_rx_fixup,
+	.tx_fixup = ax88772_tx_fixup,
+	.reset	= ax88772b_reset,
+};
+
+static const struct driver_info dlink_dub_e100_772b_info = {
+	.description = "D-Link DUB-E100 USB 2.0 Fast Ethernet Adapter",
+	.bind	= ax88772b_bind,
+	.unbind = ax88772b_unbind,
+	.status = ax88772b_status,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 32)
+	.stop	= ax88772b_stop,
+	.flags	= FLAG_ETHER | FLAG_FRAMING_AX | FLAG_HW_IP_ALIGNMENT | FLAG_AVOID_UNLINK_URBS,
+#else
+	.flags	= FLAG_ETHER | FLAG_FRAMING_AX | FLAG_HW_IP_ALIGNMENT,
+#endif
+	.rx_fixup = ax88772b_rx_fixup,
+	.tx_fixup = ax88772b_tx_fixup,
+	.reset	= ax88772b_reset,
+};
+
+static const struct driver_info dlink_dub_e100_772c_info = {
+	.description = "D-Link DUB-E100 USB 2.0 Fast Ethernet Adapter",
+	.bind	= ax88772b_bind,
+	.unbind = ax88772b_unbind,
+	.status = ax88772b_status,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 32)
+	.stop	= ax88772b_stop,
+	.flags	= FLAG_ETHER | FLAG_FRAMING_AX | FLAG_HW_IP_ALIGNMENT | FLAG_AVOID_UNLINK_URBS,
+#else
+	.flags	= FLAG_ETHER | FLAG_FRAMING_AX | FLAG_HW_IP_ALIGNMENT,
+#endif
+	.rx_fixup = ax88772b_rx_fixup,
+	.tx_fixup = ax88772b_tx_fixup,
+	.reset	= ax88772b_reset,
+};
+
+static const struct driver_info ax88772a_info = {
+	.description = "ASIX AX88772A USB 2.0 Ethernet",
+	.bind	= ax88772a_bind,
+	.unbind = ax88772a_unbind,
+	.status = ax88772a_status,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 32)
+	.stop	= ax88772b_stop,
+	.flags	= FLAG_ETHER | FLAG_FRAMING_AX | FLAG_AVOID_UNLINK_URBS,
+#else
+	.flags	= FLAG_ETHER | FLAG_FRAMING_AX,
+#endif
+	.rx_fixup = ax88772_rx_fixup,
+	.tx_fixup = ax88772_tx_fixup,
+	.reset	= ax88772b_reset,
+};
+
+static const struct driver_info ax88772b_info = {
+	.description = "ASIX AX88772B USB 2.0 Ethernet",
+	.bind	= ax88772b_bind,
+	.unbind = ax88772b_unbind,
+	.status = ax88772b_status,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 32)
+	.stop	= ax88772b_stop,
+	.flags	= FLAG_ETHER | FLAG_FRAMING_AX | FLAG_HW_IP_ALIGNMENT | FLAG_AVOID_UNLINK_URBS,
+#else
+	.flags	= FLAG_ETHER | FLAG_FRAMING_AX | FLAG_HW_IP_ALIGNMENT,
+#endif
+	.rx_fixup = ax88772b_rx_fixup,
+	.tx_fixup = ax88772b_tx_fixup,
+	.reset	= ax88772b_reset,
+};
+
+static const struct driver_info ax88772c_info = {
+	.description = "ASIX AX88772C USB 2.0 Ethernet",
+	.bind	= ax88772b_bind,
+	.unbind = ax88772b_unbind,
+	.status = ax88772c_status,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 32)
+	.stop	= ax88772b_stop,
+	.flags	= FLAG_ETHER | FLAG_FRAMING_AX | FLAG_HW_IP_ALIGNMENT | FLAG_AVOID_UNLINK_URBS,
+#else
+	.flags	= FLAG_ETHER | FLAG_FRAMING_AX | FLAG_HW_IP_ALIGNMENT,
+#endif
+	.rx_fixup = ax88772b_rx_fixup,
+	.tx_fixup = ax88772b_tx_fixup,
+	.reset	= ax88772b_reset,
+};
+
+static const struct usb_device_id products[] = {
+{
+	/* 88178 */
+	USB_DEVICE(0x0b95, 0x1780),
+	.driver_info =	(unsigned long) &ax88178_info,
+}, {
+	/* 88178 for billianton linksys */
+	USB_DEVICE(0x077b, 0x2226),
+	.driver_info =	(unsigned long) &ax88178_info,
+}, {
+	/* ABOCOM for linksys */
+	USB_DEVICE(0x1737, 0x0039),
+	.driver_info =	(unsigned long) &ax88178_info,
+}, {
+	/* ABOCOM  for pci */
+	USB_DEVICE(0x14ea, 0xab11),
+	.driver_info =	(unsigned long) &ax88178_info,
+}, {
+	/* Belkin */
+	USB_DEVICE(0x050d, 0x5055),
+	.driver_info =	(unsigned long) &belkin178_info,
+}, {
+	/* Linksys USB200M */
+	USB_DEVICE(0x077b, 0x2226),
+	.driver_info =	(unsigned long) &ax8817x_info,
+}, {
+	/* Netgear FA120 */
+	USB_DEVICE(0x0846, 0x1040),
+	.driver_info =  (unsigned long) &netgear_fa120_info,
+}, {
+	/* DLink DUB-E100 */
+	USB_DEVICE(0x2001, 0x1a00),
+	.driver_info =  (unsigned long) &dlink_dub_e100_info,
+}, {
+	/* DLink DUB-E100B */
+	USB_DEVICE(0x2001, 0x3c05),
+	.driver_info =  (unsigned long) &dlink_dub_e100b_info,
+}, {
+	/* DLink DUB-E100B */
+	USB_DEVICE(0x07d1, 0x3c05),
+	.driver_info =  (unsigned long) &dlink_dub_e100b_info,
+}, {
+	/* DLink DUB-E100 (AX88772B)*/
+	USB_DEVICE_VER(0x2001, 0x1a02, 0, 1),
+	.driver_info =  (unsigned long) &dlink_dub_e100_772b_info,
+}, {
+	/* DLink DUB-E100 (AX88772C)*/
+	USB_DEVICE_VER(0x2001, 0x1a02, 0, 2),
+	.driver_info =  (unsigned long) &dlink_dub_e100_772c_info,
+}, {
+	/* Intellinet, ST Lab USB Ethernet */
+	USB_DEVICE(0x0b95, 0x1720),
+	.driver_info =  (unsigned long) &ax8817x_info,
+}, {
+	/* Hawking UF200, TrendNet TU2-ET100 */
+	USB_DEVICE(0x07b8, 0x420a),
+	.driver_info =  (unsigned long) &hawking_uf200_info,
+}, {
+	/* Billionton Systems, USB2AR */
+	USB_DEVICE(0x08dd, 0x90ff),
+	.driver_info =  (unsigned long) &ax8817x_info,
+}, {
+	/* ATEN UC210T */
+	USB_DEVICE(0x0557, 0x2009),
+	.driver_info =  (unsigned long) &ax8817x_info,
+}, {
+	/* Buffalo LUA-U2-KTX */
+	USB_DEVICE(0x0411, 0x003d),
+	.driver_info =  (unsigned long) &ax8817x_info,
+}, {
+	/* Sitecom LN-029 "USB 2.0 10/100 Ethernet adapter" */
+	USB_DEVICE(0x6189, 0x182d),
+	.driver_info =  (unsigned long) &ax8817x_info,
+}, {
+	/* corega FEther USB2-TX */
+	USB_DEVICE(0x07aa, 0x0017),
+	.driver_info =  (unsigned long) &ax8817x_info,
+}, {
+	/* Surecom EP-1427X-2 */
+	USB_DEVICE(0x1189, 0x0893),
+	.driver_info = (unsigned long) &ax8817x_info,
+}, {
+	/* goodway corp usb gwusb2e */
+	USB_DEVICE(0x1631, 0x6200),
+	.driver_info = (unsigned long) &ax8817x_info,
+}, {
+	/* ASIX AX88772 10/100 */
+	USB_DEVICE(0x0b95, 0x7720),
+	.driver_info = (unsigned long) &ax88772_info,
+}, {
+	/* ASIX AX88772 10/100 */
+	USB_DEVICE(0x125E, 0x180D),
+	.driver_info = (unsigned long) &ax88772_info,
+}, {
+	/* ASIX AX88772A 10/100 */
+	USB_DEVICE(0x0b95, 0x772A),
+	.driver_info = (unsigned long) &ax88772a_info,
+}, {
+	/* ASIX AX88772A 10/100 */
+	USB_DEVICE(0x0db0, 0xA877),
+	.driver_info = (unsigned long) &ax88772a_info,
+}, {
+	/* ASIX AX88772A 10/100 */
+	USB_DEVICE(0x0421, 0x772A),
+	.driver_info = (unsigned long) &ax88772a_info,
+}, {
+	/* Linksys 200M */
+	 USB_DEVICE(0x13B1, 0x0018),
+	.driver_info = (unsigned long) &ax88772a_info,
+}, {
+	USB_DEVICE(0x05ac, 0x1402),
+	.driver_info = (unsigned long) &ax88772a_info,
+}, {
+	/* ASIX AX88772B 10/100 */
+	USB_DEVICE_VER(0x0b95, 0x772B, 0, 1),
+	.driver_info = (unsigned long) &ax88772b_info,
+}, {
+	/* Asus AX88772B 10/100 */
+	USB_DEVICE_VER(0x0b95, 0x7e2b, 0, 1),
+	.driver_info = (unsigned long) &ax88772b_info,
+}, {
+	/* Lenovo AX88772B 10/100 */
+	USB_DEVICE_VER(0x17ef, 0x7203, 0, 1),
+	.driver_info = (unsigned long) &ax88772b_info,
+},{
+	/* ASIX AX88772B ver.2 10/100 */
+	USB_DEVICE_VER(0x0b95, 0x772B, 0, 2),
+	.driver_info = (unsigned long) &ax88772c_info,
+},
+	{ },		/* END */
+};
+MODULE_DEVICE_TABLE(usb, products);
+
+static struct usb_driver asix_driver = {
+	/* .owner =	THIS_MODULE, */
+	.name =		"asix",
+	.id_table =	products,
+	.probe =	axusbnet_probe,
+	.suspend =	ax_suspend,
+	.resume =	ax_resume,
+	.disconnect =	axusbnet_disconnect,
+};
+
+static int __init asix_init(void)
+{
+	return usb_register(&asix_driver);
+}
+module_init(asix_init);
+
+static void __exit asix_exit(void)
+{
+	usb_deregister(&asix_driver);
+}
+module_exit(asix_exit);
+
+MODULE_AUTHOR("David Hollis");
+MODULE_DESCRIPTION("ASIX AX8817X based USB 2.0 Ethernet Devices");
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/usb/asix.h b/drivers/net/usb/asix.h
index 9a4171b..a0a59e8 100644
--- a/drivers/net/usb/asix.h
+++ b/drivers/net/usb/asix.h
@@ -1,255 +1,575 @@
+#ifndef	__LINUX_USBNET_ASIX_H
+#define	__LINUX_USBNET_ASIX_H
+
 /*
- * ASIX AX8817X based USB 2.0 Ethernet Devices
- * Copyright (C) 2003-2006 David Hollis <dhollis@davehollis.com>
- * Copyright (C) 2005 Phil Chang <pchang23@sbcglobal.net>
- * Copyright (C) 2006 James Painter <jamie.painter@iname.com>
- * Copyright (c) 2002-2003 TiVo Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ * Turn on this flag if the implementation of your USB host controller
+ * cannot handle non-double word aligned buffer.
+ * When turn on this flag, driver will fixup egress packet aligned on double
+ * word boundary before deliver to USB host controller. And will Disable the
+ * function "skb_reserve (skb, NET_IP_ALIGN)" to retain the buffer aligned on
+ * double word alignment for ingress packets.
  */
+#define AX_FORCE_BUFF_ALIGN		0
 
-#ifndef _ASIX_H
-#define _ASIX_H
+//#define RX_SKB_COPY
 
-// #define	DEBUG			// error path messages, extra info
-// #define	VERBOSE			// more; success messages
+#define AX_MONITOR_MODE			0x01
+#define AX_MONITOR_LINK			0x02
+#define AX_MONITOR_MAGIC		0x04
+#define AX_MONITOR_HSFS			0x10
 
-#include <linux/module.h>
-#include <linux/kmod.h>
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/ethtool.h>
-#include <linux/workqueue.h>
-#include <linux/mii.h>
-#include <linux/usb.h>
-#include <linux/crc32.h>
-#include <linux/usb/usbnet.h>
-#include <linux/slab.h>
-#include <linux/if_vlan.h>
+/* AX88172 Medium Status Register values */
+#define AX_MEDIUM_FULL_DUPLEX		0x02
+#define AX_MEDIUM_TX_ABORT_ALLOW	0x04
+#define AX_MEDIUM_FLOW_CONTROL_EN	0x10
+#define AX_MCAST_FILTER_SIZE		8
+#define AX_MAX_MCAST			64
 
-#define DRIVER_VERSION "22-Dec-2011"
-#define DRIVER_NAME "asix"
+#define AX_EEPROM_LEN			0x40
 
-/* ASIX AX8817X based USB 2.0 Ethernet Devices */
+#define AX_SWRESET_CLEAR		0x00
+#define AX_SWRESET_RR			0x01
+#define AX_SWRESET_RT			0x02
+#define AX_SWRESET_PRTE			0x04
+#define AX_SWRESET_PRL			0x08
+#define AX_SWRESET_BZ			0x10
+#define AX_SWRESET_IPRL			0x20
+#define AX_SWRESET_IPPD			0x40
+#define AX_SWRESET_IPOSC		0x0080
+#define AX_SWRESET_IPPSL_0		0x0100
+#define AX_SWRESET_IPPSL_1		0x0200
+#define AX_SWRESET_IPCOPS		0x0400
+#define AX_SWRESET_IPCOPSC		0x0800
+#define AX_SWRESET_AUTODETACH		0x1000
+#define AX_SWRESET_WOLLP		0x8000
+
+#define AX88772_IPG0_DEFAULT		0x15
+#define AX88772_IPG1_DEFAULT		0x0c
+#define AX88772_IPG2_DEFAULT		0x0E
+
+#define AX88772A_IPG0_DEFAULT		0x15
+#define AX88772A_IPG1_DEFAULT		0x16
+#define AX88772A_IPG2_DEFAULT		0x1A
+
+#define AX88772_MEDIUM_FULL_DUPLEX	0x0002
+#define AX88772_MEDIUM_RESERVED		0x0004
+#define AX88772_MEDIUM_RX_FC_ENABLE	0x0010
+#define AX88772_MEDIUM_TX_FC_ENABLE	0x0020
+#define AX88772_MEDIUM_PAUSE_FORMAT	0x0080
+#define AX88772_MEDIUM_RX_ENABLE	0x0100
+#define AX88772_MEDIUM_100MB		0x0200
+#define AX88772_MEDIUM_DEFAULT	\
+	(AX88772_MEDIUM_FULL_DUPLEX | AX88772_MEDIUM_RX_FC_ENABLE | \
+	 AX88772_MEDIUM_TX_FC_ENABLE | AX88772_MEDIUM_100MB | \
+	 AX88772_MEDIUM_RESERVED | AX88772_MEDIUM_RX_ENABLE)
 
 #define AX_CMD_SET_SW_MII		0x06
 #define AX_CMD_READ_MII_REG		0x07
 #define AX_CMD_WRITE_MII_REG		0x08
-#define AX_CMD_STATMNGSTS_REG		0x09
+#define AX_CMD_READ_STATMNGSTS_REG	0x09
+	#define AX_HOST_EN		0x01
+
 #define AX_CMD_SET_HW_MII		0x0a
 #define AX_CMD_READ_EEPROM		0x0b
 #define AX_CMD_WRITE_EEPROM		0x0c
-#define AX_CMD_WRITE_ENABLE		0x0d
-#define AX_CMD_WRITE_DISABLE		0x0e
-#define AX_CMD_READ_RX_CTL		0x0f
+#define AX_CMD_WRITE_EEPROM_EN		0x0d
+#define AX_CMD_WRITE_EEPROM_DIS		0x0e
 #define AX_CMD_WRITE_RX_CTL		0x10
 #define AX_CMD_READ_IPG012		0x11
 #define AX_CMD_WRITE_IPG0		0x12
 #define AX_CMD_WRITE_IPG1		0x13
-#define AX_CMD_READ_NODE_ID		0x13
-#define AX_CMD_WRITE_NODE_ID		0x14
 #define AX_CMD_WRITE_IPG2		0x14
 #define AX_CMD_WRITE_MULTI_FILTER	0x16
-#define AX88172_CMD_READ_NODE_ID	0x17
+#define AX_CMD_READ_NODE_ID		0x17
 #define AX_CMD_READ_PHY_ID		0x19
-#define AX_CMD_READ_MEDIUM_STATUS	0x1a
+#define AX_CMD_READ_MEDIUM_MODE		0x1a
 #define AX_CMD_WRITE_MEDIUM_MODE	0x1b
 #define AX_CMD_READ_MONITOR_MODE	0x1c
 #define AX_CMD_WRITE_MONITOR_MODE	0x1d
-#define AX_CMD_READ_GPIOS		0x1e
 #define AX_CMD_WRITE_GPIOS		0x1f
 #define AX_CMD_SW_RESET			0x20
 #define AX_CMD_SW_PHY_STATUS		0x21
 #define AX_CMD_SW_PHY_SELECT		0x22
-#define AX_QCTCTRL			0x2A
+	#define AX_PHYSEL_PSEL		(1 << 0)
+	#define AX_PHYSEL_ASEL		(1 << 1)
+	#define AX_PHYSEL_SSMII		(0 << 2)
+	#define AX_PHYSEL_SSRMII	(1 << 2)
+	#define AX_PHYSEL_SSRRMII	(3 << 2)
+	#define AX_PHYSEL_SSEN		(1 << 4)
+#define AX88772_CMD_READ_NODE_ID	0x13
+#define AX88772_CMD_WRITE_NODE_ID	0x14
+#define AX_CMD_READ_WKFARY		0x23
+#define AX_CMD_WRITE_WKFARY		0x24
+#define AX_CMD_READ_RXCOE_CTL		0x2b
+#define AX_CMD_WRITE_RXCOE_CTL		0x2c
+#define AX_CMD_READ_TXCOE_CTL		0x2d
+#define AX_CMD_WRITE_TXCOE_CTL		0x2e
+
+#define REG_LENGTH			2
+#define PHY_ID_MASK			0x1f
+
+#define AX_RXCOE_IPCE			0x0001
+#define AX_RXCOE_IPVE			0x0002
+#define AX_RXCOE_V6VE			0x0004
+#define AX_RXCOE_TCPE			0x0008
+#define AX_RXCOE_UDPE			0x0010
+#define AX_RXCOE_ICMP			0x0020
+#define AX_RXCOE_IGMP			0x0040
+#define AX_RXCOE_ICV6			0x0080
+#define AX_RXCOE_TCPV6			0x0100
+#define AX_RXCOE_UDPV6			0x0200
+#define AX_RXCOE_ICMV6			0x0400
+#define AX_RXCOE_IGMV6			0x0800
+#define AX_RXCOE_ICV6V6			0x1000
+#define AX_RXCOE_FOPC			0x8000
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 22)
+#define AX_RXCOE_DEF_CSUM		(AX_RXCOE_IPCE | AX_RXCOE_IPVE | \
+					 AX_RXCOE_V6VE | AX_RXCOE_TCPE | \
+					 AX_RXCOE_UDPE |  AX_RXCOE_ICV6 | \
+					 AX_RXCOE_TCPV6 | AX_RXCOE_UDPV6)
+#else
+#define AX_RXCOE_DEF_CSUM		(AX_RXCOE_IPCE | AX_RXCOE_IPVE | \
+					 AX_RXCOE_TCPE | AX_RXCOE_UDPE)
+#endif
+
+#define AX_RXCOE_64TE			0x0100
+#define AX_RXCOE_PPPOE			0x0200
+#define AX_RXCOE_RPCE			0x8000
+
+#define AX_TXCOE_IP			0x0001
+#define AX_TXCOE_TCP			0x0002
+#define AX_TXCOE_UDP			0x0004
+#define AX_TXCOE_ICMP			0x0008
+#define AX_TXCOE_IGMP			0x0010
+#define AX_TXCOE_ICV6			0x0020
+
+#define AX_TXCOE_TCPV6			0x0100
+#define AX_TXCOE_UDPV6			0x0200
+#define AX_TXCOE_ICMV6			0x0400
+#define AX_TXCOE_IGMV6			0x0800
+#define AX_TXCOE_ICV6V6			0x1000
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 22)
+#define AX_TXCOE_DEF_CSUM		(AX_TXCOE_TCP | AX_TXCOE_UDP | \
+					 AX_TXCOE_TCPV6 | AX_TXCOE_UDPV6)
+#else
+#define AX_TXCOE_DEF_CSUM		(AX_TXCOE_TCP | AX_TXCOE_UDP)
+#endif
+
+#define AX_TXCOE_64TE			0x0001
+#define AX_TXCOE_PPPE			0x0002
+
+#define AX88772B_MAX_BULKIN_2K		0
+#define AX88772B_MAX_BULKIN_4K		1
+#define AX88772B_MAX_BULKIN_6K		2
+#define AX88772B_MAX_BULKIN_8K		3
+#define AX88772B_MAX_BULKIN_16K		4
+#define AX88772B_MAX_BULKIN_20K		5
+#define AX88772B_MAX_BULKIN_24K		6
+#define AX88772B_MAX_BULKIN_32K		7
+struct {unsigned short size, byte_cnt, threshold; } AX88772B_BULKIN_SIZE[] = {
+	/* 2k */
+	{2048, 0x8000, 0x8001},
+	/* 4k */
+	{4096, 0x8100, 0x8147},
+	/* 6k */
+	{6144, 0x8200, 0x81EB},
+	/* 8k */
+	{8192, 0x8300, 0x83D7},
+	/* 16 */
+	{16384, 0x8400, 0x851E},
+	/* 20k */
+	{20480, 0x8500, 0x8666},
+	/* 24k */
+	{24576, 0x8600, 0x87AE},
+	/* 32k */
+	{32768, 0x8700, 0x8A3D},
+};
 
-#define AX_CHIPCODE_MASK		0x70
-#define AX_AX88772_CHIPCODE		0x00
-#define AX_AX88772A_CHIPCODE		0x10
-#define AX_AX88772B_CHIPCODE		0x20
-#define AX_HOST_EN			0x01
 
-#define AX_PHYSEL_PSEL			0x01
-#define AX_PHYSEL_SSMII			0
-#define AX_PHYSEL_SSEN			0x10
+#define AX_RX_CTL_RH1M			0x0100		/* Enable RX-Header mode 0 */
+#define AX_RX_CTL_RH2M			0x0200		/* Enable IP header in receive buffer aligned on 32-bit aligment */
+#define AX_RX_CTL_RH3M			0x0400		/* checksum value in rx header 3 */
+#define AX_RX_HEADER_DEFAULT		(AX_RX_CTL_RH1M | AX_RX_CTL_RH2M)
 
-#define AX_PHY_SELECT_MASK		(BIT(3) | BIT(2))
-#define AX_PHY_SELECT_INTERNAL		0
-#define AX_PHY_SELECT_EXTERNAL		BIT(2)
+#define AX_RX_CTL_MFB			0x0300		/* Maximum Frame size 16384bytes */
+#define AX_RX_CTL_START			0x0080		/* Ethernet MAC start */
+#define AX_RX_CTL_AP			0x0020		/* Accept physcial address from Multicast array */
+#define AX_RX_CTL_AM			0x0010
+#define AX_RX_CTL_AB			0x0008		/* Accetp Brocadcast frames*/
+#define AX_RX_CTL_SEP			0x0004		/* Save error packets */
+#define AX_RX_CTL_AMALL			0x0002		/* Accetp all multicast frames */
+#define AX_RX_CTL_PRO			0x0001		/* Promiscuous Mode */
+#define AX_RX_CTL_STOP			0x0000		/* Stop MAC */
 
 #define AX_MONITOR_MODE			0x01
 #define AX_MONITOR_LINK			0x02
 #define AX_MONITOR_MAGIC		0x04
 #define AX_MONITOR_HSFS			0x10
 
-/* AX88172 Medium Status Register values */
-#define AX88172_MEDIUM_FD		0x02
-#define AX88172_MEDIUM_TX		0x04
-#define AX88172_MEDIUM_FC		0x10
-#define AX88172_MEDIUM_DEFAULT \
-		( AX88172_MEDIUM_FD | AX88172_MEDIUM_TX | AX88172_MEDIUM_FC )
-
 #define AX_MCAST_FILTER_SIZE		8
 #define AX_MAX_MCAST			64
+#define AX_INTERRUPT_BUFSIZE		8
+
+#define AX_EEPROM_LEN			0x40
+#define AX_EEPROM_MAGIC			0xdeadbeef
+#define EEPROMMASK			0x7f
+
+/* GPIO REGISTER */
+#define AXGPIOS_GPO0EN			0X01 /* 1 << 0 */
+#define AXGPIOS_GPO0			0X02 /* 1 << 1 */
+#define AXGPIOS_GPO1EN			0X04 /*	1 << 2 */
+#define AXGPIOS_GPO1			0X08 /* 1 << 3 */
+#define AXGPIOS_GPO2EN			0X10 /* 1 << 4 */
+#define AXGPIOS_GPO2			0X20 /* 1 << 5 */
+#define AXGPIOS_RSE			0X80 /* 1 << 7 */
+
+/* TX-header format */
+#define AX_TX_HDR_CPHI			0x4000
+#define AX_TX_HDR_DICF			0x8000
+
+/* GMII register definitions */
+#define GMII_PHY_CONTROL		0x00	/* control reg */
+#define GMII_PHY_STATUS			0x01	/* status reg */
+#define GMII_PHY_OUI			0x02	/* most of the OUI bits */
+#define GMII_PHY_MODEL			0x03	/* model/rev bits, and rest of OUI */
+#define GMII_PHY_ANAR			0x04	/* AN advertisement reg */
+#define GMII_PHY_ANLPAR			0x05	/* AN Link Partner */
+#define GMII_PHY_ANER			0x06	/* AN expansion reg */
+#define GMII_PHY_1000BT_CONTROL		0x09	/* control reg for 1000BT */
+#define GMII_PHY_1000BT_STATUS		0x0A	/* status reg for 1000BT */
+
+/* Bit definitions: GMII Control */
+#define GMII_CONTROL_RESET		0x8000	/* reset bit in control reg */
+#define GMII_CONTROL_LOOPBACK		0x4000	/* loopback bit in control reg */
+#define GMII_CONTROL_10MB		0x0000	/* 10 Mbit */
+#define GMII_CONTROL_100MB		0x2000	/* 100Mbit */
+#define GMII_CONTROL_1000MB		0x0040	/* 1000Mbit */
+#define GMII_CONTROL_SPEED_BITS		0x2040	/* speed bit mask */
+#define GMII_CONTROL_ENABLE_AUTO	0x1000	/* autonegotiate enable */
+#define GMII_CONTROL_POWER_DOWN		0x0800
+#define GMII_CONTROL_ISOLATE		0x0400	/* islolate bit */
+#define GMII_CONTROL_START_AUTO		0x0200	/* restart autonegotiate */
+#define GMII_CONTROL_FULL_DUPLEX	0x0100
+
+/* Bit definitions: GMII Status */
+#define GMII_STATUS_100MB_MASK		0xE000	/* any of these indicate 100 Mbit */
+#define GMII_STATUS_10MB_MASK		0x1800	/* either of these indicate 10 Mbit */
+#define GMII_STATUS_AUTO_DONE		0x0020	/* auto negotiation complete */
+#define GMII_STATUS_AUTO		0x0008	/* auto negotiation is available */
+#define GMII_STATUS_LINK_UP		0x0004	/* link status bit */
+#define GMII_STATUS_EXTENDED		0x0001	/* extended regs exist */
+#define GMII_STATUS_100T4		0x8000	/* capable of 100BT4 */
+#define GMII_STATUS_100TXFD		0x4000	/* capable of 100BTX full duplex */
+#define GMII_STATUS_100TX		0x2000	/* capable of 100BTX */
+#define GMII_STATUS_10TFD		0x1000	/* capable of 10BT full duplex */
+#define GMII_STATUS_10T			0x0800	/* capable of 10BT */
+
+/* Bit definitions: Auto-Negotiation Advertisement */
+#define GMII_ANAR_ASYM_PAUSE		0x0800	/* support asymetric pause */
+#define GMII_ANAR_PAUSE			0x0400	/* support pause packets */
+#define GMII_ANAR_100T4			0x0200	/* support 100BT4 */
+#define GMII_ANAR_100TXFD		0x0100	/* support 100BTX full duplex */
+#define GMII_ANAR_100TX			0x0080	/* support 100BTX half duplex */
+#define GMII_ANAR_10TFD			0x0040	/* support 10BT full duplex */
+#define GMII_ANAR_10T			0x0020	/* support 10BT half duplex */
+#define GMII_SELECTOR_FIELD		0x001F	/* selector field. */
+
+/* Bit definitions: Auto-Negotiation Link Partner Ability */
+#define GMII_ANLPAR_100T4		0x0200	/* support 100BT4 */
+#define GMII_ANLPAR_100TXFD		0x0100	/* support 100BTX full duplex */
+#define GMII_ANLPAR_100TX		0x0080	/* support 100BTX half duplex */
+#define GMII_ANLPAR_10TFD		0x0040	/* support 10BT full duplex */
+#define GMII_ANLPAR_10T			0x0020	/* support 10BT half duplex */
+#define GMII_ANLPAR_PAUSE		0x0400	/* support pause packets */
+#define GMII_ANLPAR_ASYM_PAUSE		0x0800	/* support asymetric pause */
+#define GMII_ANLPAR_ACK			0x4000	/* means LCB was successfully rx'd */
+#define GMII_SELECTOR_8023		0x0001;
+
+/* Bit definitions: 1000BaseT AUX Control */
+#define GMII_1000_AUX_CTRL_MASTER_SLAVE		0x1000
+#define GMII_1000_AUX_CTRL_FD_CAPABLE		0x0200	/* full duplex capable */
+#define GMII_1000_AUX_CTRL_HD_CAPABLE		0x0100	/* half duplex capable */
+
+/* Bit definitions: 1000BaseT AUX Status */
+#define GMII_1000_AUX_STATUS_FD_CAPABLE		0x0800	/* full duplex capable */
+#define GMII_1000_AUX_STATUS_HD_CAPABLE		0x0400	/* half duplex capable */
+
+/* Cicada MII Registers */
+#define GMII_AUX_CTRL_STATUS			0x1C
+#define GMII_AUX_ANEG_CPLT			0x8000
+#define GMII_AUX_FDX				0x0020
+#define GMII_AUX_SPEED_1000			0x0010
+#define GMII_AUX_SPEED_100			0x0008
+
+#ifndef ADVERTISE_PAUSE_CAP
+#define ADVERTISE_PAUSE_CAP			0x0400
+#endif
+
+#ifndef MII_STAT1000
+#define MII_STAT1000				0x000A
+#endif
+
+#ifndef LPA_1000FULL
+#define LPA_1000FULL				0x0800
+#endif
+
+/* medium mode register */
+#define MEDIUM_GIGA_MODE			0x0001
+#define MEDIUM_FULL_DUPLEX_MODE			0x0002
+#define MEDIUM_TX_ABORT_MODE			0x0004
+#define MEDIUM_ENABLE_125MHZ			0x0008
+#define MEDIUM_ENABLE_RX_FLOWCTRL		0x0010
+#define MEDIUM_ENABLE_TX_FLOWCTRL		0x0020
+#define MEDIUM_ENABLE_JUMBO_FRAME		0x0040
+#define MEDIUM_CHECK_PAUSE_FRAME_MODE		0x0080
+#define MEDIUM_ENABLE_RECEIVE			0x0100
+#define MEDIUM_MII_100M_MODE			0x0200
+#define MEDIUM_ENABLE_JAM_PATTERN		0x0400
+#define MEDIUM_ENABLE_STOP_BACKPRESSURE		0x0800
+#define MEDIUM_ENABLE_SUPPER_MAC_SUPPORT	0x1000
+
+/* PHY mode */
+#define PHY_MODE_MARVELL		0
+#define PHY_MODE_CICADA_FAMILY		1
+#define PHY_MODE_CICADA_V1		1
+#define PHY_MODE_AGERE_FAMILY		2
+#define PHY_MODE_AGERE_V0		2
+#define PHY_MODE_CICADA_V2		5
+#define PHY_MODE_AGERE_V0_GMII		6
+#define PHY_MODE_CICADA_V2_ASIX		9
+#define PHY_MODE_VSC8601		10
+#define PHY_MODE_RTL8211CL		12
+#define PHY_MODE_RTL8211BN		13
+#define PHY_MODE_RTL8251CL		14
+#define PHY_MODE_ATTANSIC_V0		0x40
+#define PHY_MODE_ATTANSIC_FAMILY	0x40
+#define PHY_MODE_MAC_TO_MAC_GMII	0x7C
+
+/*  */
+#define LED_MODE_MARVELL		0
+#define LED_MODE_CAMEO			1
+
+#define MARVELL_LED_CTRL		0x18
+#define MARVELL_MANUAL_LED		0x19
+
+#define PHY_IDENTIFIER			0x0002
+#define PHY_AGERE_IDENTIFIER		0x0282
+#define PHY_CICADA_IDENTIFIER		0x000f
+#define PHY_MARVELL_IDENTIFIER		0x0141
+
+#define PHY_MARVELL_STATUS		0x001b
+#define MARVELL_STATUS_HWCFG		0x0004		/* SGMII without clock */
+
+#define PHY_MARVELL_CTRL		0x0014
+#define MARVELL_CTRL_RXDELAY		0x0080
+#define MARVELL_CTRL_TXDELAY		0x0002
+
+#define PHY_CICADA_EXTPAGE		0x001f
+#define CICADA_EXTPAGE_EN		0x0001
+#define CICADA_EXTPAGE_DIS		0x0000
+
+/* External ethernet phy */
+#define EXTPHY_ID_MASK_OUI(phyid1, phyid2) ((phyid1 << 6) | ((phyid2 & 0xFC00) >> 10))
+#define EXTPHY_ID_MASK_MODEL(phyid2) ((phyid2 & 0x3F0) >> 4) 
+
+#define EXTPHY_BROADCOM_OUI		0x2B8094
+#define EXTPHY_BCM89811_MODEL		0x02
+
+struct {unsigned short value, offset; } CICADA_FAMILY_HWINIT[] = {
+	{0x0001, 0x001f}, {0x1c25, 0x0017}, {0x2a30, 0x001f}, {0x234c, 0x0010},
+	{0x2a30, 0x001f}, {0x0212, 0x0008}, {0x52b5, 0x001f}, {0xa7fa, 0x0000},
+	{0x0012, 0x0002}, {0x3002, 0x0001}, {0x87fa, 0x0000}, {0x52b5, 0x001f},
+	{0xafac, 0x0000}, {0x000d, 0x0002}, {0x001c, 0x0001}, {0x8fac, 0x0000},
+	{0x2a30, 0x001f}, {0x0012, 0x0008}, {0x2a30, 0x001f}, {0x0400, 0x0014},
+	{0x2a30, 0x001f}, {0x0212, 0x0008}, {0x52b5, 0x001f}, {0xa760, 0x0000},
+	{0x0000, 0x0002}, {0xfaff, 0x0001}, {0x8760, 0x0000}, {0x52b5, 0x001f},
+	{0xa760, 0x0000}, {0x0000, 0x0002}, {0xfaff, 0x0001}, {0x8760, 0x0000},
+	{0x52b5, 0x001f}, {0xafae, 0x0000}, {0x0004, 0x0002}, {0x0671, 0x0001},
+	{0x8fae, 0x0000}, {0x2a30, 0x001f}, {0x0012, 0x0008}, {0x0000, 0x001f},
+};
 
-#define AX_SWRESET_CLEAR		0x00
-#define AX_SWRESET_RR			0x01
-#define AX_SWRESET_RT			0x02
-#define AX_SWRESET_PRTE			0x04
-#define AX_SWRESET_PRL			0x08
-#define AX_SWRESET_BZ			0x10
-#define AX_SWRESET_IPRL			0x20
-#define AX_SWRESET_IPPD			0x40
+struct {unsigned short value, offset; } CICADA_V2_HWINIT[] = {
+	{0x2a30, 0x001f}, {0x0212, 0x0008}, {0x52b5, 0x001f}, {0x000f, 0x0002},
+	{0x472a, 0x0001}, {0x8fa4, 0x0000}, {0x2a30, 0x001f}, {0x0212, 0x0008},
+	{0x0000, 0x001f},
+};
 
-#define AX88772_IPG0_DEFAULT		0x15
-#define AX88772_IPG1_DEFAULT		0x0c
-#define AX88772_IPG2_DEFAULT		0x12
-
-/* AX88772 & AX88178 Medium Mode Register */
-#define AX_MEDIUM_PF		0x0080
-#define AX_MEDIUM_JFE		0x0040
-#define AX_MEDIUM_TFC		0x0020
-#define AX_MEDIUM_RFC		0x0010
-#define AX_MEDIUM_ENCK		0x0008
-#define AX_MEDIUM_AC		0x0004
-#define AX_MEDIUM_FD		0x0002
-#define AX_MEDIUM_GM		0x0001
-#define AX_MEDIUM_SM		0x1000
-#define AX_MEDIUM_SBP		0x0800
-#define AX_MEDIUM_PS		0x0200
-#define AX_MEDIUM_RE		0x0100
-
-#define AX88178_MEDIUM_DEFAULT	\
-	(AX_MEDIUM_PS | AX_MEDIUM_FD | AX_MEDIUM_AC | \
-	 AX_MEDIUM_RFC | AX_MEDIUM_TFC | AX_MEDIUM_JFE | \
-	 AX_MEDIUM_RE)
+struct {unsigned short value, offset; } CICADA_V2_ASIX_HWINIT[] = {
+	{0x2a30, 0x001f}, {0x0212, 0x0008}, {0x52b5, 0x001f}, {0x0012, 0x0002},
+	{0x3002, 0x0001}, {0x87fa, 0x0000}, {0x52b5, 0x001f}, {0x000f, 0x0002},
+	{0x472a, 0x0001}, {0x8fa4, 0x0000}, {0x2a30, 0x001f}, {0x0212, 0x0008},
+	{0x0000, 0x001f},
+};
 
-#define AX88772_MEDIUM_DEFAULT	\
-	(AX_MEDIUM_FD | AX_MEDIUM_RFC | \
-	 AX_MEDIUM_TFC | AX_MEDIUM_PS | \
-	 AX_MEDIUM_AC | AX_MEDIUM_RE)
-
-/* AX88772 & AX88178 RX_CTL values */
-#define AX_RX_CTL_SO		0x0080
-#define AX_RX_CTL_AP		0x0020
-#define AX_RX_CTL_AM		0x0010
-#define AX_RX_CTL_AB		0x0008
-#define AX_RX_CTL_SEP		0x0004
-#define AX_RX_CTL_AMALL		0x0002
-#define AX_RX_CTL_PRO		0x0001
-#define AX_RX_CTL_MFB_2048	0x0000
-#define AX_RX_CTL_MFB_4096	0x0100
-#define AX_RX_CTL_MFB_8192	0x0200
-#define AX_RX_CTL_MFB_16384	0x0300
-
-#define AX_DEFAULT_RX_CTL	(AX_RX_CTL_SO | AX_RX_CTL_AB)
-
-/* GPIO 0 .. 2 toggles */
-#define AX_GPIO_GPO0EN		0x01	/* GPIO0 Output enable */
-#define AX_GPIO_GPO_0		0x02	/* GPIO0 Output value */
-#define AX_GPIO_GPO1EN		0x04	/* GPIO1 Output enable */
-#define AX_GPIO_GPO_1		0x08	/* GPIO1 Output value */
-#define AX_GPIO_GPO2EN		0x10	/* GPIO2 Output enable */
-#define AX_GPIO_GPO_2		0x20	/* GPIO2 Output value */
-#define AX_GPIO_RESERVED	0x40	/* Reserved */
-#define AX_GPIO_RSE		0x80	/* Reload serial EEPROM */
-
-#define AX_EEPROM_MAGIC		0xdeadbeef
-#define AX_EEPROM_LEN		0x200
+struct {unsigned short value, offset; } AGERE_FAMILY_HWINIT[] = {
+	{0x0800, 0x0000}, {0x0007, 0x0012}, {0x8805, 0x0010}, {0xb03e, 0x0011},
+	{0x8808, 0x0010}, {0xe110, 0x0011}, {0x8806, 0x0010}, {0xb03e, 0x0011},
+	{0x8807, 0x0010}, {0xff00, 0x0011}, {0x880e, 0x0010}, {0xb4d3, 0x0011},
+	{0x880f, 0x0010}, {0xb4d3, 0x0011}, {0x8810, 0x0010}, {0xb4d3, 0x0011},
+	{0x8817, 0x0010}, {0x1c00, 0x0011}, {0x300d, 0x0010}, {0x0001, 0x0011},
+	{0x0002, 0x0012},
+};
 
-/* This structure cannot exceed sizeof(unsigned long [5]) AKA 20 bytes */
-struct asix_data {
-	u8 multi_filter[AX_MCAST_FILTER_SIZE];
-	u8 mac_addr[ETH_ALEN];
-	u8 phymode;
-	u8 ledmode;
-	u8 res;
+struct ax88178_data {
+	u16	EepromData;
+	u16	MediaLink;
+	int	UseGpio0;
+	int	UseRgmii;
+	u8	PhyMode;
+	u8	LedMode;
+	u8	BuffaloOld;
 };
 
-struct asix_rx_fixup_info {
-	struct sk_buff *ax_skb;
-	u32 header;
-	u16 remaining;
-	bool split_head;
+enum watchdog_state {
+	AX_NOP = 0,
+	CHK_LINK,			/* Routine A */
+	CHK_CABLE_EXIST,		/* Called by A */
+	CHK_CABLE_EXIST_AGAIN,		/* Routine B */
+	PHY_POWER_UP,			/* Called by B */
+	PHY_POWER_UP_BH,
+	PHY_POWER_DOWN,
+	CHK_CABLE_STATUS,		/* Routine C */
+	WAIT_AUTONEG_COMPLETE,
+	AX_SET_RX_CFG,
+	AX_CHK_AUTODETACH,
 };
 
-struct asix_common_private {
-	void (*resume)(struct usbnet *dev);
-	void (*suspend)(struct usbnet *dev);
+struct ax88772b_data {
+	struct usbnet *dev;
+	struct workqueue_struct *ax_work;
+	struct work_struct check_link;
+	unsigned long time_to_chk;
+	u16 psc;
+	u8 pw_enabled;
+	u8 Event;
+	u8 checksum;
+	u8 PhySelect:1;
+	u8 OperationMode:1;
 	u16 presvd_phy_advertise;
 	u16 presvd_phy_bmcr;
-	struct asix_rx_fixup_info rx_fixup_info;
-};
-
-extern const struct driver_info ax88172a_info;
-
-/* ASIX specific flags */
-#define FLAG_EEPROM_MAC		(1UL << 0)  /* init device MAC from eeprom */
-
-int asix_read_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,
-		  u16 size, void *data, int in_pm);
-
-int asix_write_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,
-		   u16 size, void *data, int in_pm);
-
-void asix_write_cmd_async(struct usbnet *dev, u8 cmd, u16 value,
-			  u16 index, u16 size, void *data);
-
-int asix_rx_fixup_internal(struct usbnet *dev, struct sk_buff *skb,
-			   struct asix_rx_fixup_info *rx);
-int asix_rx_fixup_common(struct usbnet *dev, struct sk_buff *skb);
-void asix_rx_fixup_common_free(struct asix_common_private *dp);
-
-struct sk_buff *asix_tx_fixup(struct usbnet *dev, struct sk_buff *skb,
-			      gfp_t flags);
-
-int asix_set_sw_mii(struct usbnet *dev, int in_pm);
-int asix_set_hw_mii(struct usbnet *dev, int in_pm);
 
-int asix_read_phy_addr(struct usbnet *dev, int internal);
-int asix_get_phy_addr(struct usbnet *dev);
-
-int asix_sw_reset(struct usbnet *dev, u8 flags, int in_pm);
-
-u16 asix_read_rx_ctl(struct usbnet *dev, int in_pm);
-int asix_write_rx_ctl(struct usbnet *dev, u16 mode, int in_pm);
-
-u16 asix_read_medium_status(struct usbnet *dev, int in_pm);
-int asix_write_medium_mode(struct usbnet *dev, u16 mode, int in_pm);
-
-int asix_write_gpio(struct usbnet *dev, u16 value, int sleep, int in_pm);
-
-void asix_set_multicast(struct net_device *net);
-
-int asix_mdio_read(struct net_device *netdev, int phy_id, int loc);
-void asix_mdio_write(struct net_device *netdev, int phy_id, int loc, int val);
+	u32 ext_phy_oui;
+	u8  ext_phy_model;
+};
 
-int asix_mdio_read_nopm(struct net_device *netdev, int phy_id, int loc);
-void asix_mdio_write_nopm(struct net_device *netdev, int phy_id, int loc,
-			  int val);
+/* define for MAC or PHY mode */
+#define OPERATION_MAC_MODE			0
+#define OPERATION_PHY_MODE			1
+
+struct ax88772a_data {
+	struct usbnet *dev;
+	struct workqueue_struct *ax_work;
+	struct work_struct check_link;
+	unsigned long autoneg_start;
+#define AX88772B_WATCHDOG	(6 * HZ)
+	u8 Event;
+	u8 TickToExpire;
+	u8 DlyIndex;
+	u8 DlySel;
+	u16 EepromData;
+	u16 presvd_phy_advertise;
+	u16 presvd_phy_bmcr;
+};
 
-void asix_get_wol(struct net_device *net, struct ethtool_wolinfo *wolinfo);
-int asix_set_wol(struct net_device *net, struct ethtool_wolinfo *wolinfo);
+struct ax88772_data {
+	struct usbnet *dev;
+	struct workqueue_struct *ax_work;
+	struct work_struct check_link;
+	unsigned long autoneg_start;
+	u8 Event;
+	u8 TickToExpire;
+	u16 presvd_phy_advertise;
+	u16 presvd_phy_bmcr;
+};
 
-int asix_get_eeprom_len(struct net_device *net);
-int asix_get_eeprom(struct net_device *net, struct ethtool_eeprom *eeprom,
-		    u8 *data);
-int asix_set_eeprom(struct net_device *net, struct ethtool_eeprom *eeprom,
-		    u8 *data);
+#define AX_RX_CHECKSUM		1
+#define AX_TX_CHECKSUM		2
 
-void asix_get_drvinfo(struct net_device *net, struct ethtool_drvinfo *info);
+/* This structure cannot exceed sizeof(unsigned long [5]) AKA 20 bytes */
+struct ax8817x_data {
+	u8 multi_filter[AX_MCAST_FILTER_SIZE];
+	int (*resume) (struct usb_interface *intf);
+	int (*suspend) (struct usb_interface *intf,
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 10)
+					pm_message_t message);
+#else
+					u32 message);
+#endif
+};
 
-int asix_set_mac_address(struct net_device *net, void *p);
+struct ax88172_int_data {
+	u16 res1;
+#define AX_INT_PPLS_LINK		(1 << 0)
+#define AX_INT_SPLS_LINK		(1 << 1)
+#define AX_INT_CABOFF_UNPLUG		(1 << 7)
+	u8 link;
+	u16 res2;
+	u8 status;
+	u16 res3;
+} __attribute__ ((packed));
+
+#define AX_RXHDR_L4_ERR		(1 << 8)
+#define AX_RXHDR_L3_ERR		(1 << 9)
+
+#define AX_RXHDR_L4_TYPE_UDP		1
+#define AX_RXHDR_L4_TYPE_ICMP		2
+#define AX_RXHDR_L4_TYPE_IGMP		3
+#define AX_RXHDR_L4_TYPE_TCP		4
+#define AX_RXHDR_L4_TYPE_TCMPV6	5
+#define AX_RXHDR_L4_TYPE_MASK		7
+
+#define AX_RXHDR_L3_TYPE_IP		1
+#define AX_RXHDR_L3_TYPE_IPV6		2
+
+struct ax88772b_rx_header {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+	u16	len:11,
+		res1:1,
+		crc:1,
+		mii:1,
+		runt:1,
+		mc_bc:1;
+
+	u16	len_bar:11,
+		res2:5;
+
+	u8	vlan_ind:3,
+		vlan_tag_striped:1,
+		pri:3,
+		res3:1;
+
+	u8	l4_csum_err:1,
+		l3_csum_err:1,
+		l4_type:3,
+		l3_type:2,
+		ce:1;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+	u16	mc_bc:1,
+		runt:1,
+		mii:1,
+		crc:1,
+		res1:1,
+		len:11;
+
+	u16	res2:5,
+		len_bar:11;
+
+	u8	res3:1,
+		pri:3,
+		vlan_tag_striped:1,
+		vlan_ind:3;
+
+	u8	ce:1,
+		l3_type:2,
+		l4_type:3,
+		l3_csum_err:1,
+		l4_csum_err:1;
+#else
+#error	"Please fix <asm/byteorder.h>"
+#endif
+
+} __attribute__ ((packed));
+
+
+#endif /* __LINUX_USBNET_ASIX_H */
 
-#endif /* _ASIX_H */
diff --git a/drivers/net/usb/asix_common.c b/drivers/net/usb/asix_common.c
deleted file mode 100644
index 023b8d0..00000000
--- a/drivers/net/usb/asix_common.c
+++ /dev/null
@@ -1,776 +0,0 @@
-/*
- * ASIX AX8817X based USB 2.0 Ethernet Devices
- * Copyright (C) 2003-2006 David Hollis <dhollis@davehollis.com>
- * Copyright (C) 2005 Phil Chang <pchang23@sbcglobal.net>
- * Copyright (C) 2006 James Painter <jamie.painter@iname.com>
- * Copyright (c) 2002-2003 TiVo Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, see <http://www.gnu.org/licenses/>.
- */
-
-#include "asix.h"
-
-int asix_read_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,
-		  u16 size, void *data, int in_pm)
-{
-	int ret;
-	int (*fn)(struct usbnet *, u8, u8, u16, u16, void *, u16);
-
-	BUG_ON(!dev);
-
-	if (!in_pm)
-		fn = usbnet_read_cmd;
-	else
-		fn = usbnet_read_cmd_nopm;
-
-	ret = fn(dev, cmd, USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-		 value, index, data, size);
-
-	if (unlikely(ret < 0))
-		netdev_warn(dev->net, "Failed to read reg index 0x%04x: %d\n",
-			    index, ret);
-
-	return ret;
-}
-
-int asix_write_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,
-		   u16 size, void *data, int in_pm)
-{
-	int ret;
-	int (*fn)(struct usbnet *, u8, u8, u16, u16, const void *, u16);
-
-	BUG_ON(!dev);
-
-	if (!in_pm)
-		fn = usbnet_write_cmd;
-	else
-		fn = usbnet_write_cmd_nopm;
-
-	ret = fn(dev, cmd, USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-		 value, index, data, size);
-
-	if (unlikely(ret < 0))
-		netdev_warn(dev->net, "Failed to write reg index 0x%04x: %d\n",
-			    index, ret);
-
-	return ret;
-}
-
-void asix_write_cmd_async(struct usbnet *dev, u8 cmd, u16 value, u16 index,
-			  u16 size, void *data)
-{
-	usbnet_write_cmd_async(dev, cmd,
-			       USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-			       value, index, data, size);
-}
-
-static void reset_asix_rx_fixup_info(struct asix_rx_fixup_info *rx)
-{
-	/* Reset the variables that have a lifetime outside of
-	 * asix_rx_fixup_internal() so that future processing starts from a
-	 * known set of initial conditions.
-	 */
-
-	if (rx->ax_skb) {
-		/* Discard any incomplete Ethernet frame in the netdev buffer */
-		kfree_skb(rx->ax_skb);
-		rx->ax_skb = NULL;
-	}
-
-	/* Assume the Data header 32-bit word is at the start of the current
-	 * or next URB socket buffer so reset all the state variables.
-	 */
-	rx->remaining = 0;
-	rx->split_head = false;
-	rx->header = 0;
-}
-
-int asix_rx_fixup_internal(struct usbnet *dev, struct sk_buff *skb,
-			   struct asix_rx_fixup_info *rx)
-{
-	int offset = 0;
-	u16 size;
-
-	/* When an Ethernet frame spans multiple URB socket buffers,
-	 * do a sanity test for the Data header synchronisation.
-	 * Attempt to detect the situation of the previous socket buffer having
-	 * been truncated or a socket buffer was missing. These situations
-	 * cause a discontinuity in the data stream and therefore need to avoid
-	 * appending bad data to the end of the current netdev socket buffer.
-	 * Also avoid unnecessarily discarding a good current netdev socket
-	 * buffer.
-	 */
-	if (rx->remaining && (rx->remaining + sizeof(u32) <= skb->len)) {
-		offset = ((rx->remaining + 1) & 0xfffe);
-		rx->header = get_unaligned_le32(skb->data + offset);
-		offset = 0;
-
-		size = (u16)(rx->header & 0x7ff);
-		if (size != ((~rx->header >> 16) & 0x7ff)) {
-			netdev_err(dev->net, "asix_rx_fixup() Data Header synchronisation was lost, remaining %d\n",
-				   rx->remaining);
-			reset_asix_rx_fixup_info(rx);
-		}
-	}
-
-	while (offset + sizeof(u16) <= skb->len) {
-		u16 copy_length;
-
-		if (!rx->remaining) {
-			if (skb->len - offset == sizeof(u16)) {
-				rx->header = get_unaligned_le16(
-						skb->data + offset);
-				rx->split_head = true;
-				offset += sizeof(u16);
-				break;
-			}
-
-			if (rx->split_head == true) {
-				rx->header |= (get_unaligned_le16(
-						skb->data + offset) << 16);
-				rx->split_head = false;
-				offset += sizeof(u16);
-			} else {
-				rx->header = get_unaligned_le32(skb->data +
-								offset);
-				offset += sizeof(u32);
-			}
-
-			/* take frame length from Data header 32-bit word */
-			size = (u16)(rx->header & 0x7ff);
-			if (size != ((~rx->header >> 16) & 0x7ff)) {
-				netdev_err(dev->net, "asix_rx_fixup() Bad Header Length 0x%x, offset %d\n",
-					   rx->header, offset);
-				reset_asix_rx_fixup_info(rx);
-				return 0;
-			}
-			if (size > dev->net->mtu + ETH_HLEN + VLAN_HLEN) {
-				netdev_dbg(dev->net, "asix_rx_fixup() Bad RX Length %d\n",
-					   size);
-				reset_asix_rx_fixup_info(rx);
-				return 0;
-			}
-
-			/* Sometimes may fail to get a netdev socket buffer but
-			 * continue to process the URB socket buffer so that
-			 * synchronisation of the Ethernet frame Data header
-			 * word is maintained.
-			 */
-			rx->ax_skb = netdev_alloc_skb_ip_align(dev->net, size);
-
-			rx->remaining = size;
-		}
-
-		if (rx->remaining > skb->len - offset) {
-			copy_length = skb->len - offset;
-			rx->remaining -= copy_length;
-		} else {
-			copy_length = rx->remaining;
-			rx->remaining = 0;
-		}
-
-		if (rx->ax_skb) {
-			skb_put_data(rx->ax_skb, skb->data + offset,
-				     copy_length);
-			if (!rx->remaining) {
-				usbnet_skb_return(dev, rx->ax_skb);
-				rx->ax_skb = NULL;
-			}
-		}
-
-		offset += (copy_length + 1) & 0xfffe;
-	}
-
-	if (skb->len != offset) {
-		netdev_err(dev->net, "asix_rx_fixup() Bad SKB Length %d, %d\n",
-			   skb->len, offset);
-		reset_asix_rx_fixup_info(rx);
-		return 0;
-	}
-
-	return 1;
-}
-
-int asix_rx_fixup_common(struct usbnet *dev, struct sk_buff *skb)
-{
-	struct asix_common_private *dp = dev->driver_priv;
-	struct asix_rx_fixup_info *rx = &dp->rx_fixup_info;
-
-	return asix_rx_fixup_internal(dev, skb, rx);
-}
-
-void asix_rx_fixup_common_free(struct asix_common_private *dp)
-{
-	struct asix_rx_fixup_info *rx;
-
-	if (!dp)
-		return;
-
-	rx = &dp->rx_fixup_info;
-
-	if (rx->ax_skb) {
-		kfree_skb(rx->ax_skb);
-		rx->ax_skb = NULL;
-	}
-}
-
-struct sk_buff *asix_tx_fixup(struct usbnet *dev, struct sk_buff *skb,
-			      gfp_t flags)
-{
-	int padlen;
-	int headroom = skb_headroom(skb);
-	int tailroom = skb_tailroom(skb);
-	u32 packet_len;
-	u32 padbytes = 0xffff0000;
-
-	padlen = ((skb->len + 4) & (dev->maxpacket - 1)) ? 0 : 4;
-
-	/* We need to push 4 bytes in front of frame (packet_len)
-	 * and maybe add 4 bytes after the end (if padlen is 4)
-	 *
-	 * Avoid skb_copy_expand() expensive call, using following rules :
-	 * - We are allowed to push 4 bytes in headroom if skb_header_cloned()
-	 *   is false (and if we have 4 bytes of headroom)
-	 * - We are allowed to put 4 bytes at tail if skb_cloned()
-	 *   is false (and if we have 4 bytes of tailroom)
-	 *
-	 * TCP packets for example are cloned, but __skb_header_release()
-	 * was called in tcp stack, allowing us to use headroom for our needs.
-	 */
-	if (!skb_header_cloned(skb) &&
-	    !(padlen && skb_cloned(skb)) &&
-	    headroom + tailroom >= 4 + padlen) {
-		/* following should not happen, but better be safe */
-		if (headroom < 4 ||
-		    tailroom < padlen) {
-			skb->data = memmove(skb->head + 4, skb->data, skb->len);
-			skb_set_tail_pointer(skb, skb->len);
-		}
-	} else {
-		struct sk_buff *skb2;
-
-		skb2 = skb_copy_expand(skb, 4, padlen, flags);
-		dev_kfree_skb_any(skb);
-		skb = skb2;
-		if (!skb)
-			return NULL;
-	}
-
-	packet_len = ((skb->len ^ 0x0000ffff) << 16) + skb->len;
-	skb_push(skb, 4);
-	cpu_to_le32s(&packet_len);
-	skb_copy_to_linear_data(skb, &packet_len, sizeof(packet_len));
-
-	if (padlen) {
-		cpu_to_le32s(&padbytes);
-		memcpy(skb_tail_pointer(skb), &padbytes, sizeof(padbytes));
-		skb_put(skb, sizeof(padbytes));
-	}
-
-	usbnet_set_skb_tx_stats(skb, 1, 0);
-	return skb;
-}
-
-int asix_set_sw_mii(struct usbnet *dev, int in_pm)
-{
-	int ret;
-	ret = asix_write_cmd(dev, AX_CMD_SET_SW_MII, 0x0000, 0, 0, NULL, in_pm);
-
-	if (ret < 0)
-		netdev_err(dev->net, "Failed to enable software MII access\n");
-	return ret;
-}
-
-int asix_set_hw_mii(struct usbnet *dev, int in_pm)
-{
-	int ret;
-	ret = asix_write_cmd(dev, AX_CMD_SET_HW_MII, 0x0000, 0, 0, NULL, in_pm);
-	if (ret < 0)
-		netdev_err(dev->net, "Failed to enable hardware MII access\n");
-	return ret;
-}
-
-int asix_read_phy_addr(struct usbnet *dev, int internal)
-{
-	int offset = (internal ? 1 : 0);
-	u8 buf[2];
-	int ret = asix_read_cmd(dev, AX_CMD_READ_PHY_ID, 0, 0, 2, buf, 0);
-
-	netdev_dbg(dev->net, "asix_get_phy_addr()\n");
-
-	if (ret < 0) {
-		netdev_err(dev->net, "Error reading PHYID register: %02x\n", ret);
-		goto out;
-	}
-	netdev_dbg(dev->net, "asix_get_phy_addr() returning 0x%04x\n",
-		   *((__le16 *)buf));
-	ret = buf[offset];
-
-out:
-	return ret;
-}
-
-int asix_get_phy_addr(struct usbnet *dev)
-{
-	/* return the address of the internal phy */
-	return asix_read_phy_addr(dev, 1);
-}
-
-
-int asix_sw_reset(struct usbnet *dev, u8 flags, int in_pm)
-{
-	int ret;
-
-	ret = asix_write_cmd(dev, AX_CMD_SW_RESET, flags, 0, 0, NULL, in_pm);
-	if (ret < 0)
-		netdev_err(dev->net, "Failed to send software reset: %02x\n", ret);
-
-	return ret;
-}
-
-u16 asix_read_rx_ctl(struct usbnet *dev, int in_pm)
-{
-	__le16 v;
-	int ret = asix_read_cmd(dev, AX_CMD_READ_RX_CTL, 0, 0, 2, &v, in_pm);
-
-	if (ret < 0) {
-		netdev_err(dev->net, "Error reading RX_CTL register: %02x\n", ret);
-		goto out;
-	}
-	ret = le16_to_cpu(v);
-out:
-	return ret;
-}
-
-int asix_write_rx_ctl(struct usbnet *dev, u16 mode, int in_pm)
-{
-	int ret;
-
-	netdev_dbg(dev->net, "asix_write_rx_ctl() - mode = 0x%04x\n", mode);
-	ret = asix_write_cmd(dev, AX_CMD_WRITE_RX_CTL, mode, 0, 0, NULL, in_pm);
-	if (ret < 0)
-		netdev_err(dev->net, "Failed to write RX_CTL mode to 0x%04x: %02x\n",
-			   mode, ret);
-
-	return ret;
-}
-
-u16 asix_read_medium_status(struct usbnet *dev, int in_pm)
-{
-	__le16 v;
-	int ret = asix_read_cmd(dev, AX_CMD_READ_MEDIUM_STATUS,
-				0, 0, 2, &v, in_pm);
-
-	if (ret < 0) {
-		netdev_err(dev->net, "Error reading Medium Status register: %02x\n",
-			   ret);
-		return ret;	/* TODO: callers not checking for error ret */
-	}
-
-	return le16_to_cpu(v);
-
-}
-
-int asix_write_medium_mode(struct usbnet *dev, u16 mode, int in_pm)
-{
-	int ret;
-
-	netdev_dbg(dev->net, "asix_write_medium_mode() - mode = 0x%04x\n", mode);
-	ret = asix_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE,
-			     mode, 0, 0, NULL, in_pm);
-	if (ret < 0)
-		netdev_err(dev->net, "Failed to write Medium Mode mode to 0x%04x: %02x\n",
-			   mode, ret);
-
-	return ret;
-}
-
-int asix_write_gpio(struct usbnet *dev, u16 value, int sleep, int in_pm)
-{
-	int ret;
-
-	netdev_dbg(dev->net, "asix_write_gpio() - value = 0x%04x\n", value);
-	ret = asix_write_cmd(dev, AX_CMD_WRITE_GPIOS, value, 0, 0, NULL, in_pm);
-	if (ret < 0)
-		netdev_err(dev->net, "Failed to write GPIO value 0x%04x: %02x\n",
-			   value, ret);
-
-	if (sleep)
-		msleep(sleep);
-
-	return ret;
-}
-
-/*
- * AX88772 & AX88178 have a 16-bit RX_CTL value
- */
-void asix_set_multicast(struct net_device *net)
-{
-	struct usbnet *dev = netdev_priv(net);
-	struct asix_data *data = (struct asix_data *)&dev->data;
-	u16 rx_ctl = AX_DEFAULT_RX_CTL;
-
-	if (net->flags & IFF_PROMISC) {
-		rx_ctl |= AX_RX_CTL_PRO;
-	} else if (net->flags & IFF_ALLMULTI ||
-		   netdev_mc_count(net) > AX_MAX_MCAST) {
-		rx_ctl |= AX_RX_CTL_AMALL;
-	} else if (netdev_mc_empty(net)) {
-		/* just broadcast and directed */
-	} else {
-		/* We use the 20 byte dev->data
-		 * for our 8 byte filter buffer
-		 * to avoid allocating memory that
-		 * is tricky to free later */
-		struct netdev_hw_addr *ha;
-		u32 crc_bits;
-
-		memset(data->multi_filter, 0, AX_MCAST_FILTER_SIZE);
-
-		/* Build the multicast hash filter. */
-		netdev_for_each_mc_addr(ha, net) {
-			crc_bits = ether_crc(ETH_ALEN, ha->addr) >> 26;
-			data->multi_filter[crc_bits >> 3] |=
-			    1 << (crc_bits & 7);
-		}
-
-		asix_write_cmd_async(dev, AX_CMD_WRITE_MULTI_FILTER, 0, 0,
-				   AX_MCAST_FILTER_SIZE, data->multi_filter);
-
-		rx_ctl |= AX_RX_CTL_AM;
-	}
-
-	asix_write_cmd_async(dev, AX_CMD_WRITE_RX_CTL, rx_ctl, 0, 0, NULL);
-}
-
-int asix_mdio_read(struct net_device *netdev, int phy_id, int loc)
-{
-	struct usbnet *dev = netdev_priv(netdev);
-	__le16 res;
-	u8 smsr;
-	int i = 0;
-	int ret;
-
-	mutex_lock(&dev->phy_mutex);
-	do {
-		ret = asix_set_sw_mii(dev, 0);
-		if (ret == -ENODEV || ret == -ETIMEDOUT)
-			break;
-		usleep_range(1000, 1100);
-		ret = asix_read_cmd(dev, AX_CMD_STATMNGSTS_REG,
-				    0, 0, 1, &smsr, 0);
-	} while (!(smsr & AX_HOST_EN) && (i++ < 30) && (ret != -ENODEV));
-	if (ret == -ENODEV || ret == -ETIMEDOUT) {
-		mutex_unlock(&dev->phy_mutex);
-		return ret;
-	}
-
-	asix_read_cmd(dev, AX_CMD_READ_MII_REG, phy_id,
-				(__u16)loc, 2, &res, 0);
-	asix_set_hw_mii(dev, 0);
-	mutex_unlock(&dev->phy_mutex);
-
-	netdev_dbg(dev->net, "asix_mdio_read() phy_id=0x%02x, loc=0x%02x, returns=0x%04x\n",
-			phy_id, loc, le16_to_cpu(res));
-
-	return le16_to_cpu(res);
-}
-
-void asix_mdio_write(struct net_device *netdev, int phy_id, int loc, int val)
-{
-	struct usbnet *dev = netdev_priv(netdev);
-	__le16 res = cpu_to_le16(val);
-	u8 smsr;
-	int i = 0;
-	int ret;
-
-	netdev_dbg(dev->net, "asix_mdio_write() phy_id=0x%02x, loc=0x%02x, val=0x%04x\n",
-			phy_id, loc, val);
-
-	mutex_lock(&dev->phy_mutex);
-	do {
-		ret = asix_set_sw_mii(dev, 0);
-		if (ret == -ENODEV)
-			break;
-		usleep_range(1000, 1100);
-		ret = asix_read_cmd(dev, AX_CMD_STATMNGSTS_REG,
-				    0, 0, 1, &smsr, 0);
-	} while (!(smsr & AX_HOST_EN) && (i++ < 30) && (ret != -ENODEV));
-	if (ret == -ENODEV) {
-		mutex_unlock(&dev->phy_mutex);
-		return;
-	}
-
-	asix_write_cmd(dev, AX_CMD_WRITE_MII_REG, phy_id,
-		       (__u16)loc, 2, &res, 0);
-	asix_set_hw_mii(dev, 0);
-	mutex_unlock(&dev->phy_mutex);
-}
-
-int asix_mdio_read_nopm(struct net_device *netdev, int phy_id, int loc)
-{
-	struct usbnet *dev = netdev_priv(netdev);
-	__le16 res;
-	u8 smsr;
-	int i = 0;
-	int ret;
-
-	mutex_lock(&dev->phy_mutex);
-	do {
-		ret = asix_set_sw_mii(dev, 1);
-		if (ret == -ENODEV || ret == -ETIMEDOUT)
-			break;
-		usleep_range(1000, 1100);
-		ret = asix_read_cmd(dev, AX_CMD_STATMNGSTS_REG,
-				    0, 0, 1, &smsr, 1);
-	} while (!(smsr & AX_HOST_EN) && (i++ < 30) && (ret != -ENODEV));
-	if (ret == -ENODEV || ret == -ETIMEDOUT) {
-		mutex_unlock(&dev->phy_mutex);
-		return ret;
-	}
-
-	asix_read_cmd(dev, AX_CMD_READ_MII_REG, phy_id,
-		      (__u16)loc, 2, &res, 1);
-	asix_set_hw_mii(dev, 1);
-	mutex_unlock(&dev->phy_mutex);
-
-	netdev_dbg(dev->net, "asix_mdio_read_nopm() phy_id=0x%02x, loc=0x%02x, returns=0x%04x\n",
-			phy_id, loc, le16_to_cpu(res));
-
-	return le16_to_cpu(res);
-}
-
-void
-asix_mdio_write_nopm(struct net_device *netdev, int phy_id, int loc, int val)
-{
-	struct usbnet *dev = netdev_priv(netdev);
-	__le16 res = cpu_to_le16(val);
-	u8 smsr;
-	int i = 0;
-	int ret;
-
-	netdev_dbg(dev->net, "asix_mdio_write() phy_id=0x%02x, loc=0x%02x, val=0x%04x\n",
-			phy_id, loc, val);
-
-	mutex_lock(&dev->phy_mutex);
-	do {
-		ret = asix_set_sw_mii(dev, 1);
-		if (ret == -ENODEV)
-			break;
-		usleep_range(1000, 1100);
-		ret = asix_read_cmd(dev, AX_CMD_STATMNGSTS_REG,
-				    0, 0, 1, &smsr, 1);
-	} while (!(smsr & AX_HOST_EN) && (i++ < 30) && (ret != -ENODEV));
-	if (ret == -ENODEV) {
-		mutex_unlock(&dev->phy_mutex);
-		return;
-	}
-
-	asix_write_cmd(dev, AX_CMD_WRITE_MII_REG, phy_id,
-		       (__u16)loc, 2, &res, 1);
-	asix_set_hw_mii(dev, 1);
-	mutex_unlock(&dev->phy_mutex);
-}
-
-void asix_get_wol(struct net_device *net, struct ethtool_wolinfo *wolinfo)
-{
-	struct usbnet *dev = netdev_priv(net);
-	u8 opt;
-
-	if (asix_read_cmd(dev, AX_CMD_READ_MONITOR_MODE,
-			  0, 0, 1, &opt, 0) < 0) {
-		wolinfo->supported = 0;
-		wolinfo->wolopts = 0;
-		return;
-	}
-	wolinfo->supported = WAKE_PHY | WAKE_MAGIC;
-	wolinfo->wolopts = 0;
-	if (opt & AX_MONITOR_LINK)
-		wolinfo->wolopts |= WAKE_PHY;
-	if (opt & AX_MONITOR_MAGIC)
-		wolinfo->wolopts |= WAKE_MAGIC;
-}
-
-int asix_set_wol(struct net_device *net, struct ethtool_wolinfo *wolinfo)
-{
-	struct usbnet *dev = netdev_priv(net);
-	u8 opt = 0;
-
-	if (wolinfo->wolopts & ~(WAKE_PHY | WAKE_MAGIC))
-		return -EINVAL;
-
-	if (wolinfo->wolopts & WAKE_PHY)
-		opt |= AX_MONITOR_LINK;
-	if (wolinfo->wolopts & WAKE_MAGIC)
-		opt |= AX_MONITOR_MAGIC;
-
-	if (asix_write_cmd(dev, AX_CMD_WRITE_MONITOR_MODE,
-			      opt, 0, 0, NULL, 0) < 0)
-		return -EINVAL;
-
-	return 0;
-}
-
-int asix_get_eeprom_len(struct net_device *net)
-{
-	return AX_EEPROM_LEN;
-}
-
-int asix_get_eeprom(struct net_device *net, struct ethtool_eeprom *eeprom,
-		    u8 *data)
-{
-	struct usbnet *dev = netdev_priv(net);
-	u16 *eeprom_buff;
-	int first_word, last_word;
-	int i;
-
-	if (eeprom->len == 0)
-		return -EINVAL;
-
-	eeprom->magic = AX_EEPROM_MAGIC;
-
-	first_word = eeprom->offset >> 1;
-	last_word = (eeprom->offset + eeprom->len - 1) >> 1;
-
-	eeprom_buff = kmalloc_array(last_word - first_word + 1, sizeof(u16),
-				    GFP_KERNEL);
-	if (!eeprom_buff)
-		return -ENOMEM;
-
-	/* ax8817x returns 2 bytes from eeprom on read */
-	for (i = first_word; i <= last_word; i++) {
-		if (asix_read_cmd(dev, AX_CMD_READ_EEPROM, i, 0, 2,
-				  &eeprom_buff[i - first_word], 0) < 0) {
-			kfree(eeprom_buff);
-			return -EIO;
-		}
-	}
-
-	memcpy(data, (u8 *)eeprom_buff + (eeprom->offset & 1), eeprom->len);
-	kfree(eeprom_buff);
-	return 0;
-}
-
-int asix_set_eeprom(struct net_device *net, struct ethtool_eeprom *eeprom,
-		    u8 *data)
-{
-	struct usbnet *dev = netdev_priv(net);
-	u16 *eeprom_buff;
-	int first_word, last_word;
-	int i;
-	int ret;
-
-	netdev_dbg(net, "write EEPROM len %d, offset %d, magic 0x%x\n",
-		   eeprom->len, eeprom->offset, eeprom->magic);
-
-	if (eeprom->len == 0)
-		return -EINVAL;
-
-	if (eeprom->magic != AX_EEPROM_MAGIC)
-		return -EINVAL;
-
-	first_word = eeprom->offset >> 1;
-	last_word = (eeprom->offset + eeprom->len - 1) >> 1;
-
-	eeprom_buff = kmalloc_array(last_word - first_word + 1, sizeof(u16),
-				    GFP_KERNEL);
-	if (!eeprom_buff)
-		return -ENOMEM;
-
-	/* align data to 16 bit boundaries, read the missing data from
-	   the EEPROM */
-	if (eeprom->offset & 1) {
-		ret = asix_read_cmd(dev, AX_CMD_READ_EEPROM, first_word, 0, 2,
-				    &eeprom_buff[0], 0);
-		if (ret < 0) {
-			netdev_err(net, "Failed to read EEPROM at offset 0x%02x.\n", first_word);
-			goto free;
-		}
-	}
-
-	if ((eeprom->offset + eeprom->len) & 1) {
-		ret = asix_read_cmd(dev, AX_CMD_READ_EEPROM, last_word, 0, 2,
-				    &eeprom_buff[last_word - first_word], 0);
-		if (ret < 0) {
-			netdev_err(net, "Failed to read EEPROM at offset 0x%02x.\n", last_word);
-			goto free;
-		}
-	}
-
-	memcpy((u8 *)eeprom_buff + (eeprom->offset & 1), data, eeprom->len);
-
-	/* write data to EEPROM */
-	ret = asix_write_cmd(dev, AX_CMD_WRITE_ENABLE, 0x0000, 0, 0, NULL, 0);
-	if (ret < 0) {
-		netdev_err(net, "Failed to enable EEPROM write\n");
-		goto free;
-	}
-	msleep(20);
-
-	for (i = first_word; i <= last_word; i++) {
-		netdev_dbg(net, "write to EEPROM at offset 0x%02x, data 0x%04x\n",
-			   i, eeprom_buff[i - first_word]);
-		ret = asix_write_cmd(dev, AX_CMD_WRITE_EEPROM, i,
-				     eeprom_buff[i - first_word], 0, NULL, 0);
-		if (ret < 0) {
-			netdev_err(net, "Failed to write EEPROM at offset 0x%02x.\n",
-				   i);
-			goto free;
-		}
-		msleep(20);
-	}
-
-	ret = asix_write_cmd(dev, AX_CMD_WRITE_DISABLE, 0x0000, 0, 0, NULL, 0);
-	if (ret < 0) {
-		netdev_err(net, "Failed to disable EEPROM write\n");
-		goto free;
-	}
-
-	ret = 0;
-free:
-	kfree(eeprom_buff);
-	return ret;
-}
-
-void asix_get_drvinfo(struct net_device *net, struct ethtool_drvinfo *info)
-{
-	/* Inherit standard device info */
-	usbnet_get_drvinfo(net, info);
-	strlcpy(info->driver, DRIVER_NAME, sizeof(info->driver));
-	strlcpy(info->version, DRIVER_VERSION, sizeof(info->version));
-}
-
-int asix_set_mac_address(struct net_device *net, void *p)
-{
-	struct usbnet *dev = netdev_priv(net);
-	struct asix_data *data = (struct asix_data *)&dev->data;
-	struct sockaddr *addr = p;
-
-	if (netif_running(net))
-		return -EBUSY;
-	if (!is_valid_ether_addr(addr->sa_data))
-		return -EADDRNOTAVAIL;
-
-	memcpy(net->dev_addr, addr->sa_data, ETH_ALEN);
-
-	/* We use the 20 byte dev->data
-	 * for our 6 byte mac buffer
-	 * to avoid allocating memory that
-	 * is tricky to free later */
-	memcpy(data->mac_addr, addr->sa_data, ETH_ALEN);
-	asix_write_cmd_async(dev, AX_CMD_WRITE_NODE_ID, 0, 0, ETH_ALEN,
-							data->mac_addr);
-
-	return 0;
-}
diff --git a/drivers/net/usb/asix_devices.c b/drivers/net/usb/asix_devices.c
deleted file mode 100644
index 2eca416..00000000
--- a/drivers/net/usb/asix_devices.c
+++ /dev/null
@@ -1,1401 +0,0 @@
-/*
- * ASIX AX8817X based USB 2.0 Ethernet Devices
- * Copyright (C) 2003-2006 David Hollis <dhollis@davehollis.com>
- * Copyright (C) 2005 Phil Chang <pchang23@sbcglobal.net>
- * Copyright (C) 2006 James Painter <jamie.painter@iname.com>
- * Copyright (c) 2002-2003 TiVo Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, see <http://www.gnu.org/licenses/>.
- */
-
-#include "asix.h"
-
-#define PHY_MODE_MARVELL	0x0000
-#define MII_MARVELL_LED_CTRL	0x0018
-#define MII_MARVELL_STATUS	0x001b
-#define MII_MARVELL_CTRL	0x0014
-
-#define MARVELL_LED_MANUAL	0x0019
-
-#define MARVELL_STATUS_HWCFG	0x0004
-
-#define MARVELL_CTRL_TXDELAY	0x0002
-#define MARVELL_CTRL_RXDELAY	0x0080
-
-#define	PHY_MODE_RTL8211CL	0x000C
-
-#define AX88772A_PHY14H		0x14
-#define AX88772A_PHY14H_DEFAULT 0x442C
-
-#define AX88772A_PHY15H		0x15
-#define AX88772A_PHY15H_DEFAULT 0x03C8
-
-#define AX88772A_PHY16H		0x16
-#define AX88772A_PHY16H_DEFAULT 0x4044
-
-struct ax88172_int_data {
-	__le16 res1;
-	u8 link;
-	__le16 res2;
-	u8 status;
-	__le16 res3;
-} __packed;
-
-static void asix_status(struct usbnet *dev, struct urb *urb)
-{
-	struct ax88172_int_data *event;
-	int link;
-
-	if (urb->actual_length < 8)
-		return;
-
-	event = urb->transfer_buffer;
-	link = event->link & 0x01;
-	if (netif_carrier_ok(dev->net) != link) {
-		usbnet_link_change(dev, link, 1);
-		netdev_dbg(dev->net, "Link Status is: %d\n", link);
-	}
-}
-
-static void asix_set_netdev_dev_addr(struct usbnet *dev, u8 *addr)
-{
-	if (is_valid_ether_addr(addr)) {
-		memcpy(dev->net->dev_addr, addr, ETH_ALEN);
-	} else {
-		netdev_info(dev->net, "invalid hw address, using random\n");
-		eth_hw_addr_random(dev->net);
-	}
-}
-
-/* Get the PHY Identifier from the PHYSID1 & PHYSID2 MII registers */
-static u32 asix_get_phyid(struct usbnet *dev)
-{
-	int phy_reg;
-	u32 phy_id;
-	int i;
-
-	/* Poll for the rare case the FW or phy isn't ready yet.  */
-	for (i = 0; i < 100; i++) {
-		phy_reg = asix_mdio_read(dev->net, dev->mii.phy_id, MII_PHYSID1);
-		if (phy_reg < 0)
-			return 0;
-		if (phy_reg != 0 && phy_reg != 0xFFFF)
-			break;
-		mdelay(1);
-	}
-
-	if (phy_reg <= 0 || phy_reg == 0xFFFF)
-		return 0;
-
-	phy_id = (phy_reg & 0xffff) << 16;
-
-	phy_reg = asix_mdio_read(dev->net, dev->mii.phy_id, MII_PHYSID2);
-	if (phy_reg < 0)
-		return 0;
-
-	phy_id |= (phy_reg & 0xffff);
-
-	return phy_id;
-}
-
-static u32 asix_get_link(struct net_device *net)
-{
-	struct usbnet *dev = netdev_priv(net);
-
-	return mii_link_ok(&dev->mii);
-}
-
-static int asix_ioctl (struct net_device *net, struct ifreq *rq, int cmd)
-{
-	struct usbnet *dev = netdev_priv(net);
-
-	return generic_mii_ioctl(&dev->mii, if_mii(rq), cmd, NULL);
-}
-
-/* We need to override some ethtool_ops so we require our
-   own structure so we don't interfere with other usbnet
-   devices that may be connected at the same time. */
-static const struct ethtool_ops ax88172_ethtool_ops = {
-	.get_drvinfo		= asix_get_drvinfo,
-	.get_link		= asix_get_link,
-	.get_msglevel		= usbnet_get_msglevel,
-	.set_msglevel		= usbnet_set_msglevel,
-	.get_wol		= asix_get_wol,
-	.set_wol		= asix_set_wol,
-	.get_eeprom_len		= asix_get_eeprom_len,
-	.get_eeprom		= asix_get_eeprom,
-	.set_eeprom		= asix_set_eeprom,
-	.nway_reset		= usbnet_nway_reset,
-	.get_link_ksettings	= usbnet_get_link_ksettings,
-	.set_link_ksettings	= usbnet_set_link_ksettings,
-};
-
-static void ax88172_set_multicast(struct net_device *net)
-{
-	struct usbnet *dev = netdev_priv(net);
-	struct asix_data *data = (struct asix_data *)&dev->data;
-	u8 rx_ctl = 0x8c;
-
-	if (net->flags & IFF_PROMISC) {
-		rx_ctl |= 0x01;
-	} else if (net->flags & IFF_ALLMULTI ||
-		   netdev_mc_count(net) > AX_MAX_MCAST) {
-		rx_ctl |= 0x02;
-	} else if (netdev_mc_empty(net)) {
-		/* just broadcast and directed */
-	} else {
-		/* We use the 20 byte dev->data
-		 * for our 8 byte filter buffer
-		 * to avoid allocating memory that
-		 * is tricky to free later */
-		struct netdev_hw_addr *ha;
-		u32 crc_bits;
-
-		memset(data->multi_filter, 0, AX_MCAST_FILTER_SIZE);
-
-		/* Build the multicast hash filter. */
-		netdev_for_each_mc_addr(ha, net) {
-			crc_bits = ether_crc(ETH_ALEN, ha->addr) >> 26;
-			data->multi_filter[crc_bits >> 3] |=
-			    1 << (crc_bits & 7);
-		}
-
-		asix_write_cmd_async(dev, AX_CMD_WRITE_MULTI_FILTER, 0, 0,
-				   AX_MCAST_FILTER_SIZE, data->multi_filter);
-
-		rx_ctl |= 0x10;
-	}
-
-	asix_write_cmd_async(dev, AX_CMD_WRITE_RX_CTL, rx_ctl, 0, 0, NULL);
-}
-
-static int ax88172_link_reset(struct usbnet *dev)
-{
-	u8 mode;
-	struct ethtool_cmd ecmd = { .cmd = ETHTOOL_GSET };
-
-	mii_check_media(&dev->mii, 1, 1);
-	mii_ethtool_gset(&dev->mii, &ecmd);
-	mode = AX88172_MEDIUM_DEFAULT;
-
-	if (ecmd.duplex != DUPLEX_FULL)
-		mode |= ~AX88172_MEDIUM_FD;
-
-	netdev_dbg(dev->net, "ax88172_link_reset() speed: %u duplex: %d setting mode to 0x%04x\n",
-		   ethtool_cmd_speed(&ecmd), ecmd.duplex, mode);
-
-	asix_write_medium_mode(dev, mode, 0);
-
-	return 0;
-}
-
-static const struct net_device_ops ax88172_netdev_ops = {
-	.ndo_open		= usbnet_open,
-	.ndo_stop		= usbnet_stop,
-	.ndo_start_xmit		= usbnet_start_xmit,
-	.ndo_tx_timeout		= usbnet_tx_timeout,
-	.ndo_change_mtu		= usbnet_change_mtu,
-	.ndo_get_stats64	= usbnet_get_stats64,
-	.ndo_set_mac_address 	= eth_mac_addr,
-	.ndo_validate_addr	= eth_validate_addr,
-	.ndo_do_ioctl		= asix_ioctl,
-	.ndo_set_rx_mode	= ax88172_set_multicast,
-};
-
-static void asix_phy_reset(struct usbnet *dev, unsigned int reset_bits)
-{
-	unsigned int timeout = 5000;
-
-	asix_mdio_write(dev->net, dev->mii.phy_id, MII_BMCR, reset_bits);
-
-	/* give phy_id a chance to process reset */
-	udelay(500);
-
-	/* See IEEE 802.3 "22.2.4.1.1 Reset": 500ms max */
-	while (timeout--) {
-		if (asix_mdio_read(dev->net, dev->mii.phy_id, MII_BMCR)
-							& BMCR_RESET)
-			udelay(100);
-		else
-			return;
-	}
-
-	netdev_err(dev->net, "BMCR_RESET timeout on phy_id %d\n",
-		   dev->mii.phy_id);
-}
-
-static int ax88172_bind(struct usbnet *dev, struct usb_interface *intf)
-{
-	int ret = 0;
-	u8 buf[ETH_ALEN] = {0};
-	int i;
-	unsigned long gpio_bits = dev->driver_info->data;
-
-	usbnet_get_endpoints(dev,intf);
-
-	/* Toggle the GPIOs in a manufacturer/model specific way */
-	for (i = 2; i >= 0; i--) {
-		ret = asix_write_cmd(dev, AX_CMD_WRITE_GPIOS,
-				(gpio_bits >> (i * 8)) & 0xff, 0, 0, NULL, 0);
-		if (ret < 0)
-			goto out;
-		msleep(5);
-	}
-
-	ret = asix_write_rx_ctl(dev, 0x80, 0);
-	if (ret < 0)
-		goto out;
-
-	/* Get the MAC address */
-	ret = asix_read_cmd(dev, AX88172_CMD_READ_NODE_ID,
-			    0, 0, ETH_ALEN, buf, 0);
-	if (ret < 0) {
-		netdev_dbg(dev->net, "read AX_CMD_READ_NODE_ID failed: %d\n",
-			   ret);
-		goto out;
-	}
-
-	asix_set_netdev_dev_addr(dev, buf);
-
-	/* Initialize MII structure */
-	dev->mii.dev = dev->net;
-	dev->mii.mdio_read = asix_mdio_read;
-	dev->mii.mdio_write = asix_mdio_write;
-	dev->mii.phy_id_mask = 0x3f;
-	dev->mii.reg_num_mask = 0x1f;
-	dev->mii.phy_id = asix_get_phy_addr(dev);
-
-	dev->net->netdev_ops = &ax88172_netdev_ops;
-	dev->net->ethtool_ops = &ax88172_ethtool_ops;
-	dev->net->needed_headroom = 4; /* cf asix_tx_fixup() */
-	dev->net->needed_tailroom = 4; /* cf asix_tx_fixup() */
-
-	asix_phy_reset(dev, BMCR_RESET);
-	asix_mdio_write(dev->net, dev->mii.phy_id, MII_ADVERTISE,
-		ADVERTISE_ALL | ADVERTISE_CSMA | ADVERTISE_PAUSE_CAP);
-	mii_nway_restart(&dev->mii);
-
-	return 0;
-
-out:
-	return ret;
-}
-
-static const struct ethtool_ops ax88772_ethtool_ops = {
-	.get_drvinfo		= asix_get_drvinfo,
-	.get_link		= asix_get_link,
-	.get_msglevel		= usbnet_get_msglevel,
-	.set_msglevel		= usbnet_set_msglevel,
-	.get_wol		= asix_get_wol,
-	.set_wol		= asix_set_wol,
-	.get_eeprom_len		= asix_get_eeprom_len,
-	.get_eeprom		= asix_get_eeprom,
-	.set_eeprom		= asix_set_eeprom,
-	.nway_reset		= usbnet_nway_reset,
-	.get_link_ksettings	= usbnet_get_link_ksettings,
-	.set_link_ksettings	= usbnet_set_link_ksettings,
-};
-
-static int ax88772_link_reset(struct usbnet *dev)
-{
-	u16 mode;
-	struct ethtool_cmd ecmd = { .cmd = ETHTOOL_GSET };
-
-	mii_check_media(&dev->mii, 1, 1);
-	mii_ethtool_gset(&dev->mii, &ecmd);
-	mode = AX88772_MEDIUM_DEFAULT;
-
-	if (ethtool_cmd_speed(&ecmd) != SPEED_100)
-		mode &= ~AX_MEDIUM_PS;
-
-	if (ecmd.duplex != DUPLEX_FULL)
-		mode &= ~AX_MEDIUM_FD;
-
-	netdev_dbg(dev->net, "ax88772_link_reset() speed: %u duplex: %d setting mode to 0x%04x\n",
-		   ethtool_cmd_speed(&ecmd), ecmd.duplex, mode);
-
-	asix_write_medium_mode(dev, mode, 0);
-
-	return 0;
-}
-
-static int ax88772_reset(struct usbnet *dev)
-{
-	struct asix_data *data = (struct asix_data *)&dev->data;
-	int ret;
-
-	/* Rewrite MAC address */
-	ether_addr_copy(data->mac_addr, dev->net->dev_addr);
-	ret = asix_write_cmd(dev, AX_CMD_WRITE_NODE_ID, 0, 0,
-			     ETH_ALEN, data->mac_addr, 0);
-	if (ret < 0)
-		goto out;
-
-	/* Set RX_CTL to default values with 2k buffer, and enable cactus */
-	ret = asix_write_rx_ctl(dev, AX_DEFAULT_RX_CTL, 0);
-	if (ret < 0)
-		goto out;
-
-	ret = asix_write_medium_mode(dev, AX88772_MEDIUM_DEFAULT, 0);
-	if (ret < 0)
-		goto out;
-
-	return 0;
-
-out:
-	return ret;
-}
-
-static int ax88772_hw_reset(struct usbnet *dev, int in_pm)
-{
-	struct asix_data *data = (struct asix_data *)&dev->data;
-	int ret, embd_phy;
-	u16 rx_ctl;
-
-	ret = asix_write_gpio(dev, AX_GPIO_RSE | AX_GPIO_GPO_2 |
-			      AX_GPIO_GPO2EN, 5, in_pm);
-	if (ret < 0)
-		goto out;
-
-	embd_phy = ((dev->mii.phy_id & 0x1f) == 0x10 ? 1 : 0);
-
-	ret = asix_write_cmd(dev, AX_CMD_SW_PHY_SELECT, embd_phy,
-			     0, 0, NULL, in_pm);
-	if (ret < 0) {
-		netdev_dbg(dev->net, "Select PHY #1 failed: %d\n", ret);
-		goto out;
-	}
-
-	if (embd_phy) {
-		ret = asix_sw_reset(dev, AX_SWRESET_IPPD, in_pm);
-		if (ret < 0)
-			goto out;
-
-		usleep_range(10000, 11000);
-
-		ret = asix_sw_reset(dev, AX_SWRESET_CLEAR, in_pm);
-		if (ret < 0)
-			goto out;
-
-		msleep(60);
-
-		ret = asix_sw_reset(dev, AX_SWRESET_IPRL | AX_SWRESET_PRL,
-				    in_pm);
-		if (ret < 0)
-			goto out;
-	} else {
-		ret = asix_sw_reset(dev, AX_SWRESET_IPPD | AX_SWRESET_PRL,
-				    in_pm);
-		if (ret < 0)
-			goto out;
-	}
-
-	msleep(150);
-
-	if (in_pm && (!asix_mdio_read_nopm(dev->net, dev->mii.phy_id,
-					   MII_PHYSID1))){
-		ret = -EIO;
-		goto out;
-	}
-
-	ret = asix_write_rx_ctl(dev, AX_DEFAULT_RX_CTL, in_pm);
-	if (ret < 0)
-		goto out;
-
-	ret = asix_write_medium_mode(dev, AX88772_MEDIUM_DEFAULT, in_pm);
-	if (ret < 0)
-		goto out;
-
-	ret = asix_write_cmd(dev, AX_CMD_WRITE_IPG0,
-			     AX88772_IPG0_DEFAULT | AX88772_IPG1_DEFAULT,
-			     AX88772_IPG2_DEFAULT, 0, NULL, in_pm);
-	if (ret < 0) {
-		netdev_dbg(dev->net, "Write IPG,IPG1,IPG2 failed: %d\n", ret);
-		goto out;
-	}
-
-	/* Rewrite MAC address */
-	ether_addr_copy(data->mac_addr, dev->net->dev_addr);
-	ret = asix_write_cmd(dev, AX_CMD_WRITE_NODE_ID, 0, 0,
-			     ETH_ALEN, data->mac_addr, in_pm);
-	if (ret < 0)
-		goto out;
-
-	/* Set RX_CTL to default values with 2k buffer, and enable cactus */
-	ret = asix_write_rx_ctl(dev, AX_DEFAULT_RX_CTL, in_pm);
-	if (ret < 0)
-		goto out;
-
-	rx_ctl = asix_read_rx_ctl(dev, in_pm);
-	netdev_dbg(dev->net, "RX_CTL is 0x%04x after all initializations\n",
-		   rx_ctl);
-
-	rx_ctl = asix_read_medium_status(dev, in_pm);
-	netdev_dbg(dev->net,
-		   "Medium Status is 0x%04x after all initializations\n",
-		   rx_ctl);
-
-	return 0;
-
-out:
-	return ret;
-}
-
-static int ax88772a_hw_reset(struct usbnet *dev, int in_pm)
-{
-	struct asix_data *data = (struct asix_data *)&dev->data;
-	int ret, embd_phy;
-	u16 rx_ctl, phy14h, phy15h, phy16h;
-	u8 chipcode = 0;
-
-	ret = asix_write_gpio(dev, AX_GPIO_RSE, 5, in_pm);
-	if (ret < 0)
-		goto out;
-
-	embd_phy = ((dev->mii.phy_id & 0x1f) == 0x10 ? 1 : 0);
-
-	ret = asix_write_cmd(dev, AX_CMD_SW_PHY_SELECT, embd_phy |
-			     AX_PHYSEL_SSEN, 0, 0, NULL, in_pm);
-	if (ret < 0) {
-		netdev_dbg(dev->net, "Select PHY #1 failed: %d\n", ret);
-		goto out;
-	}
-	usleep_range(10000, 11000);
-
-	ret = asix_sw_reset(dev, AX_SWRESET_IPPD | AX_SWRESET_IPRL, in_pm);
-	if (ret < 0)
-		goto out;
-
-	usleep_range(10000, 11000);
-
-	ret = asix_sw_reset(dev, AX_SWRESET_IPRL, in_pm);
-	if (ret < 0)
-		goto out;
-
-	msleep(160);
-
-	ret = asix_sw_reset(dev, AX_SWRESET_CLEAR, in_pm);
-	if (ret < 0)
-		goto out;
-
-	ret = asix_sw_reset(dev, AX_SWRESET_IPRL, in_pm);
-	if (ret < 0)
-		goto out;
-
-	msleep(200);
-
-	if (in_pm && (!asix_mdio_read_nopm(dev->net, dev->mii.phy_id,
-					   MII_PHYSID1))) {
-		ret = -1;
-		goto out;
-	}
-
-	ret = asix_read_cmd(dev, AX_CMD_STATMNGSTS_REG, 0,
-			    0, 1, &chipcode, in_pm);
-	if (ret < 0)
-		goto out;
-
-	if ((chipcode & AX_CHIPCODE_MASK) == AX_AX88772B_CHIPCODE) {
-		ret = asix_write_cmd(dev, AX_QCTCTRL, 0x8000, 0x8001,
-				     0, NULL, in_pm);
-		if (ret < 0) {
-			netdev_dbg(dev->net, "Write BQ setting failed: %d\n",
-				   ret);
-			goto out;
-		}
-	} else if ((chipcode & AX_CHIPCODE_MASK) == AX_AX88772A_CHIPCODE) {
-		/* Check if the PHY registers have default settings */
-		phy14h = asix_mdio_read_nopm(dev->net, dev->mii.phy_id,
-					     AX88772A_PHY14H);
-		phy15h = asix_mdio_read_nopm(dev->net, dev->mii.phy_id,
-					     AX88772A_PHY15H);
-		phy16h = asix_mdio_read_nopm(dev->net, dev->mii.phy_id,
-					     AX88772A_PHY16H);
-
-		netdev_dbg(dev->net,
-			   "772a_hw_reset: MR20=0x%x MR21=0x%x MR22=0x%x\n",
-			   phy14h, phy15h, phy16h);
-
-		/* Restore PHY registers default setting if not */
-		if (phy14h != AX88772A_PHY14H_DEFAULT)
-			asix_mdio_write_nopm(dev->net, dev->mii.phy_id,
-					     AX88772A_PHY14H,
-					     AX88772A_PHY14H_DEFAULT);
-		if (phy15h != AX88772A_PHY15H_DEFAULT)
-			asix_mdio_write_nopm(dev->net, dev->mii.phy_id,
-					     AX88772A_PHY15H,
-					     AX88772A_PHY15H_DEFAULT);
-		if (phy16h != AX88772A_PHY16H_DEFAULT)
-			asix_mdio_write_nopm(dev->net, dev->mii.phy_id,
-					     AX88772A_PHY16H,
-					     AX88772A_PHY16H_DEFAULT);
-	}
-
-	ret = asix_write_cmd(dev, AX_CMD_WRITE_IPG0,
-				AX88772_IPG0_DEFAULT | AX88772_IPG1_DEFAULT,
-				AX88772_IPG2_DEFAULT, 0, NULL, in_pm);
-	if (ret < 0) {
-		netdev_dbg(dev->net, "Write IPG,IPG1,IPG2 failed: %d\n", ret);
-		goto out;
-	}
-
-	/* Rewrite MAC address */
-	memcpy(data->mac_addr, dev->net->dev_addr, ETH_ALEN);
-	ret = asix_write_cmd(dev, AX_CMD_WRITE_NODE_ID, 0, 0, ETH_ALEN,
-							data->mac_addr, in_pm);
-	if (ret < 0)
-		goto out;
-
-	/* Set RX_CTL to default values with 2k buffer, and enable cactus */
-	ret = asix_write_rx_ctl(dev, AX_DEFAULT_RX_CTL, in_pm);
-	if (ret < 0)
-		goto out;
-
-	ret = asix_write_medium_mode(dev, AX88772_MEDIUM_DEFAULT, in_pm);
-	if (ret < 0)
-		return ret;
-
-	/* Set RX_CTL to default values with 2k buffer, and enable cactus */
-	ret = asix_write_rx_ctl(dev, AX_DEFAULT_RX_CTL, in_pm);
-	if (ret < 0)
-		goto out;
-
-	rx_ctl = asix_read_rx_ctl(dev, in_pm);
-	netdev_dbg(dev->net, "RX_CTL is 0x%04x after all initializations\n",
-		   rx_ctl);
-
-	rx_ctl = asix_read_medium_status(dev, in_pm);
-	netdev_dbg(dev->net,
-		   "Medium Status is 0x%04x after all initializations\n",
-		   rx_ctl);
-
-	return 0;
-
-out:
-	return ret;
-}
-
-static const struct net_device_ops ax88772_netdev_ops = {
-	.ndo_open		= usbnet_open,
-	.ndo_stop		= usbnet_stop,
-	.ndo_start_xmit		= usbnet_start_xmit,
-	.ndo_tx_timeout		= usbnet_tx_timeout,
-	.ndo_change_mtu		= usbnet_change_mtu,
-	.ndo_get_stats64	= usbnet_get_stats64,
-	.ndo_set_mac_address 	= asix_set_mac_address,
-	.ndo_validate_addr	= eth_validate_addr,
-	.ndo_do_ioctl		= asix_ioctl,
-	.ndo_set_rx_mode        = asix_set_multicast,
-};
-
-static void ax88772_suspend(struct usbnet *dev)
-{
-	struct asix_common_private *priv = dev->driver_priv;
-	u16 medium;
-
-	/* Stop MAC operation */
-	medium = asix_read_medium_status(dev, 1);
-	medium &= ~AX_MEDIUM_RE;
-	asix_write_medium_mode(dev, medium, 1);
-
-	netdev_dbg(dev->net, "ax88772_suspend: medium=0x%04x\n",
-		   asix_read_medium_status(dev, 1));
-
-	/* Preserve BMCR for restoring */
-	priv->presvd_phy_bmcr =
-		asix_mdio_read_nopm(dev->net, dev->mii.phy_id, MII_BMCR);
-
-	/* Preserve ANAR for restoring */
-	priv->presvd_phy_advertise =
-		asix_mdio_read_nopm(dev->net, dev->mii.phy_id, MII_ADVERTISE);
-}
-
-static int asix_suspend(struct usb_interface *intf, pm_message_t message)
-{
-	struct usbnet *dev = usb_get_intfdata(intf);
-	struct asix_common_private *priv = dev->driver_priv;
-
-	if (priv && priv->suspend)
-		priv->suspend(dev);
-
-	return usbnet_suspend(intf, message);
-}
-
-static void ax88772_restore_phy(struct usbnet *dev)
-{
-	struct asix_common_private *priv = dev->driver_priv;
-
-	if (priv->presvd_phy_advertise) {
-		/* Restore Advertisement control reg */
-		asix_mdio_write_nopm(dev->net, dev->mii.phy_id, MII_ADVERTISE,
-				     priv->presvd_phy_advertise);
-
-		/* Restore BMCR */
-		if (priv->presvd_phy_bmcr & BMCR_ANENABLE)
-			priv->presvd_phy_bmcr |= BMCR_ANRESTART;
-
-		asix_mdio_write_nopm(dev->net, dev->mii.phy_id, MII_BMCR,
-				     priv->presvd_phy_bmcr);
-
-		priv->presvd_phy_advertise = 0;
-		priv->presvd_phy_bmcr = 0;
-	}
-}
-
-static void ax88772_resume(struct usbnet *dev)
-{
-	int i;
-
-	for (i = 0; i < 3; i++)
-		if (!ax88772_hw_reset(dev, 1))
-			break;
-	ax88772_restore_phy(dev);
-}
-
-static void ax88772a_resume(struct usbnet *dev)
-{
-	int i;
-
-	for (i = 0; i < 3; i++) {
-		if (!ax88772a_hw_reset(dev, 1))
-			break;
-	}
-
-	ax88772_restore_phy(dev);
-}
-
-static int asix_resume(struct usb_interface *intf)
-{
-	struct usbnet *dev = usb_get_intfdata(intf);
-	struct asix_common_private *priv = dev->driver_priv;
-
-	if (priv && priv->resume)
-		priv->resume(dev);
-
-	return usbnet_resume(intf);
-}
-
-static int ax88772_bind(struct usbnet *dev, struct usb_interface *intf)
-{
-	int ret, i;
-	u8 buf[ETH_ALEN] = {0}, chipcode = 0;
-	u32 phyid;
-	struct asix_common_private *priv;
-
-	usbnet_get_endpoints(dev, intf);
-
-	/* Maybe the boot loader passed the MAC address via device tree */
-	if (!eth_platform_get_mac_address(&dev->udev->dev, buf)) {
-		netif_dbg(dev, ifup, dev->net,
-			  "MAC address read from device tree");
-	} else {
-		/* Try getting the MAC address from EEPROM */
-		if (dev->driver_info->data & FLAG_EEPROM_MAC) {
-			for (i = 0; i < (ETH_ALEN >> 1); i++) {
-				ret = asix_read_cmd(dev, AX_CMD_READ_EEPROM,
-						    0x04 + i, 0, 2, buf + i * 2,
-						    0);
-				if (ret < 0)
-					break;
-			}
-		} else {
-			ret = asix_read_cmd(dev, AX_CMD_READ_NODE_ID,
-					    0, 0, ETH_ALEN, buf, 0);
-		}
-
-		if (ret < 0) {
-			netdev_dbg(dev->net, "Failed to read MAC address: %d\n",
-				   ret);
-			return ret;
-		}
-	}
-
-	asix_set_netdev_dev_addr(dev, buf);
-
-	/* Initialize MII structure */
-	dev->mii.dev = dev->net;
-	dev->mii.mdio_read = asix_mdio_read;
-	dev->mii.mdio_write = asix_mdio_write;
-	dev->mii.phy_id_mask = 0x1f;
-	dev->mii.reg_num_mask = 0x1f;
-	dev->mii.phy_id = asix_get_phy_addr(dev);
-
-	dev->net->netdev_ops = &ax88772_netdev_ops;
-	dev->net->ethtool_ops = &ax88772_ethtool_ops;
-	dev->net->needed_headroom = 4; /* cf asix_tx_fixup() */
-	dev->net->needed_tailroom = 4; /* cf asix_tx_fixup() */
-
-	asix_read_cmd(dev, AX_CMD_STATMNGSTS_REG, 0, 0, 1, &chipcode, 0);
-	chipcode &= AX_CHIPCODE_MASK;
-
-	ret = (chipcode == AX_AX88772_CHIPCODE) ? ax88772_hw_reset(dev, 0) :
-						  ax88772a_hw_reset(dev, 0);
-
-	if (ret < 0) {
-		netdev_dbg(dev->net, "Failed to reset AX88772: %d\n", ret);
-		return ret;
-	}
-
-	/* Read PHYID register *AFTER* the PHY was reset properly */
-	phyid = asix_get_phyid(dev);
-	netdev_dbg(dev->net, "PHYID=0x%08x\n", phyid);
-
-	/* Asix framing packs multiple eth frames into a 2K usb bulk transfer */
-	if (dev->driver_info->flags & FLAG_FRAMING_AX) {
-		/* hard_mtu  is still the default - the device does not support
-		   jumbo eth frames */
-		dev->rx_urb_size = 2048;
-	}
-
-	dev->driver_priv = kzalloc(sizeof(struct asix_common_private), GFP_KERNEL);
-	if (!dev->driver_priv)
-		return -ENOMEM;
-
-	priv = dev->driver_priv;
-
-	priv->presvd_phy_bmcr = 0;
-	priv->presvd_phy_advertise = 0;
-	if (chipcode == AX_AX88772_CHIPCODE) {
-		priv->resume = ax88772_resume;
-		priv->suspend = ax88772_suspend;
-	} else {
-		priv->resume = ax88772a_resume;
-		priv->suspend = ax88772_suspend;
-	}
-
-	return 0;
-}
-
-static void ax88772_unbind(struct usbnet *dev, struct usb_interface *intf)
-{
-	asix_rx_fixup_common_free(dev->driver_priv);
-	kfree(dev->driver_priv);
-}
-
-static const struct ethtool_ops ax88178_ethtool_ops = {
-	.get_drvinfo		= asix_get_drvinfo,
-	.get_link		= asix_get_link,
-	.get_msglevel		= usbnet_get_msglevel,
-	.set_msglevel		= usbnet_set_msglevel,
-	.get_wol		= asix_get_wol,
-	.set_wol		= asix_set_wol,
-	.get_eeprom_len		= asix_get_eeprom_len,
-	.get_eeprom		= asix_get_eeprom,
-	.set_eeprom		= asix_set_eeprom,
-	.nway_reset		= usbnet_nway_reset,
-	.get_link_ksettings	= usbnet_get_link_ksettings,
-	.set_link_ksettings	= usbnet_set_link_ksettings,
-};
-
-static int marvell_phy_init(struct usbnet *dev)
-{
-	struct asix_data *data = (struct asix_data *)&dev->data;
-	u16 reg;
-
-	netdev_dbg(dev->net, "marvell_phy_init()\n");
-
-	reg = asix_mdio_read(dev->net, dev->mii.phy_id, MII_MARVELL_STATUS);
-	netdev_dbg(dev->net, "MII_MARVELL_STATUS = 0x%04x\n", reg);
-
-	asix_mdio_write(dev->net, dev->mii.phy_id, MII_MARVELL_CTRL,
-			MARVELL_CTRL_RXDELAY | MARVELL_CTRL_TXDELAY);
-
-	if (data->ledmode) {
-		reg = asix_mdio_read(dev->net, dev->mii.phy_id,
-			MII_MARVELL_LED_CTRL);
-		netdev_dbg(dev->net, "MII_MARVELL_LED_CTRL (1) = 0x%04x\n", reg);
-
-		reg &= 0xf8ff;
-		reg |= (1 + 0x0100);
-		asix_mdio_write(dev->net, dev->mii.phy_id,
-			MII_MARVELL_LED_CTRL, reg);
-
-		reg = asix_mdio_read(dev->net, dev->mii.phy_id,
-			MII_MARVELL_LED_CTRL);
-		netdev_dbg(dev->net, "MII_MARVELL_LED_CTRL (2) = 0x%04x\n", reg);
-		reg &= 0xfc0f;
-	}
-
-	return 0;
-}
-
-static int rtl8211cl_phy_init(struct usbnet *dev)
-{
-	struct asix_data *data = (struct asix_data *)&dev->data;
-
-	netdev_dbg(dev->net, "rtl8211cl_phy_init()\n");
-
-	asix_mdio_write (dev->net, dev->mii.phy_id, 0x1f, 0x0005);
-	asix_mdio_write (dev->net, dev->mii.phy_id, 0x0c, 0);
-	asix_mdio_write (dev->net, dev->mii.phy_id, 0x01,
-		asix_mdio_read (dev->net, dev->mii.phy_id, 0x01) | 0x0080);
-	asix_mdio_write (dev->net, dev->mii.phy_id, 0x1f, 0);
-
-	if (data->ledmode == 12) {
-		asix_mdio_write (dev->net, dev->mii.phy_id, 0x1f, 0x0002);
-		asix_mdio_write (dev->net, dev->mii.phy_id, 0x1a, 0x00cb);
-		asix_mdio_write (dev->net, dev->mii.phy_id, 0x1f, 0);
-	}
-
-	return 0;
-}
-
-static int marvell_led_status(struct usbnet *dev, u16 speed)
-{
-	u16 reg = asix_mdio_read(dev->net, dev->mii.phy_id, MARVELL_LED_MANUAL);
-
-	netdev_dbg(dev->net, "marvell_led_status() read 0x%04x\n", reg);
-
-	/* Clear out the center LED bits - 0x03F0 */
-	reg &= 0xfc0f;
-
-	switch (speed) {
-		case SPEED_1000:
-			reg |= 0x03e0;
-			break;
-		case SPEED_100:
-			reg |= 0x03b0;
-			break;
-		default:
-			reg |= 0x02f0;
-	}
-
-	netdev_dbg(dev->net, "marvell_led_status() writing 0x%04x\n", reg);
-	asix_mdio_write(dev->net, dev->mii.phy_id, MARVELL_LED_MANUAL, reg);
-
-	return 0;
-}
-
-static int ax88178_reset(struct usbnet *dev)
-{
-	struct asix_data *data = (struct asix_data *)&dev->data;
-	int ret;
-	__le16 eeprom;
-	u8 status;
-	int gpio0 = 0;
-	u32 phyid;
-
-	asix_read_cmd(dev, AX_CMD_READ_GPIOS, 0, 0, 1, &status, 0);
-	netdev_dbg(dev->net, "GPIO Status: 0x%04x\n", status);
-
-	asix_write_cmd(dev, AX_CMD_WRITE_ENABLE, 0, 0, 0, NULL, 0);
-	asix_read_cmd(dev, AX_CMD_READ_EEPROM, 0x0017, 0, 2, &eeprom, 0);
-	asix_write_cmd(dev, AX_CMD_WRITE_DISABLE, 0, 0, 0, NULL, 0);
-
-	netdev_dbg(dev->net, "EEPROM index 0x17 is 0x%04x\n", eeprom);
-
-	if (eeprom == cpu_to_le16(0xffff)) {
-		data->phymode = PHY_MODE_MARVELL;
-		data->ledmode = 0;
-		gpio0 = 1;
-	} else {
-		data->phymode = le16_to_cpu(eeprom) & 0x7F;
-		data->ledmode = le16_to_cpu(eeprom) >> 8;
-		gpio0 = (le16_to_cpu(eeprom) & 0x80) ? 0 : 1;
-	}
-	netdev_dbg(dev->net, "GPIO0: %d, PhyMode: %d\n", gpio0, data->phymode);
-
-	/* Power up external GigaPHY through AX88178 GPIO pin */
-	asix_write_gpio(dev, AX_GPIO_RSE | AX_GPIO_GPO_1 |
-			AX_GPIO_GPO1EN, 40, 0);
-	if ((le16_to_cpu(eeprom) >> 8) != 1) {
-		asix_write_gpio(dev, 0x003c, 30, 0);
-		asix_write_gpio(dev, 0x001c, 300, 0);
-		asix_write_gpio(dev, 0x003c, 30, 0);
-	} else {
-		netdev_dbg(dev->net, "gpio phymode == 1 path\n");
-		asix_write_gpio(dev, AX_GPIO_GPO1EN, 30, 0);
-		asix_write_gpio(dev, AX_GPIO_GPO1EN | AX_GPIO_GPO_1, 30, 0);
-	}
-
-	/* Read PHYID register *AFTER* powering up PHY */
-	phyid = asix_get_phyid(dev);
-	netdev_dbg(dev->net, "PHYID=0x%08x\n", phyid);
-
-	/* Set AX88178 to enable MII/GMII/RGMII interface for external PHY */
-	asix_write_cmd(dev, AX_CMD_SW_PHY_SELECT, 0, 0, 0, NULL, 0);
-
-	asix_sw_reset(dev, 0, 0);
-	msleep(150);
-
-	asix_sw_reset(dev, AX_SWRESET_PRL | AX_SWRESET_IPPD, 0);
-	msleep(150);
-
-	asix_write_rx_ctl(dev, 0, 0);
-
-	if (data->phymode == PHY_MODE_MARVELL) {
-		marvell_phy_init(dev);
-		msleep(60);
-	} else if (data->phymode == PHY_MODE_RTL8211CL)
-		rtl8211cl_phy_init(dev);
-
-	asix_phy_reset(dev, BMCR_RESET | BMCR_ANENABLE);
-	asix_mdio_write(dev->net, dev->mii.phy_id, MII_ADVERTISE,
-			ADVERTISE_ALL | ADVERTISE_CSMA | ADVERTISE_PAUSE_CAP);
-	asix_mdio_write(dev->net, dev->mii.phy_id, MII_CTRL1000,
-			ADVERTISE_1000FULL);
-
-	asix_write_medium_mode(dev, AX88178_MEDIUM_DEFAULT, 0);
-	mii_nway_restart(&dev->mii);
-
-	/* Rewrite MAC address */
-	memcpy(data->mac_addr, dev->net->dev_addr, ETH_ALEN);
-	ret = asix_write_cmd(dev, AX_CMD_WRITE_NODE_ID, 0, 0, ETH_ALEN,
-							data->mac_addr, 0);
-	if (ret < 0)
-		return ret;
-
-	ret = asix_write_rx_ctl(dev, AX_DEFAULT_RX_CTL, 0);
-	if (ret < 0)
-		return ret;
-
-	return 0;
-}
-
-static int ax88178_link_reset(struct usbnet *dev)
-{
-	u16 mode;
-	struct ethtool_cmd ecmd = { .cmd = ETHTOOL_GSET };
-	struct asix_data *data = (struct asix_data *)&dev->data;
-	u32 speed;
-
-	netdev_dbg(dev->net, "ax88178_link_reset()\n");
-
-	mii_check_media(&dev->mii, 1, 1);
-	mii_ethtool_gset(&dev->mii, &ecmd);
-	mode = AX88178_MEDIUM_DEFAULT;
-	speed = ethtool_cmd_speed(&ecmd);
-
-	if (speed == SPEED_1000)
-		mode |= AX_MEDIUM_GM;
-	else if (speed == SPEED_100)
-		mode |= AX_MEDIUM_PS;
-	else
-		mode &= ~(AX_MEDIUM_PS | AX_MEDIUM_GM);
-
-	mode |= AX_MEDIUM_ENCK;
-
-	if (ecmd.duplex == DUPLEX_FULL)
-		mode |= AX_MEDIUM_FD;
-	else
-		mode &= ~AX_MEDIUM_FD;
-
-	netdev_dbg(dev->net, "ax88178_link_reset() speed: %u duplex: %d setting mode to 0x%04x\n",
-		   speed, ecmd.duplex, mode);
-
-	asix_write_medium_mode(dev, mode, 0);
-
-	if (data->phymode == PHY_MODE_MARVELL && data->ledmode)
-		marvell_led_status(dev, speed);
-
-	return 0;
-}
-
-static void ax88178_set_mfb(struct usbnet *dev)
-{
-	u16 mfb = AX_RX_CTL_MFB_16384;
-	u16 rxctl;
-	u16 medium;
-	int old_rx_urb_size = dev->rx_urb_size;
-
-	if (dev->hard_mtu < 2048) {
-		dev->rx_urb_size = 2048;
-		mfb = AX_RX_CTL_MFB_2048;
-	} else if (dev->hard_mtu < 4096) {
-		dev->rx_urb_size = 4096;
-		mfb = AX_RX_CTL_MFB_4096;
-	} else if (dev->hard_mtu < 8192) {
-		dev->rx_urb_size = 8192;
-		mfb = AX_RX_CTL_MFB_8192;
-	} else if (dev->hard_mtu < 16384) {
-		dev->rx_urb_size = 16384;
-		mfb = AX_RX_CTL_MFB_16384;
-	}
-
-	rxctl = asix_read_rx_ctl(dev, 0);
-	asix_write_rx_ctl(dev, (rxctl & ~AX_RX_CTL_MFB_16384) | mfb, 0);
-
-	medium = asix_read_medium_status(dev, 0);
-	if (dev->net->mtu > 1500)
-		medium |= AX_MEDIUM_JFE;
-	else
-		medium &= ~AX_MEDIUM_JFE;
-	asix_write_medium_mode(dev, medium, 0);
-
-	if (dev->rx_urb_size > old_rx_urb_size)
-		usbnet_unlink_rx_urbs(dev);
-}
-
-static int ax88178_change_mtu(struct net_device *net, int new_mtu)
-{
-	struct usbnet *dev = netdev_priv(net);
-	int ll_mtu = new_mtu + net->hard_header_len + 4;
-
-	netdev_dbg(dev->net, "ax88178_change_mtu() new_mtu=%d\n", new_mtu);
-
-	if ((ll_mtu % dev->maxpacket) == 0)
-		return -EDOM;
-
-	net->mtu = new_mtu;
-	dev->hard_mtu = net->mtu + net->hard_header_len;
-	ax88178_set_mfb(dev);
-
-	/* max qlen depend on hard_mtu and rx_urb_size */
-	usbnet_update_max_qlen(dev);
-
-	return 0;
-}
-
-static const struct net_device_ops ax88178_netdev_ops = {
-	.ndo_open		= usbnet_open,
-	.ndo_stop		= usbnet_stop,
-	.ndo_start_xmit		= usbnet_start_xmit,
-	.ndo_tx_timeout		= usbnet_tx_timeout,
-	.ndo_get_stats64	= usbnet_get_stats64,
-	.ndo_set_mac_address 	= asix_set_mac_address,
-	.ndo_validate_addr	= eth_validate_addr,
-	.ndo_set_rx_mode	= asix_set_multicast,
-	.ndo_do_ioctl 		= asix_ioctl,
-	.ndo_change_mtu 	= ax88178_change_mtu,
-};
-
-static int ax88178_bind(struct usbnet *dev, struct usb_interface *intf)
-{
-	int ret;
-	u8 buf[ETH_ALEN] = {0};
-
-	usbnet_get_endpoints(dev,intf);
-
-	/* Get the MAC address */
-	ret = asix_read_cmd(dev, AX_CMD_READ_NODE_ID, 0, 0, ETH_ALEN, buf, 0);
-	if (ret < 0) {
-		netdev_dbg(dev->net, "Failed to read MAC address: %d\n", ret);
-		return ret;
-	}
-
-	asix_set_netdev_dev_addr(dev, buf);
-
-	/* Initialize MII structure */
-	dev->mii.dev = dev->net;
-	dev->mii.mdio_read = asix_mdio_read;
-	dev->mii.mdio_write = asix_mdio_write;
-	dev->mii.phy_id_mask = 0x1f;
-	dev->mii.reg_num_mask = 0xff;
-	dev->mii.supports_gmii = 1;
-	dev->mii.phy_id = asix_get_phy_addr(dev);
-
-	dev->net->netdev_ops = &ax88178_netdev_ops;
-	dev->net->ethtool_ops = &ax88178_ethtool_ops;
-	dev->net->max_mtu = 16384 - (dev->net->hard_header_len + 4);
-
-	/* Blink LEDS so users know driver saw dongle */
-	asix_sw_reset(dev, 0, 0);
-	msleep(150);
-
-	asix_sw_reset(dev, AX_SWRESET_PRL | AX_SWRESET_IPPD, 0);
-	msleep(150);
-
-	/* Asix framing packs multiple eth frames into a 2K usb bulk transfer */
-	if (dev->driver_info->flags & FLAG_FRAMING_AX) {
-		/* hard_mtu  is still the default - the device does not support
-		   jumbo eth frames */
-		dev->rx_urb_size = 2048;
-	}
-
-	dev->driver_priv = kzalloc(sizeof(struct asix_common_private), GFP_KERNEL);
-	if (!dev->driver_priv)
-			return -ENOMEM;
-
-	return 0;
-}
-
-static const struct driver_info ax8817x_info = {
-	.description = "ASIX AX8817x USB 2.0 Ethernet",
-	.bind = ax88172_bind,
-	.status = asix_status,
-	.link_reset = ax88172_link_reset,
-	.reset = ax88172_link_reset,
-	.flags =  FLAG_ETHER | FLAG_LINK_INTR,
-	.data = 0x00130103,
-};
-
-static const struct driver_info dlink_dub_e100_info = {
-	.description = "DLink DUB-E100 USB Ethernet",
-	.bind = ax88172_bind,
-	.status = asix_status,
-	.link_reset = ax88172_link_reset,
-	.reset = ax88172_link_reset,
-	.flags =  FLAG_ETHER | FLAG_LINK_INTR,
-	.data = 0x009f9d9f,
-};
-
-static const struct driver_info netgear_fa120_info = {
-	.description = "Netgear FA-120 USB Ethernet",
-	.bind = ax88172_bind,
-	.status = asix_status,
-	.link_reset = ax88172_link_reset,
-	.reset = ax88172_link_reset,
-	.flags =  FLAG_ETHER | FLAG_LINK_INTR,
-	.data = 0x00130103,
-};
-
-static const struct driver_info hawking_uf200_info = {
-	.description = "Hawking UF200 USB Ethernet",
-	.bind = ax88172_bind,
-	.status = asix_status,
-	.link_reset = ax88172_link_reset,
-	.reset = ax88172_link_reset,
-	.flags =  FLAG_ETHER | FLAG_LINK_INTR,
-	.data = 0x001f1d1f,
-};
-
-static const struct driver_info ax88772_info = {
-	.description = "ASIX AX88772 USB 2.0 Ethernet",
-	.bind = ax88772_bind,
-	.unbind = ax88772_unbind,
-	.status = asix_status,
-	.link_reset = ax88772_link_reset,
-	.reset = ax88772_reset,
-	.flags = FLAG_ETHER | FLAG_FRAMING_AX | FLAG_LINK_INTR | FLAG_MULTI_PACKET,
-	.rx_fixup = asix_rx_fixup_common,
-	.tx_fixup = asix_tx_fixup,
-};
-
-static const struct driver_info ax88772b_info = {
-	.description = "ASIX AX88772B USB 2.0 Ethernet",
-	.bind = ax88772_bind,
-	.unbind = ax88772_unbind,
-	.status = asix_status,
-	.link_reset = ax88772_link_reset,
-	.reset = ax88772_reset,
-	.flags = FLAG_ETHER | FLAG_FRAMING_AX | FLAG_LINK_INTR |
-	         FLAG_MULTI_PACKET,
-	.rx_fixup = asix_rx_fixup_common,
-	.tx_fixup = asix_tx_fixup,
-	.data = FLAG_EEPROM_MAC,
-};
-
-static const struct driver_info ax88178_info = {
-	.description = "ASIX AX88178 USB 2.0 Ethernet",
-	.bind = ax88178_bind,
-	.unbind = ax88772_unbind,
-	.status = asix_status,
-	.link_reset = ax88178_link_reset,
-	.reset = ax88178_reset,
-	.flags = FLAG_ETHER | FLAG_FRAMING_AX | FLAG_LINK_INTR |
-		 FLAG_MULTI_PACKET,
-	.rx_fixup = asix_rx_fixup_common,
-	.tx_fixup = asix_tx_fixup,
-};
-
-/*
- * USBLINK 20F9 "USB 2.0 LAN" USB ethernet adapter, typically found in
- * no-name packaging.
- * USB device strings are:
- *   1: Manufacturer: USBLINK
- *   2: Product: HG20F9 USB2.0
- *   3: Serial: 000003
- * Appears to be compatible with Asix 88772B.
- */
-static const struct driver_info hg20f9_info = {
-	.description = "HG20F9 USB 2.0 Ethernet",
-	.bind = ax88772_bind,
-	.unbind = ax88772_unbind,
-	.status = asix_status,
-	.link_reset = ax88772_link_reset,
-	.reset = ax88772_reset,
-	.flags = FLAG_ETHER | FLAG_FRAMING_AX | FLAG_LINK_INTR |
-	         FLAG_MULTI_PACKET,
-	.rx_fixup = asix_rx_fixup_common,
-	.tx_fixup = asix_tx_fixup,
-	.data = FLAG_EEPROM_MAC,
-};
-
-static const struct usb_device_id	products [] = {
-{
-	// Linksys USB200M
-	USB_DEVICE (0x077b, 0x2226),
-	.driver_info =	(unsigned long) &ax8817x_info,
-}, {
-	// Netgear FA120
-	USB_DEVICE (0x0846, 0x1040),
-	.driver_info =  (unsigned long) &netgear_fa120_info,
-}, {
-	// DLink DUB-E100
-	USB_DEVICE (0x2001, 0x1a00),
-	.driver_info =  (unsigned long) &dlink_dub_e100_info,
-}, {
-	// Intellinet, ST Lab USB Ethernet
-	USB_DEVICE (0x0b95, 0x1720),
-	.driver_info =  (unsigned long) &ax8817x_info,
-}, {
-	// Hawking UF200, TrendNet TU2-ET100
-	USB_DEVICE (0x07b8, 0x420a),
-	.driver_info =  (unsigned long) &hawking_uf200_info,
-}, {
-	// Billionton Systems, USB2AR
-	USB_DEVICE (0x08dd, 0x90ff),
-	.driver_info =  (unsigned long) &ax8817x_info,
-}, {
-	// Billionton Systems, GUSB2AM-1G-B
-	USB_DEVICE(0x08dd, 0x0114),
-	.driver_info =  (unsigned long) &ax88178_info,
-}, {
-	// ATEN UC210T
-	USB_DEVICE (0x0557, 0x2009),
-	.driver_info =  (unsigned long) &ax8817x_info,
-}, {
-	// Buffalo LUA-U2-KTX
-	USB_DEVICE (0x0411, 0x003d),
-	.driver_info =  (unsigned long) &ax8817x_info,
-}, {
-	// Buffalo LUA-U2-GT 10/100/1000
-	USB_DEVICE (0x0411, 0x006e),
-	.driver_info =  (unsigned long) &ax88178_info,
-}, {
-	// Sitecom LN-029 "USB 2.0 10/100 Ethernet adapter"
-	USB_DEVICE (0x6189, 0x182d),
-	.driver_info =  (unsigned long) &ax8817x_info,
-}, {
-	// Sitecom LN-031 "USB 2.0 10/100/1000 Ethernet adapter"
-	USB_DEVICE (0x0df6, 0x0056),
-	.driver_info =  (unsigned long) &ax88178_info,
-}, {
-	// Sitecom LN-028 "USB 2.0 10/100/1000 Ethernet adapter"
-	USB_DEVICE (0x0df6, 0x061c),
-	.driver_info =  (unsigned long) &ax88178_info,
-}, {
-	// corega FEther USB2-TX
-	USB_DEVICE (0x07aa, 0x0017),
-	.driver_info =  (unsigned long) &ax8817x_info,
-}, {
-	// Surecom EP-1427X-2
-	USB_DEVICE (0x1189, 0x0893),
-	.driver_info = (unsigned long) &ax8817x_info,
-}, {
-	// goodway corp usb gwusb2e
-	USB_DEVICE (0x1631, 0x6200),
-	.driver_info = (unsigned long) &ax8817x_info,
-}, {
-	// JVC MP-PRX1 Port Replicator
-	USB_DEVICE (0x04f1, 0x3008),
-	.driver_info = (unsigned long) &ax8817x_info,
-}, {
-	// Lenovo U2L100P 10/100
-	USB_DEVICE (0x17ef, 0x7203),
-	.driver_info = (unsigned long)&ax88772b_info,
-}, {
-	// ASIX AX88772B 10/100
-	USB_DEVICE (0x0b95, 0x772b),
-	.driver_info = (unsigned long) &ax88772b_info,
-}, {
-	// ASIX AX88772 10/100
-	USB_DEVICE (0x0b95, 0x7720),
-	.driver_info = (unsigned long) &ax88772_info,
-}, {
-	// ASIX AX88178 10/100/1000
-	USB_DEVICE (0x0b95, 0x1780),
-	.driver_info = (unsigned long) &ax88178_info,
-}, {
-	// Logitec LAN-GTJ/U2A
-	USB_DEVICE (0x0789, 0x0160),
-	.driver_info = (unsigned long) &ax88178_info,
-}, {
-	// Linksys USB200M Rev 2
-	USB_DEVICE (0x13b1, 0x0018),
-	.driver_info = (unsigned long) &ax88772_info,
-}, {
-	// 0Q0 cable ethernet
-	USB_DEVICE (0x1557, 0x7720),
-	.driver_info = (unsigned long) &ax88772_info,
-}, {
-	// DLink DUB-E100 H/W Ver B1
-	USB_DEVICE (0x07d1, 0x3c05),
-	.driver_info = (unsigned long) &ax88772_info,
-}, {
-	// DLink DUB-E100 H/W Ver B1 Alternate
-	USB_DEVICE (0x2001, 0x3c05),
-	.driver_info = (unsigned long) &ax88772_info,
-}, {
-       // DLink DUB-E100 H/W Ver C1
-       USB_DEVICE (0x2001, 0x1a02),
-       .driver_info = (unsigned long) &ax88772_info,
-}, {
-	// Linksys USB1000
-	USB_DEVICE (0x1737, 0x0039),
-	.driver_info = (unsigned long) &ax88178_info,
-}, {
-	// IO-DATA ETG-US2
-	USB_DEVICE (0x04bb, 0x0930),
-	.driver_info = (unsigned long) &ax88178_info,
-}, {
-	// Belkin F5D5055
-	USB_DEVICE(0x050d, 0x5055),
-	.driver_info = (unsigned long) &ax88178_info,
-}, {
-	// Apple USB Ethernet Adapter
-	USB_DEVICE(0x05ac, 0x1402),
-	.driver_info = (unsigned long) &ax88772_info,
-}, {
-	// Cables-to-Go USB Ethernet Adapter
-	USB_DEVICE(0x0b95, 0x772a),
-	.driver_info = (unsigned long) &ax88772_info,
-}, {
-	// ABOCOM for pci
-	USB_DEVICE(0x14ea, 0xab11),
-	.driver_info = (unsigned long) &ax88178_info,
-}, {
-	// ASIX 88772a
-	USB_DEVICE(0x0db0, 0xa877),
-	.driver_info = (unsigned long) &ax88772_info,
-}, {
-	// Asus USB Ethernet Adapter
-	USB_DEVICE (0x0b95, 0x7e2b),
-	.driver_info = (unsigned long)&ax88772b_info,
-}, {
-	/* ASIX 88172a demo board */
-	USB_DEVICE(0x0b95, 0x172a),
-	.driver_info = (unsigned long) &ax88172a_info,
-}, {
-	/*
-	 * USBLINK HG20F9 "USB 2.0 LAN"
-	 * Appears to have gazumped Linksys's manufacturer ID but
-	 * doesn't (yet) conflict with any known Linksys product.
-	 */
-	USB_DEVICE(0x066b, 0x20f9),
-	.driver_info = (unsigned long) &hg20f9_info,
-},
-	{ },		// END
-};
-MODULE_DEVICE_TABLE(usb, products);
-
-static struct usb_driver asix_driver = {
-	.name =		DRIVER_NAME,
-	.id_table =	products,
-	.probe =	usbnet_probe,
-	.suspend =	asix_suspend,
-	.resume =	asix_resume,
-	.reset_resume =	asix_resume,
-	.disconnect =	usbnet_disconnect,
-	.supports_autosuspend = 1,
-	.disable_hub_initiated_lpm = 1,
-};
-
-module_usb_driver(asix_driver);
-
-MODULE_AUTHOR("David Hollis");
-MODULE_VERSION(DRIVER_VERSION);
-MODULE_DESCRIPTION("ASIX AX8817X based USB 2.0 Ethernet Devices");
-MODULE_LICENSE("GPL");
-
diff --git a/drivers/net/usb/ax88172a.c b/drivers/net/usb/ax88172a.c
deleted file mode 100644
index 501576f..00000000
--- a/drivers/net/usb/ax88172a.c
+++ /dev/null
@@ -1,387 +0,0 @@
-/*
- * ASIX AX88172A based USB 2.0 Ethernet Devices
- * Copyright (C) 2012 OMICRON electronics GmbH
- *
- * Supports external PHYs via phylib. Based on the driver for the
- * AX88772. Original copyrights follow:
- *
- * Copyright (C) 2003-2006 David Hollis <dhollis@davehollis.com>
- * Copyright (C) 2005 Phil Chang <pchang23@sbcglobal.net>
- * Copyright (C) 2006 James Painter <jamie.painter@iname.com>
- * Copyright (c) 2002-2003 TiVo Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, see <http://www.gnu.org/licenses/>.
- */
-
-#include "asix.h"
-#include <linux/phy.h>
-
-struct ax88172a_private {
-	struct mii_bus *mdio;
-	struct phy_device *phydev;
-	char phy_name[20];
-	u16 phy_addr;
-	u16 oldmode;
-	int use_embdphy;
-	struct asix_rx_fixup_info rx_fixup_info;
-};
-
-/* MDIO read and write wrappers for phylib */
-static int asix_mdio_bus_read(struct mii_bus *bus, int phy_id, int regnum)
-{
-	return asix_mdio_read(((struct usbnet *)bus->priv)->net, phy_id,
-			      regnum);
-}
-
-static int asix_mdio_bus_write(struct mii_bus *bus, int phy_id, int regnum,
-			       u16 val)
-{
-	asix_mdio_write(((struct usbnet *)bus->priv)->net, phy_id, regnum, val);
-	return 0;
-}
-
-static int ax88172a_ioctl(struct net_device *net, struct ifreq *rq, int cmd)
-{
-	if (!netif_running(net))
-		return -EINVAL;
-
-	if (!net->phydev)
-		return -ENODEV;
-
-	return phy_mii_ioctl(net->phydev, rq, cmd);
-}
-
-/* set MAC link settings according to information from phylib */
-static void ax88172a_adjust_link(struct net_device *netdev)
-{
-	struct phy_device *phydev = netdev->phydev;
-	struct usbnet *dev = netdev_priv(netdev);
-	struct ax88172a_private *priv = dev->driver_priv;
-	u16 mode = 0;
-
-	if (phydev->link) {
-		mode = AX88772_MEDIUM_DEFAULT;
-
-		if (phydev->duplex == DUPLEX_HALF)
-			mode &= ~AX_MEDIUM_FD;
-
-		if (phydev->speed != SPEED_100)
-			mode &= ~AX_MEDIUM_PS;
-	}
-
-	if (mode != priv->oldmode) {
-		asix_write_medium_mode(dev, mode, 0);
-		priv->oldmode = mode;
-		netdev_dbg(netdev, "speed %u duplex %d, setting mode to 0x%04x\n",
-			   phydev->speed, phydev->duplex, mode);
-		phy_print_status(phydev);
-	}
-}
-
-static void ax88172a_status(struct usbnet *dev, struct urb *urb)
-{
-	/* link changes are detected by polling the phy */
-}
-
-/* use phylib infrastructure */
-static int ax88172a_init_mdio(struct usbnet *dev)
-{
-	struct ax88172a_private *priv = dev->driver_priv;
-	int ret;
-
-	priv->mdio = mdiobus_alloc();
-	if (!priv->mdio) {
-		netdev_err(dev->net, "Could not allocate MDIO bus\n");
-		return -ENOMEM;
-	}
-
-	priv->mdio->priv = (void *)dev;
-	priv->mdio->read = &asix_mdio_bus_read;
-	priv->mdio->write = &asix_mdio_bus_write;
-	priv->mdio->name = "Asix MDIO Bus";
-	/* mii bus name is usb-<usb bus number>-<usb device number> */
-	snprintf(priv->mdio->id, MII_BUS_ID_SIZE, "usb-%03d:%03d",
-		 dev->udev->bus->busnum, dev->udev->devnum);
-
-	ret = mdiobus_register(priv->mdio);
-	if (ret) {
-		netdev_err(dev->net, "Could not register MDIO bus\n");
-		goto mfree;
-	}
-
-	netdev_info(dev->net, "registered mdio bus %s\n", priv->mdio->id);
-	return 0;
-
-mfree:
-	mdiobus_free(priv->mdio);
-	return ret;
-}
-
-static void ax88172a_remove_mdio(struct usbnet *dev)
-{
-	struct ax88172a_private *priv = dev->driver_priv;
-
-	netdev_info(dev->net, "deregistering mdio bus %s\n", priv->mdio->id);
-	mdiobus_unregister(priv->mdio);
-	mdiobus_free(priv->mdio);
-}
-
-static const struct net_device_ops ax88172a_netdev_ops = {
-	.ndo_open		= usbnet_open,
-	.ndo_stop		= usbnet_stop,
-	.ndo_start_xmit		= usbnet_start_xmit,
-	.ndo_tx_timeout		= usbnet_tx_timeout,
-	.ndo_change_mtu		= usbnet_change_mtu,
-	.ndo_get_stats64	= usbnet_get_stats64,
-	.ndo_set_mac_address	= asix_set_mac_address,
-	.ndo_validate_addr	= eth_validate_addr,
-	.ndo_do_ioctl		= ax88172a_ioctl,
-	.ndo_set_rx_mode        = asix_set_multicast,
-};
-
-static const struct ethtool_ops ax88172a_ethtool_ops = {
-	.get_drvinfo		= asix_get_drvinfo,
-	.get_link		= usbnet_get_link,
-	.get_msglevel		= usbnet_get_msglevel,
-	.set_msglevel		= usbnet_set_msglevel,
-	.get_wol		= asix_get_wol,
-	.set_wol		= asix_set_wol,
-	.get_eeprom_len		= asix_get_eeprom_len,
-	.get_eeprom		= asix_get_eeprom,
-	.set_eeprom		= asix_set_eeprom,
-	.nway_reset		= phy_ethtool_nway_reset,
-	.get_link_ksettings	= phy_ethtool_get_link_ksettings,
-	.set_link_ksettings	= phy_ethtool_set_link_ksettings,
-};
-
-static int ax88172a_reset_phy(struct usbnet *dev, int embd_phy)
-{
-	int ret;
-
-	ret = asix_sw_reset(dev, AX_SWRESET_IPPD, 0);
-	if (ret < 0)
-		goto err;
-
-	msleep(150);
-	ret = asix_sw_reset(dev, AX_SWRESET_CLEAR, 0);
-	if (ret < 0)
-		goto err;
-
-	msleep(150);
-
-	ret = asix_sw_reset(dev, embd_phy ? AX_SWRESET_IPRL : AX_SWRESET_IPPD,
-			    0);
-	if (ret < 0)
-		goto err;
-
-	return 0;
-
-err:
-	return ret;
-}
-
-
-static int ax88172a_bind(struct usbnet *dev, struct usb_interface *intf)
-{
-	int ret;
-	u8 buf[ETH_ALEN];
-	struct ax88172a_private *priv;
-
-	usbnet_get_endpoints(dev, intf);
-
-	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
-	if (!priv)
-		return -ENOMEM;
-
-	dev->driver_priv = priv;
-
-	/* Get the MAC address */
-	ret = asix_read_cmd(dev, AX_CMD_READ_NODE_ID, 0, 0, ETH_ALEN, buf, 0);
-	if (ret < 0) {
-		netdev_err(dev->net, "Failed to read MAC address: %d\n", ret);
-		goto free;
-	}
-	memcpy(dev->net->dev_addr, buf, ETH_ALEN);
-
-	dev->net->netdev_ops = &ax88172a_netdev_ops;
-	dev->net->ethtool_ops = &ax88172a_ethtool_ops;
-
-	/* are we using the internal or the external phy? */
-	ret = asix_read_cmd(dev, AX_CMD_SW_PHY_STATUS, 0, 0, 1, buf, 0);
-	if (ret < 0) {
-		netdev_err(dev->net, "Failed to read software interface selection register: %d\n",
-			   ret);
-		goto free;
-	}
-
-	netdev_dbg(dev->net, "AX_CMD_SW_PHY_STATUS = 0x%02x\n", buf[0]);
-	switch (buf[0] & AX_PHY_SELECT_MASK) {
-	case AX_PHY_SELECT_INTERNAL:
-		netdev_dbg(dev->net, "use internal phy\n");
-		priv->use_embdphy = 1;
-		break;
-	case AX_PHY_SELECT_EXTERNAL:
-		netdev_dbg(dev->net, "use external phy\n");
-		priv->use_embdphy = 0;
-		break;
-	default:
-		netdev_err(dev->net, "Interface mode not supported by driver\n");
-		ret = -ENOTSUPP;
-		goto free;
-	}
-
-	priv->phy_addr = asix_read_phy_addr(dev, priv->use_embdphy);
-	ax88172a_reset_phy(dev, priv->use_embdphy);
-
-	/* Asix framing packs multiple eth frames into a 2K usb bulk transfer */
-	if (dev->driver_info->flags & FLAG_FRAMING_AX) {
-		/* hard_mtu  is still the default - the device does not support
-		   jumbo eth frames */
-		dev->rx_urb_size = 2048;
-	}
-
-	/* init MDIO bus */
-	ret = ax88172a_init_mdio(dev);
-	if (ret)
-		goto free;
-
-	return 0;
-
-free:
-	kfree(priv);
-	return ret;
-}
-
-static int ax88172a_stop(struct usbnet *dev)
-{
-	struct ax88172a_private *priv = dev->driver_priv;
-
-	netdev_dbg(dev->net, "Stopping interface\n");
-
-	if (priv->phydev) {
-		netdev_info(dev->net, "Disconnecting from phy %s\n",
-			    priv->phy_name);
-		phy_stop(priv->phydev);
-		phy_disconnect(priv->phydev);
-	}
-
-	return 0;
-}
-
-static void ax88172a_unbind(struct usbnet *dev, struct usb_interface *intf)
-{
-	struct ax88172a_private *priv = dev->driver_priv;
-
-	ax88172a_remove_mdio(dev);
-	kfree(priv);
-}
-
-static int ax88172a_reset(struct usbnet *dev)
-{
-	struct asix_data *data = (struct asix_data *)&dev->data;
-	struct ax88172a_private *priv = dev->driver_priv;
-	int ret;
-	u16 rx_ctl;
-
-	ax88172a_reset_phy(dev, priv->use_embdphy);
-
-	msleep(150);
-	rx_ctl = asix_read_rx_ctl(dev, 0);
-	netdev_dbg(dev->net, "RX_CTL is 0x%04x after software reset\n", rx_ctl);
-	ret = asix_write_rx_ctl(dev, 0x0000, 0);
-	if (ret < 0)
-		goto out;
-
-	rx_ctl = asix_read_rx_ctl(dev, 0);
-	netdev_dbg(dev->net, "RX_CTL is 0x%04x setting to 0x0000\n", rx_ctl);
-
-	msleep(150);
-
-	ret = asix_write_cmd(dev, AX_CMD_WRITE_IPG0,
-			     AX88772_IPG0_DEFAULT | AX88772_IPG1_DEFAULT,
-			     AX88772_IPG2_DEFAULT, 0, NULL, 0);
-	if (ret < 0) {
-		netdev_err(dev->net, "Write IPG,IPG1,IPG2 failed: %d\n", ret);
-		goto out;
-	}
-
-	/* Rewrite MAC address */
-	memcpy(data->mac_addr, dev->net->dev_addr, ETH_ALEN);
-	ret = asix_write_cmd(dev, AX_CMD_WRITE_NODE_ID, 0, 0, ETH_ALEN,
-			     data->mac_addr, 0);
-	if (ret < 0)
-		goto out;
-
-	/* Set RX_CTL to default values with 2k buffer, and enable cactus */
-	ret = asix_write_rx_ctl(dev, AX_DEFAULT_RX_CTL, 0);
-	if (ret < 0)
-		goto out;
-
-	rx_ctl = asix_read_rx_ctl(dev, 0);
-	netdev_dbg(dev->net, "RX_CTL is 0x%04x after all initializations\n",
-		   rx_ctl);
-
-	rx_ctl = asix_read_medium_status(dev, 0);
-	netdev_dbg(dev->net, "Medium Status is 0x%04x after all initializations\n",
-		   rx_ctl);
-
-	/* Connect to PHY */
-	snprintf(priv->phy_name, 20, PHY_ID_FMT,
-		 priv->mdio->id, priv->phy_addr);
-
-	priv->phydev = phy_connect(dev->net, priv->phy_name,
-				   &ax88172a_adjust_link,
-				   PHY_INTERFACE_MODE_MII);
-	if (IS_ERR(priv->phydev)) {
-		netdev_err(dev->net, "Could not connect to PHY device %s\n",
-			   priv->phy_name);
-		ret = PTR_ERR(priv->phydev);
-		goto out;
-	}
-
-	netdev_info(dev->net, "Connected to phy %s\n", priv->phy_name);
-
-	/* During power-up, the AX88172A set the power down (BMCR_PDOWN)
-	 * bit of the PHY. Bring the PHY up again.
-	 */
-	genphy_resume(priv->phydev);
-	phy_start(priv->phydev);
-
-	return 0;
-
-out:
-	return ret;
-
-}
-
-static int ax88172a_rx_fixup(struct usbnet *dev, struct sk_buff *skb)
-{
-	struct ax88172a_private *dp = dev->driver_priv;
-	struct asix_rx_fixup_info *rx = &dp->rx_fixup_info;
-
-	return asix_rx_fixup_internal(dev, skb, rx);
-}
-
-const struct driver_info ax88172a_info = {
-	.description = "ASIX AX88172A USB 2.0 Ethernet",
-	.bind = ax88172a_bind,
-	.reset = ax88172a_reset,
-	.stop = ax88172a_stop,
-	.unbind = ax88172a_unbind,
-	.status = ax88172a_status,
-	.flags = FLAG_ETHER | FLAG_FRAMING_AX | FLAG_LINK_INTR |
-		 FLAG_MULTI_PACKET,
-	.rx_fixup = ax88172a_rx_fixup,
-	.tx_fixup = asix_tx_fixup,
-};
diff --git a/drivers/net/usb/ax88179_178a.c b/drivers/net/usb/ax88179_178a.c
deleted file mode 100644
index 2207f7a..00000000
--- a/drivers/net/usb/ax88179_178a.c
+++ /dev/null
@@ -1,1795 +0,0 @@
-/*
- * ASIX AX88179/178A USB 3.0/2.0 to Gigabit Ethernet Devices
- *
- * Copyright (C) 2011-2013 ASIX
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <linux/module.h>
-#include <linux/etherdevice.h>
-#include <linux/mii.h>
-#include <linux/usb.h>
-#include <linux/crc32.h>
-#include <linux/usb/usbnet.h>
-#include <uapi/linux/mdio.h>
-#include <linux/mdio.h>
-
-#define AX88179_PHY_ID				0x03
-#define AX_EEPROM_LEN				0x100
-#define AX88179_EEPROM_MAGIC			0x17900b95
-#define AX_MCAST_FLTSIZE			8
-#define AX_MAX_MCAST				64
-#define AX_INT_PPLS_LINK			((u32)BIT(16))
-#define AX_RXHDR_L4_TYPE_MASK			0x1c
-#define AX_RXHDR_L4_TYPE_UDP			4
-#define AX_RXHDR_L4_TYPE_TCP			16
-#define AX_RXHDR_L3CSUM_ERR			2
-#define AX_RXHDR_L4CSUM_ERR			1
-#define AX_RXHDR_CRC_ERR			((u32)BIT(29))
-#define AX_RXHDR_DROP_ERR			((u32)BIT(31))
-#define AX_ACCESS_MAC				0x01
-#define AX_ACCESS_PHY				0x02
-#define AX_ACCESS_EEPROM			0x04
-#define AX_ACCESS_EFUS				0x05
-#define AX_PAUSE_WATERLVL_HIGH			0x54
-#define AX_PAUSE_WATERLVL_LOW			0x55
-
-#define PHYSICAL_LINK_STATUS			0x02
-	#define	AX_USB_SS		0x04
-	#define	AX_USB_HS		0x02
-
-#define GENERAL_STATUS				0x03
-/* Check AX88179 version. UA1:Bit2 = 0,  UA2:Bit2 = 1 */
-	#define	AX_SECLD		0x04
-
-#define AX_SROM_ADDR				0x07
-#define AX_SROM_CMD				0x0a
-	#define EEP_RD			0x04
-	#define EEP_BUSY		0x10
-
-#define AX_SROM_DATA_LOW			0x08
-#define AX_SROM_DATA_HIGH			0x09
-
-#define AX_RX_CTL				0x0b
-	#define AX_RX_CTL_DROPCRCERR	0x0100
-	#define AX_RX_CTL_IPE		0x0200
-	#define AX_RX_CTL_START		0x0080
-	#define AX_RX_CTL_AP		0x0020
-	#define AX_RX_CTL_AM		0x0010
-	#define AX_RX_CTL_AB		0x0008
-	#define AX_RX_CTL_AMALL		0x0002
-	#define AX_RX_CTL_PRO		0x0001
-	#define AX_RX_CTL_STOP		0x0000
-
-#define AX_NODE_ID				0x10
-#define AX_MULFLTARY				0x16
-
-#define AX_MEDIUM_STATUS_MODE			0x22
-	#define AX_MEDIUM_GIGAMODE	0x01
-	#define AX_MEDIUM_FULL_DUPLEX	0x02
-	#define AX_MEDIUM_EN_125MHZ	0x08
-	#define AX_MEDIUM_RXFLOW_CTRLEN	0x10
-	#define AX_MEDIUM_TXFLOW_CTRLEN	0x20
-	#define AX_MEDIUM_RECEIVE_EN	0x100
-	#define AX_MEDIUM_PS		0x200
-	#define AX_MEDIUM_JUMBO_EN	0x8040
-
-#define AX_MONITOR_MOD				0x24
-	#define AX_MONITOR_MODE_RWLC	0x02
-	#define AX_MONITOR_MODE_RWMP	0x04
-	#define AX_MONITOR_MODE_PMEPOL	0x20
-	#define AX_MONITOR_MODE_PMETYPE	0x40
-
-#define AX_GPIO_CTRL				0x25
-	#define AX_GPIO_CTRL_GPIO3EN	0x80
-	#define AX_GPIO_CTRL_GPIO2EN	0x40
-	#define AX_GPIO_CTRL_GPIO1EN	0x20
-
-#define AX_PHYPWR_RSTCTL			0x26
-	#define AX_PHYPWR_RSTCTL_BZ	0x0010
-	#define AX_PHYPWR_RSTCTL_IPRL	0x0020
-	#define AX_PHYPWR_RSTCTL_AT	0x1000
-
-#define AX_RX_BULKIN_QCTRL			0x2e
-#define AX_CLK_SELECT				0x33
-	#define AX_CLK_SELECT_BCS	0x01
-	#define AX_CLK_SELECT_ACS	0x02
-	#define AX_CLK_SELECT_ULR	0x08
-
-#define AX_RXCOE_CTL				0x34
-	#define AX_RXCOE_IP		0x01
-	#define AX_RXCOE_TCP		0x02
-	#define AX_RXCOE_UDP		0x04
-	#define AX_RXCOE_TCPV6		0x20
-	#define AX_RXCOE_UDPV6		0x40
-
-#define AX_TXCOE_CTL				0x35
-	#define AX_TXCOE_IP		0x01
-	#define AX_TXCOE_TCP		0x02
-	#define AX_TXCOE_UDP		0x04
-	#define AX_TXCOE_TCPV6		0x20
-	#define AX_TXCOE_UDPV6		0x40
-
-#define AX_LEDCTRL				0x73
-
-#define GMII_PHY_PHYSR				0x11
-	#define GMII_PHY_PHYSR_SMASK	0xc000
-	#define GMII_PHY_PHYSR_GIGA	0x8000
-	#define GMII_PHY_PHYSR_100	0x4000
-	#define GMII_PHY_PHYSR_FULL	0x2000
-	#define GMII_PHY_PHYSR_LINK	0x400
-
-#define GMII_LED_ACT				0x1a
-	#define	GMII_LED_ACTIVE_MASK	0xff8f
-	#define	GMII_LED0_ACTIVE	BIT(4)
-	#define	GMII_LED1_ACTIVE	BIT(5)
-	#define	GMII_LED2_ACTIVE	BIT(6)
-
-#define GMII_LED_LINK				0x1c
-	#define	GMII_LED_LINK_MASK	0xf888
-	#define	GMII_LED0_LINK_10	BIT(0)
-	#define	GMII_LED0_LINK_100	BIT(1)
-	#define	GMII_LED0_LINK_1000	BIT(2)
-	#define	GMII_LED1_LINK_10	BIT(4)
-	#define	GMII_LED1_LINK_100	BIT(5)
-	#define	GMII_LED1_LINK_1000	BIT(6)
-	#define	GMII_LED2_LINK_10	BIT(8)
-	#define	GMII_LED2_LINK_100	BIT(9)
-	#define	GMII_LED2_LINK_1000	BIT(10)
-	#define	LED0_ACTIVE		BIT(0)
-	#define	LED0_LINK_10		BIT(1)
-	#define	LED0_LINK_100		BIT(2)
-	#define	LED0_LINK_1000		BIT(3)
-	#define	LED0_FD			BIT(4)
-	#define	LED0_USB3_MASK		0x001f
-	#define	LED1_ACTIVE		BIT(5)
-	#define	LED1_LINK_10		BIT(6)
-	#define	LED1_LINK_100		BIT(7)
-	#define	LED1_LINK_1000		BIT(8)
-	#define	LED1_FD			BIT(9)
-	#define	LED1_USB3_MASK		0x03e0
-	#define	LED2_ACTIVE		BIT(10)
-	#define	LED2_LINK_1000		BIT(13)
-	#define	LED2_LINK_100		BIT(12)
-	#define	LED2_LINK_10		BIT(11)
-	#define	LED2_FD			BIT(14)
-	#define	LED_VALID		BIT(15)
-	#define	LED2_USB3_MASK		0x7c00
-
-#define GMII_PHYPAGE				0x1e
-#define GMII_PHY_PAGE_SELECT			0x1f
-	#define GMII_PHY_PGSEL_EXT	0x0007
-	#define GMII_PHY_PGSEL_PAGE0	0x0000
-	#define GMII_PHY_PGSEL_PAGE3	0x0003
-	#define GMII_PHY_PGSEL_PAGE5	0x0005
-
-struct ax88179_data {
-	u8  eee_enabled;
-	u8  eee_active;
-	u16 rxctl;
-	u16 reserved;
-};
-
-struct ax88179_int_data {
-	__le32 intdata1;
-	__le32 intdata2;
-};
-
-static const struct {
-	unsigned char ctrl, timer_l, timer_h, size, ifg;
-} AX88179_BULKIN_SIZE[] =	{
-	{7, 0x4f, 0,	0x12, 0xff},
-	{7, 0x20, 3,	0x16, 0xff},
-	{7, 0xae, 7,	0x18, 0xff},
-	{7, 0xcc, 0x4c, 0x18, 8},
-};
-
-static int __ax88179_read_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,
-			      u16 size, void *data, int in_pm)
-{
-	int ret;
-	int (*fn)(struct usbnet *, u8, u8, u16, u16, void *, u16);
-
-	BUG_ON(!dev);
-
-	if (!in_pm)
-		fn = usbnet_read_cmd;
-	else
-		fn = usbnet_read_cmd_nopm;
-
-	ret = fn(dev, cmd, USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-		 value, index, data, size);
-
-	if (unlikely(ret < 0))
-		netdev_warn(dev->net, "Failed to read reg index 0x%04x: %d\n",
-			    index, ret);
-
-	return ret;
-}
-
-static int __ax88179_write_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,
-			       u16 size, void *data, int in_pm)
-{
-	int ret;
-	int (*fn)(struct usbnet *, u8, u8, u16, u16, const void *, u16);
-
-	BUG_ON(!dev);
-
-	if (!in_pm)
-		fn = usbnet_write_cmd;
-	else
-		fn = usbnet_write_cmd_nopm;
-
-	ret = fn(dev, cmd, USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-		 value, index, data, size);
-
-	if (unlikely(ret < 0))
-		netdev_warn(dev->net, "Failed to write reg index 0x%04x: %d\n",
-			    index, ret);
-
-	return ret;
-}
-
-static void ax88179_write_cmd_async(struct usbnet *dev, u8 cmd, u16 value,
-				    u16 index, u16 size, void *data)
-{
-	u16 buf;
-
-	if (2 == size) {
-		buf = *((u16 *)data);
-		cpu_to_le16s(&buf);
-		usbnet_write_cmd_async(dev, cmd, USB_DIR_OUT | USB_TYPE_VENDOR |
-				       USB_RECIP_DEVICE, value, index, &buf,
-				       size);
-	} else {
-		usbnet_write_cmd_async(dev, cmd, USB_DIR_OUT | USB_TYPE_VENDOR |
-				       USB_RECIP_DEVICE, value, index, data,
-				       size);
-	}
-}
-
-static int ax88179_read_cmd_nopm(struct usbnet *dev, u8 cmd, u16 value,
-				 u16 index, u16 size, void *data)
-{
-	int ret;
-
-	if (2 == size) {
-		u16 buf;
-		ret = __ax88179_read_cmd(dev, cmd, value, index, size, &buf, 1);
-		le16_to_cpus(&buf);
-		*((u16 *)data) = buf;
-	} else if (4 == size) {
-		u32 buf;
-		ret = __ax88179_read_cmd(dev, cmd, value, index, size, &buf, 1);
-		le32_to_cpus(&buf);
-		*((u32 *)data) = buf;
-	} else {
-		ret = __ax88179_read_cmd(dev, cmd, value, index, size, data, 1);
-	}
-
-	return ret;
-}
-
-static int ax88179_write_cmd_nopm(struct usbnet *dev, u8 cmd, u16 value,
-				  u16 index, u16 size, void *data)
-{
-	int ret;
-
-	if (2 == size) {
-		u16 buf;
-		buf = *((u16 *)data);
-		cpu_to_le16s(&buf);
-		ret = __ax88179_write_cmd(dev, cmd, value, index,
-					  size, &buf, 1);
-	} else {
-		ret = __ax88179_write_cmd(dev, cmd, value, index,
-					  size, data, 1);
-	}
-
-	return ret;
-}
-
-static int ax88179_read_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,
-			    u16 size, void *data)
-{
-	int ret;
-
-	if (2 == size) {
-		u16 buf;
-		ret = __ax88179_read_cmd(dev, cmd, value, index, size, &buf, 0);
-		le16_to_cpus(&buf);
-		*((u16 *)data) = buf;
-	} else if (4 == size) {
-		u32 buf;
-		ret = __ax88179_read_cmd(dev, cmd, value, index, size, &buf, 0);
-		le32_to_cpus(&buf);
-		*((u32 *)data) = buf;
-	} else {
-		ret = __ax88179_read_cmd(dev, cmd, value, index, size, data, 0);
-	}
-
-	return ret;
-}
-
-static int ax88179_write_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,
-			     u16 size, void *data)
-{
-	int ret;
-
-	if (2 == size) {
-		u16 buf;
-		buf = *((u16 *)data);
-		cpu_to_le16s(&buf);
-		ret = __ax88179_write_cmd(dev, cmd, value, index,
-					  size, &buf, 0);
-	} else {
-		ret = __ax88179_write_cmd(dev, cmd, value, index,
-					  size, data, 0);
-	}
-
-	return ret;
-}
-
-static void ax88179_status(struct usbnet *dev, struct urb *urb)
-{
-	struct ax88179_int_data *event;
-	u32 link;
-
-	if (urb->actual_length < 8)
-		return;
-
-	event = urb->transfer_buffer;
-	le32_to_cpus((void *)&event->intdata1);
-
-	link = (((__force u32)event->intdata1) & AX_INT_PPLS_LINK) >> 16;
-
-	if (netif_carrier_ok(dev->net) != link) {
-		usbnet_link_change(dev, link, 1);
-		netdev_info(dev->net, "ax88179 - Link status is: %d\n", link);
-	}
-}
-
-static int ax88179_mdio_read(struct net_device *netdev, int phy_id, int loc)
-{
-	struct usbnet *dev = netdev_priv(netdev);
-	u16 res;
-
-	ax88179_read_cmd(dev, AX_ACCESS_PHY, phy_id, (__u16)loc, 2, &res);
-	return res;
-}
-
-static void ax88179_mdio_write(struct net_device *netdev, int phy_id, int loc,
-			       int val)
-{
-	struct usbnet *dev = netdev_priv(netdev);
-	u16 res = (u16) val;
-
-	ax88179_write_cmd(dev, AX_ACCESS_PHY, phy_id, (__u16)loc, 2, &res);
-}
-
-static inline int ax88179_phy_mmd_indirect(struct usbnet *dev, u16 prtad,
-					   u16 devad)
-{
-	u16 tmp16;
-	int ret;
-
-	tmp16 = devad;
-	ret = ax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
-				MII_MMD_CTRL, 2, &tmp16);
-
-	tmp16 = prtad;
-	ret = ax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
-				MII_MMD_DATA, 2, &tmp16);
-
-	tmp16 = devad | MII_MMD_CTRL_NOINCR;
-	ret = ax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
-				MII_MMD_CTRL, 2, &tmp16);
-
-	return ret;
-}
-
-static int
-ax88179_phy_read_mmd_indirect(struct usbnet *dev, u16 prtad, u16 devad)
-{
-	int ret;
-	u16 tmp16;
-
-	ax88179_phy_mmd_indirect(dev, prtad, devad);
-
-	ret = ax88179_read_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
-			       MII_MMD_DATA, 2, &tmp16);
-	if (ret < 0)
-		return ret;
-
-	return tmp16;
-}
-
-static int
-ax88179_phy_write_mmd_indirect(struct usbnet *dev, u16 prtad, u16 devad,
-			       u16 data)
-{
-	int ret;
-
-	ax88179_phy_mmd_indirect(dev, prtad, devad);
-
-	ret = ax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
-				MII_MMD_DATA, 2, &data);
-
-	if (ret < 0)
-		return ret;
-
-	return 0;
-}
-
-static int ax88179_suspend(struct usb_interface *intf, pm_message_t message)
-{
-	struct usbnet *dev = usb_get_intfdata(intf);
-	u16 tmp16;
-	u8 tmp8;
-
-	usbnet_suspend(intf, message);
-
-	/* Disable RX path */
-	ax88179_read_cmd_nopm(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
-			      2, 2, &tmp16);
-	tmp16 &= ~AX_MEDIUM_RECEIVE_EN;
-	ax88179_write_cmd_nopm(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
-			       2, 2, &tmp16);
-
-	/* Force bulk-in zero length */
-	ax88179_read_cmd_nopm(dev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL,
-			      2, 2, &tmp16);
-
-	tmp16 |= AX_PHYPWR_RSTCTL_BZ | AX_PHYPWR_RSTCTL_IPRL;
-	ax88179_write_cmd_nopm(dev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL,
-			       2, 2, &tmp16);
-
-	/* change clock */
-	tmp8 = 0;
-	ax88179_write_cmd_nopm(dev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, &tmp8);
-
-	/* Configure RX control register => stop operation */
-	tmp16 = AX_RX_CTL_STOP;
-	ax88179_write_cmd_nopm(dev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &tmp16);
-
-	return 0;
-}
-
-/* This function is used to enable the autodetach function. */
-/* This function is determined by offset 0x43 of EEPROM */
-static int ax88179_auto_detach(struct usbnet *dev, int in_pm)
-{
-	u16 tmp16;
-	u8 tmp8;
-	int (*fnr)(struct usbnet *, u8, u16, u16, u16, void *);
-	int (*fnw)(struct usbnet *, u8, u16, u16, u16, void *);
-
-	if (!in_pm) {
-		fnr = ax88179_read_cmd;
-		fnw = ax88179_write_cmd;
-	} else {
-		fnr = ax88179_read_cmd_nopm;
-		fnw = ax88179_write_cmd_nopm;
-	}
-
-	if (fnr(dev, AX_ACCESS_EEPROM, 0x43, 1, 2, &tmp16) < 0)
-		return 0;
-
-	if ((tmp16 == 0xFFFF) || (!(tmp16 & 0x0100)))
-		return 0;
-
-	/* Enable Auto Detach bit */
-	tmp8 = 0;
-	fnr(dev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, &tmp8);
-	tmp8 |= AX_CLK_SELECT_ULR;
-	fnw(dev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, &tmp8);
-
-	fnr(dev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, &tmp16);
-	tmp16 |= AX_PHYPWR_RSTCTL_AT;
-	fnw(dev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, &tmp16);
-
-	return 0;
-}
-
-static int ax88179_resume(struct usb_interface *intf)
-{
-	struct usbnet *dev = usb_get_intfdata(intf);
-	u16 tmp16;
-	u8 tmp8;
-
-	usbnet_link_change(dev, 0, 0);
-
-	/* Power up ethernet PHY */
-	tmp16 = 0;
-	ax88179_write_cmd_nopm(dev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL,
-			       2, 2, &tmp16);
-	udelay(1000);
-
-	tmp16 = AX_PHYPWR_RSTCTL_IPRL;
-	ax88179_write_cmd_nopm(dev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL,
-			       2, 2, &tmp16);
-	msleep(200);
-
-	/* Ethernet PHY Auto Detach*/
-	ax88179_auto_detach(dev, 1);
-
-	/* Enable clock */
-	ax88179_read_cmd_nopm(dev, AX_ACCESS_MAC,  AX_CLK_SELECT, 1, 1, &tmp8);
-	tmp8 |= AX_CLK_SELECT_ACS | AX_CLK_SELECT_BCS;
-	ax88179_write_cmd_nopm(dev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, &tmp8);
-	msleep(100);
-
-	/* Configure RX control register => start operation */
-	tmp16 = AX_RX_CTL_DROPCRCERR | AX_RX_CTL_IPE | AX_RX_CTL_START |
-		AX_RX_CTL_AP | AX_RX_CTL_AMALL | AX_RX_CTL_AB;
-	ax88179_write_cmd_nopm(dev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &tmp16);
-
-	return usbnet_resume(intf);
-}
-
-static void
-ax88179_get_wol(struct net_device *net, struct ethtool_wolinfo *wolinfo)
-{
-	struct usbnet *dev = netdev_priv(net);
-	u8 opt;
-
-	if (ax88179_read_cmd(dev, AX_ACCESS_MAC, AX_MONITOR_MOD,
-			     1, 1, &opt) < 0) {
-		wolinfo->supported = 0;
-		wolinfo->wolopts = 0;
-		return;
-	}
-
-	wolinfo->supported = WAKE_PHY | WAKE_MAGIC;
-	wolinfo->wolopts = 0;
-	if (opt & AX_MONITOR_MODE_RWLC)
-		wolinfo->wolopts |= WAKE_PHY;
-	if (opt & AX_MONITOR_MODE_RWMP)
-		wolinfo->wolopts |= WAKE_MAGIC;
-}
-
-static int
-ax88179_set_wol(struct net_device *net, struct ethtool_wolinfo *wolinfo)
-{
-	struct usbnet *dev = netdev_priv(net);
-	u8 opt = 0;
-
-	if (wolinfo->wolopts & ~(WAKE_PHY | WAKE_MAGIC))
-		return -EINVAL;
-
-	if (wolinfo->wolopts & WAKE_PHY)
-		opt |= AX_MONITOR_MODE_RWLC;
-	if (wolinfo->wolopts & WAKE_MAGIC)
-		opt |= AX_MONITOR_MODE_RWMP;
-
-	if (ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_MONITOR_MOD,
-			      1, 1, &opt) < 0)
-		return -EINVAL;
-
-	return 0;
-}
-
-static int ax88179_get_eeprom_len(struct net_device *net)
-{
-	return AX_EEPROM_LEN;
-}
-
-static int
-ax88179_get_eeprom(struct net_device *net, struct ethtool_eeprom *eeprom,
-		   u8 *data)
-{
-	struct usbnet *dev = netdev_priv(net);
-	u16 *eeprom_buff;
-	int first_word, last_word;
-	int i, ret;
-
-	if (eeprom->len == 0)
-		return -EINVAL;
-
-	eeprom->magic = AX88179_EEPROM_MAGIC;
-
-	first_word = eeprom->offset >> 1;
-	last_word = (eeprom->offset + eeprom->len - 1) >> 1;
-	eeprom_buff = kmalloc_array(last_word - first_word + 1, sizeof(u16),
-				    GFP_KERNEL);
-	if (!eeprom_buff)
-		return -ENOMEM;
-
-	/* ax88179/178A returns 2 bytes from eeprom on read */
-	for (i = first_word; i <= last_word; i++) {
-		ret = __ax88179_read_cmd(dev, AX_ACCESS_EEPROM, i, 1, 2,
-					 &eeprom_buff[i - first_word],
-					 0);
-		if (ret < 0) {
-			kfree(eeprom_buff);
-			return -EIO;
-		}
-	}
-
-	memcpy(data, (u8 *)eeprom_buff + (eeprom->offset & 1), eeprom->len);
-	kfree(eeprom_buff);
-	return 0;
-}
-
-static int ax88179_get_link_ksettings(struct net_device *net,
-				      struct ethtool_link_ksettings *cmd)
-{
-	struct usbnet *dev = netdev_priv(net);
-
-	mii_ethtool_get_link_ksettings(&dev->mii, cmd);
-
-	return 0;
-}
-
-static int ax88179_set_link_ksettings(struct net_device *net,
-				      const struct ethtool_link_ksettings *cmd)
-{
-	struct usbnet *dev = netdev_priv(net);
-	return mii_ethtool_set_link_ksettings(&dev->mii, cmd);
-}
-
-static int
-ax88179_ethtool_get_eee(struct usbnet *dev, struct ethtool_eee *data)
-{
-	int val;
-
-	/* Get Supported EEE */
-	val = ax88179_phy_read_mmd_indirect(dev, MDIO_PCS_EEE_ABLE,
-					    MDIO_MMD_PCS);
-	if (val < 0)
-		return val;
-	data->supported = mmd_eee_cap_to_ethtool_sup_t(val);
-
-	/* Get advertisement EEE */
-	val = ax88179_phy_read_mmd_indirect(dev, MDIO_AN_EEE_ADV,
-					    MDIO_MMD_AN);
-	if (val < 0)
-		return val;
-	data->advertised = mmd_eee_adv_to_ethtool_adv_t(val);
-
-	/* Get LP advertisement EEE */
-	val = ax88179_phy_read_mmd_indirect(dev, MDIO_AN_EEE_LPABLE,
-					    MDIO_MMD_AN);
-	if (val < 0)
-		return val;
-	data->lp_advertised = mmd_eee_adv_to_ethtool_adv_t(val);
-
-	return 0;
-}
-
-static int
-ax88179_ethtool_set_eee(struct usbnet *dev, struct ethtool_eee *data)
-{
-	u16 tmp16 = ethtool_adv_to_mmd_eee_adv_t(data->advertised);
-
-	return ax88179_phy_write_mmd_indirect(dev, MDIO_AN_EEE_ADV,
-					      MDIO_MMD_AN, tmp16);
-}
-
-static int ax88179_chk_eee(struct usbnet *dev)
-{
-	struct ethtool_cmd ecmd = { .cmd = ETHTOOL_GSET };
-	struct ax88179_data *priv = (struct ax88179_data *)dev->data;
-
-	mii_ethtool_gset(&dev->mii, &ecmd);
-
-	if (ecmd.duplex & DUPLEX_FULL) {
-		int eee_lp, eee_cap, eee_adv;
-		u32 lp, cap, adv, supported = 0;
-
-		eee_cap = ax88179_phy_read_mmd_indirect(dev,
-							MDIO_PCS_EEE_ABLE,
-							MDIO_MMD_PCS);
-		if (eee_cap < 0) {
-			priv->eee_active = 0;
-			return false;
-		}
-
-		cap = mmd_eee_cap_to_ethtool_sup_t(eee_cap);
-		if (!cap) {
-			priv->eee_active = 0;
-			return false;
-		}
-
-		eee_lp = ax88179_phy_read_mmd_indirect(dev,
-						       MDIO_AN_EEE_LPABLE,
-						       MDIO_MMD_AN);
-		if (eee_lp < 0) {
-			priv->eee_active = 0;
-			return false;
-		}
-
-		eee_adv = ax88179_phy_read_mmd_indirect(dev,
-							MDIO_AN_EEE_ADV,
-							MDIO_MMD_AN);
-
-		if (eee_adv < 0) {
-			priv->eee_active = 0;
-			return false;
-		}
-
-		adv = mmd_eee_adv_to_ethtool_adv_t(eee_adv);
-		lp = mmd_eee_adv_to_ethtool_adv_t(eee_lp);
-		supported = (ecmd.speed == SPEED_1000) ?
-			     SUPPORTED_1000baseT_Full :
-			     SUPPORTED_100baseT_Full;
-
-		if (!(lp & adv & supported)) {
-			priv->eee_active = 0;
-			return false;
-		}
-
-		priv->eee_active = 1;
-		return true;
-	}
-
-	priv->eee_active = 0;
-	return false;
-}
-
-static void ax88179_disable_eee(struct usbnet *dev)
-{
-	u16 tmp16;
-
-	tmp16 = GMII_PHY_PGSEL_PAGE3;
-	ax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
-			  GMII_PHY_PAGE_SELECT, 2, &tmp16);
-
-	tmp16 = 0x3246;
-	ax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
-			  MII_PHYADDR, 2, &tmp16);
-
-	tmp16 = GMII_PHY_PGSEL_PAGE0;
-	ax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
-			  GMII_PHY_PAGE_SELECT, 2, &tmp16);
-}
-
-static void ax88179_enable_eee(struct usbnet *dev)
-{
-	u16 tmp16;
-
-	tmp16 = GMII_PHY_PGSEL_PAGE3;
-	ax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
-			  GMII_PHY_PAGE_SELECT, 2, &tmp16);
-
-	tmp16 = 0x3247;
-	ax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
-			  MII_PHYADDR, 2, &tmp16);
-
-	tmp16 = GMII_PHY_PGSEL_PAGE5;
-	ax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
-			  GMII_PHY_PAGE_SELECT, 2, &tmp16);
-
-	tmp16 = 0x0680;
-	ax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
-			  MII_BMSR, 2, &tmp16);
-
-	tmp16 = GMII_PHY_PGSEL_PAGE0;
-	ax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
-			  GMII_PHY_PAGE_SELECT, 2, &tmp16);
-}
-
-static int ax88179_get_eee(struct net_device *net, struct ethtool_eee *edata)
-{
-	struct usbnet *dev = netdev_priv(net);
-	struct ax88179_data *priv = (struct ax88179_data *)dev->data;
-
-	edata->eee_enabled = priv->eee_enabled;
-	edata->eee_active = priv->eee_active;
-
-	return ax88179_ethtool_get_eee(dev, edata);
-}
-
-static int ax88179_set_eee(struct net_device *net, struct ethtool_eee *edata)
-{
-	struct usbnet *dev = netdev_priv(net);
-	struct ax88179_data *priv = (struct ax88179_data *)dev->data;
-	int ret = -EOPNOTSUPP;
-
-	priv->eee_enabled = edata->eee_enabled;
-	if (!priv->eee_enabled) {
-		ax88179_disable_eee(dev);
-	} else {
-		priv->eee_enabled = ax88179_chk_eee(dev);
-		if (!priv->eee_enabled)
-			return -EOPNOTSUPP;
-
-		ax88179_enable_eee(dev);
-	}
-
-	ret = ax88179_ethtool_set_eee(dev, edata);
-	if (ret)
-		return ret;
-
-	mii_nway_restart(&dev->mii);
-
-	usbnet_link_change(dev, 0, 0);
-
-	return ret;
-}
-
-static int ax88179_ioctl(struct net_device *net, struct ifreq *rq, int cmd)
-{
-	struct usbnet *dev = netdev_priv(net);
-	return generic_mii_ioctl(&dev->mii, if_mii(rq), cmd, NULL);
-}
-
-static const struct ethtool_ops ax88179_ethtool_ops = {
-	.get_link		= ethtool_op_get_link,
-	.get_msglevel		= usbnet_get_msglevel,
-	.set_msglevel		= usbnet_set_msglevel,
-	.get_wol		= ax88179_get_wol,
-	.set_wol		= ax88179_set_wol,
-	.get_eeprom_len		= ax88179_get_eeprom_len,
-	.get_eeprom		= ax88179_get_eeprom,
-	.get_eee		= ax88179_get_eee,
-	.set_eee		= ax88179_set_eee,
-	.nway_reset		= usbnet_nway_reset,
-	.get_link_ksettings	= ax88179_get_link_ksettings,
-	.set_link_ksettings	= ax88179_set_link_ksettings,
-};
-
-static void ax88179_set_multicast(struct net_device *net)
-{
-	struct usbnet *dev = netdev_priv(net);
-	struct ax88179_data *data = (struct ax88179_data *)dev->data;
-	u8 *m_filter = ((u8 *)dev->data) + 12;
-
-	data->rxctl = (AX_RX_CTL_START | AX_RX_CTL_AB | AX_RX_CTL_IPE);
-
-	if (net->flags & IFF_PROMISC) {
-		data->rxctl |= AX_RX_CTL_PRO;
-	} else if (net->flags & IFF_ALLMULTI ||
-		   netdev_mc_count(net) > AX_MAX_MCAST) {
-		data->rxctl |= AX_RX_CTL_AMALL;
-	} else if (netdev_mc_empty(net)) {
-		/* just broadcast and directed */
-	} else {
-		/* We use the 20 byte dev->data for our 8 byte filter buffer
-		 * to avoid allocating memory that is tricky to free later
-		 */
-		u32 crc_bits;
-		struct netdev_hw_addr *ha;
-
-		memset(m_filter, 0, AX_MCAST_FLTSIZE);
-
-		netdev_for_each_mc_addr(ha, net) {
-			crc_bits = ether_crc(ETH_ALEN, ha->addr) >> 26;
-			*(m_filter + (crc_bits >> 3)) |= (1 << (crc_bits & 7));
-		}
-
-		ax88179_write_cmd_async(dev, AX_ACCESS_MAC, AX_MULFLTARY,
-					AX_MCAST_FLTSIZE, AX_MCAST_FLTSIZE,
-					m_filter);
-
-		data->rxctl |= AX_RX_CTL_AM;
-	}
-
-	ax88179_write_cmd_async(dev, AX_ACCESS_MAC, AX_RX_CTL,
-				2, 2, &data->rxctl);
-}
-
-static int
-ax88179_set_features(struct net_device *net, netdev_features_t features)
-{
-	u8 tmp;
-	struct usbnet *dev = netdev_priv(net);
-	netdev_features_t changed = net->features ^ features;
-
-	if (changed & NETIF_F_IP_CSUM) {
-		ax88179_read_cmd(dev, AX_ACCESS_MAC, AX_TXCOE_CTL, 1, 1, &tmp);
-		tmp ^= AX_TXCOE_TCP | AX_TXCOE_UDP;
-		ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_TXCOE_CTL, 1, 1, &tmp);
-	}
-
-	if (changed & NETIF_F_IPV6_CSUM) {
-		ax88179_read_cmd(dev, AX_ACCESS_MAC, AX_TXCOE_CTL, 1, 1, &tmp);
-		tmp ^= AX_TXCOE_TCPV6 | AX_TXCOE_UDPV6;
-		ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_TXCOE_CTL, 1, 1, &tmp);
-	}
-
-	if (changed & NETIF_F_RXCSUM) {
-		ax88179_read_cmd(dev, AX_ACCESS_MAC, AX_RXCOE_CTL, 1, 1, &tmp);
-		tmp ^= AX_RXCOE_IP | AX_RXCOE_TCP | AX_RXCOE_UDP |
-		       AX_RXCOE_TCPV6 | AX_RXCOE_UDPV6;
-		ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RXCOE_CTL, 1, 1, &tmp);
-	}
-
-	return 0;
-}
-
-static int ax88179_change_mtu(struct net_device *net, int new_mtu)
-{
-	struct usbnet *dev = netdev_priv(net);
-	u16 tmp16;
-
-	net->mtu = new_mtu;
-	dev->hard_mtu = net->mtu + net->hard_header_len;
-
-	if (net->mtu > 1500) {
-		ax88179_read_cmd(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
-				 2, 2, &tmp16);
-		tmp16 |= AX_MEDIUM_JUMBO_EN;
-		ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
-				  2, 2, &tmp16);
-	} else {
-		ax88179_read_cmd(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
-				 2, 2, &tmp16);
-		tmp16 &= ~AX_MEDIUM_JUMBO_EN;
-		ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
-				  2, 2, &tmp16);
-	}
-
-	/* max qlen depend on hard_mtu and rx_urb_size */
-	usbnet_update_max_qlen(dev);
-
-	return 0;
-}
-
-static int ax88179_set_mac_addr(struct net_device *net, void *p)
-{
-	struct usbnet *dev = netdev_priv(net);
-	struct sockaddr *addr = p;
-	int ret;
-
-	if (netif_running(net))
-		return -EBUSY;
-	if (!is_valid_ether_addr(addr->sa_data))
-		return -EADDRNOTAVAIL;
-
-	memcpy(net->dev_addr, addr->sa_data, ETH_ALEN);
-
-	/* Set the MAC address */
-	ret = ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_NODE_ID, ETH_ALEN,
-				 ETH_ALEN, net->dev_addr);
-	if (ret < 0)
-		return ret;
-
-	return 0;
-}
-
-static const struct net_device_ops ax88179_netdev_ops = {
-	.ndo_open		= usbnet_open,
-	.ndo_stop		= usbnet_stop,
-	.ndo_start_xmit		= usbnet_start_xmit,
-	.ndo_tx_timeout		= usbnet_tx_timeout,
-	.ndo_get_stats64	= usbnet_get_stats64,
-	.ndo_change_mtu		= ax88179_change_mtu,
-	.ndo_set_mac_address	= ax88179_set_mac_addr,
-	.ndo_validate_addr	= eth_validate_addr,
-	.ndo_do_ioctl		= ax88179_ioctl,
-	.ndo_set_rx_mode	= ax88179_set_multicast,
-	.ndo_set_features	= ax88179_set_features,
-};
-
-static int ax88179_check_eeprom(struct usbnet *dev)
-{
-	u8 i, buf, eeprom[20];
-	u16 csum, delay = HZ / 10;
-	unsigned long jtimeout;
-
-	/* Read EEPROM content */
-	for (i = 0; i < 6; i++) {
-		buf = i;
-		if (ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_SROM_ADDR,
-				      1, 1, &buf) < 0)
-			return -EINVAL;
-
-		buf = EEP_RD;
-		if (ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_SROM_CMD,
-				      1, 1, &buf) < 0)
-			return -EINVAL;
-
-		jtimeout = jiffies + delay;
-		do {
-			ax88179_read_cmd(dev, AX_ACCESS_MAC, AX_SROM_CMD,
-					 1, 1, &buf);
-
-			if (time_after(jiffies, jtimeout))
-				return -EINVAL;
-
-		} while (buf & EEP_BUSY);
-
-		__ax88179_read_cmd(dev, AX_ACCESS_MAC, AX_SROM_DATA_LOW,
-				   2, 2, &eeprom[i * 2], 0);
-
-		if ((i == 0) && (eeprom[0] == 0xFF))
-			return -EINVAL;
-	}
-
-	csum = eeprom[6] + eeprom[7] + eeprom[8] + eeprom[9];
-	csum = (csum >> 8) + (csum & 0xff);
-	if ((csum + eeprom[10]) != 0xff)
-		return -EINVAL;
-
-	return 0;
-}
-
-static int ax88179_check_efuse(struct usbnet *dev, u16 *ledmode)
-{
-	u8	i;
-	u8	efuse[64];
-	u16	csum = 0;
-
-	if (ax88179_read_cmd(dev, AX_ACCESS_EFUS, 0, 64, 64, efuse) < 0)
-		return -EINVAL;
-
-	if (*efuse == 0xFF)
-		return -EINVAL;
-
-	for (i = 0; i < 64; i++)
-		csum = csum + efuse[i];
-
-	while (csum > 255)
-		csum = (csum & 0x00FF) + ((csum >> 8) & 0x00FF);
-
-	if (csum != 0xFF)
-		return -EINVAL;
-
-	*ledmode = (efuse[51] << 8) | efuse[52];
-
-	return 0;
-}
-
-static int ax88179_convert_old_led(struct usbnet *dev, u16 *ledvalue)
-{
-	u16 led;
-
-	/* Loaded the old eFuse LED Mode */
-	if (ax88179_read_cmd(dev, AX_ACCESS_EEPROM, 0x3C, 1, 2, &led) < 0)
-		return -EINVAL;
-
-	led >>= 8;
-	switch (led) {
-	case 0xFF:
-		led = LED0_ACTIVE | LED1_LINK_10 | LED1_LINK_100 |
-		      LED1_LINK_1000 | LED2_ACTIVE | LED2_LINK_10 |
-		      LED2_LINK_100 | LED2_LINK_1000 | LED_VALID;
-		break;
-	case 0xFE:
-		led = LED0_ACTIVE | LED1_LINK_1000 | LED2_LINK_100 | LED_VALID;
-		break;
-	case 0xFD:
-		led = LED0_ACTIVE | LED1_LINK_1000 | LED2_LINK_100 |
-		      LED2_LINK_10 | LED_VALID;
-		break;
-	case 0xFC:
-		led = LED0_ACTIVE | LED1_ACTIVE | LED1_LINK_1000 | LED2_ACTIVE |
-		      LED2_LINK_100 | LED2_LINK_10 | LED_VALID;
-		break;
-	default:
-		led = LED0_ACTIVE | LED1_LINK_10 | LED1_LINK_100 |
-		      LED1_LINK_1000 | LED2_ACTIVE | LED2_LINK_10 |
-		      LED2_LINK_100 | LED2_LINK_1000 | LED_VALID;
-		break;
-	}
-
-	*ledvalue = led;
-
-	return 0;
-}
-
-static int ax88179_led_setting(struct usbnet *dev)
-{
-	u8 ledfd, value = 0;
-	u16 tmp, ledact, ledlink, ledvalue = 0, delay = HZ / 10;
-	unsigned long jtimeout;
-
-	/* Check AX88179 version. UA1 or UA2*/
-	ax88179_read_cmd(dev, AX_ACCESS_MAC, GENERAL_STATUS, 1, 1, &value);
-
-	if (!(value & AX_SECLD)) {	/* UA1 */
-		value = AX_GPIO_CTRL_GPIO3EN | AX_GPIO_CTRL_GPIO2EN |
-			AX_GPIO_CTRL_GPIO1EN;
-		if (ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_GPIO_CTRL,
-				      1, 1, &value) < 0)
-			return -EINVAL;
-	}
-
-	/* Check EEPROM */
-	if (!ax88179_check_eeprom(dev)) {
-		value = 0x42;
-		if (ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_SROM_ADDR,
-				      1, 1, &value) < 0)
-			return -EINVAL;
-
-		value = EEP_RD;
-		if (ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_SROM_CMD,
-				      1, 1, &value) < 0)
-			return -EINVAL;
-
-		jtimeout = jiffies + delay;
-		do {
-			ax88179_read_cmd(dev, AX_ACCESS_MAC, AX_SROM_CMD,
-					 1, 1, &value);
-
-			if (time_after(jiffies, jtimeout))
-				return -EINVAL;
-
-		} while (value & EEP_BUSY);
-
-		ax88179_read_cmd(dev, AX_ACCESS_MAC, AX_SROM_DATA_HIGH,
-				 1, 1, &value);
-		ledvalue = (value << 8);
-
-		ax88179_read_cmd(dev, AX_ACCESS_MAC, AX_SROM_DATA_LOW,
-				 1, 1, &value);
-		ledvalue |= value;
-
-		/* load internal ROM for defaule setting */
-		if ((ledvalue == 0xFFFF) || ((ledvalue & LED_VALID) == 0))
-			ax88179_convert_old_led(dev, &ledvalue);
-
-	} else if (!ax88179_check_efuse(dev, &ledvalue)) {
-		if ((ledvalue == 0xFFFF) || ((ledvalue & LED_VALID) == 0))
-			ax88179_convert_old_led(dev, &ledvalue);
-	} else {
-		ax88179_convert_old_led(dev, &ledvalue);
-	}
-
-	tmp = GMII_PHY_PGSEL_EXT;
-	ax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
-			  GMII_PHY_PAGE_SELECT, 2, &tmp);
-
-	tmp = 0x2c;
-	ax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
-			  GMII_PHYPAGE, 2, &tmp);
-
-	ax88179_read_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
-			 GMII_LED_ACT, 2, &ledact);
-
-	ax88179_read_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
-			 GMII_LED_LINK, 2, &ledlink);
-
-	ledact &= GMII_LED_ACTIVE_MASK;
-	ledlink &= GMII_LED_LINK_MASK;
-
-	if (ledvalue & LED0_ACTIVE)
-		ledact |= GMII_LED0_ACTIVE;
-
-	if (ledvalue & LED1_ACTIVE)
-		ledact |= GMII_LED1_ACTIVE;
-
-	if (ledvalue & LED2_ACTIVE)
-		ledact |= GMII_LED2_ACTIVE;
-
-	if (ledvalue & LED0_LINK_10)
-		ledlink |= GMII_LED0_LINK_10;
-
-	if (ledvalue & LED1_LINK_10)
-		ledlink |= GMII_LED1_LINK_10;
-
-	if (ledvalue & LED2_LINK_10)
-		ledlink |= GMII_LED2_LINK_10;
-
-	if (ledvalue & LED0_LINK_100)
-		ledlink |= GMII_LED0_LINK_100;
-
-	if (ledvalue & LED1_LINK_100)
-		ledlink |= GMII_LED1_LINK_100;
-
-	if (ledvalue & LED2_LINK_100)
-		ledlink |= GMII_LED2_LINK_100;
-
-	if (ledvalue & LED0_LINK_1000)
-		ledlink |= GMII_LED0_LINK_1000;
-
-	if (ledvalue & LED1_LINK_1000)
-		ledlink |= GMII_LED1_LINK_1000;
-
-	if (ledvalue & LED2_LINK_1000)
-		ledlink |= GMII_LED2_LINK_1000;
-
-	tmp = ledact;
-	ax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
-			  GMII_LED_ACT, 2, &tmp);
-
-	tmp = ledlink;
-	ax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
-			  GMII_LED_LINK, 2, &tmp);
-
-	tmp = GMII_PHY_PGSEL_PAGE0;
-	ax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
-			  GMII_PHY_PAGE_SELECT, 2, &tmp);
-
-	/* LED full duplex setting */
-	ledfd = 0;
-	if (ledvalue & LED0_FD)
-		ledfd |= 0x01;
-	else if ((ledvalue & LED0_USB3_MASK) == 0)
-		ledfd |= 0x02;
-
-	if (ledvalue & LED1_FD)
-		ledfd |= 0x04;
-	else if ((ledvalue & LED1_USB3_MASK) == 0)
-		ledfd |= 0x08;
-
-	if (ledvalue & LED2_FD)
-		ledfd |= 0x10;
-	else if ((ledvalue & LED2_USB3_MASK) == 0)
-		ledfd |= 0x20;
-
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_LEDCTRL, 1, 1, &ledfd);
-
-	return 0;
-}
-
-static int ax88179_bind(struct usbnet *dev, struct usb_interface *intf)
-{
-	u8 buf[5];
-	u16 *tmp16;
-	u8 *tmp;
-	struct ax88179_data *ax179_data = (struct ax88179_data *)dev->data;
-	struct ethtool_eee eee_data;
-
-	usbnet_get_endpoints(dev, intf);
-
-	tmp16 = (u16 *)buf;
-	tmp = (u8 *)buf;
-
-	memset(ax179_data, 0, sizeof(*ax179_data));
-
-	/* Power up ethernet PHY */
-	*tmp16 = 0;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, tmp16);
-	*tmp16 = AX_PHYPWR_RSTCTL_IPRL;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, tmp16);
-	msleep(200);
-
-	*tmp = AX_CLK_SELECT_ACS | AX_CLK_SELECT_BCS;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, tmp);
-	msleep(100);
-
-	ax88179_read_cmd(dev, AX_ACCESS_MAC, AX_NODE_ID, ETH_ALEN,
-			 ETH_ALEN, dev->net->dev_addr);
-	memcpy(dev->net->perm_addr, dev->net->dev_addr, ETH_ALEN);
-
-	/* RX bulk configuration */
-	memcpy(tmp, &AX88179_BULKIN_SIZE[0], 5);
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RX_BULKIN_QCTRL, 5, 5, tmp);
-
-	dev->rx_urb_size = 1024 * 20;
-
-	*tmp = 0x34;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_PAUSE_WATERLVL_LOW, 1, 1, tmp);
-
-	*tmp = 0x52;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_PAUSE_WATERLVL_HIGH,
-			  1, 1, tmp);
-
-	dev->net->netdev_ops = &ax88179_netdev_ops;
-	dev->net->ethtool_ops = &ax88179_ethtool_ops;
-	dev->net->needed_headroom = 8;
-	dev->net->max_mtu = 4088;
-
-	/* Initialize MII structure */
-	dev->mii.dev = dev->net;
-	dev->mii.mdio_read = ax88179_mdio_read;
-	dev->mii.mdio_write = ax88179_mdio_write;
-	dev->mii.phy_id_mask = 0xff;
-	dev->mii.reg_num_mask = 0xff;
-	dev->mii.phy_id = 0x03;
-	dev->mii.supports_gmii = 1;
-
-	dev->net->features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |
-			      NETIF_F_RXCSUM;
-
-	dev->net->hw_features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |
-				 NETIF_F_RXCSUM;
-
-	/* Enable checksum offload */
-	*tmp = AX_RXCOE_IP | AX_RXCOE_TCP | AX_RXCOE_UDP |
-	       AX_RXCOE_TCPV6 | AX_RXCOE_UDPV6;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RXCOE_CTL, 1, 1, tmp);
-
-	*tmp = AX_TXCOE_IP | AX_TXCOE_TCP | AX_TXCOE_UDP |
-	       AX_TXCOE_TCPV6 | AX_TXCOE_UDPV6;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_TXCOE_CTL, 1, 1, tmp);
-
-	/* Configure RX control register => start operation */
-	*tmp16 = AX_RX_CTL_DROPCRCERR | AX_RX_CTL_IPE | AX_RX_CTL_START |
-		 AX_RX_CTL_AP | AX_RX_CTL_AMALL | AX_RX_CTL_AB;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, tmp16);
-
-	*tmp = AX_MONITOR_MODE_PMETYPE | AX_MONITOR_MODE_PMEPOL |
-	       AX_MONITOR_MODE_RWMP;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_MONITOR_MOD, 1, 1, tmp);
-
-	/* Configure default medium type => giga */
-	*tmp16 = AX_MEDIUM_RECEIVE_EN | AX_MEDIUM_TXFLOW_CTRLEN |
-		 AX_MEDIUM_RXFLOW_CTRLEN | AX_MEDIUM_FULL_DUPLEX |
-		 AX_MEDIUM_GIGAMODE;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
-			  2, 2, tmp16);
-
-	ax88179_led_setting(dev);
-
-	ax179_data->eee_enabled = 0;
-	ax179_data->eee_active = 0;
-
-	ax88179_disable_eee(dev);
-
-	ax88179_ethtool_get_eee(dev, &eee_data);
-	eee_data.advertised = 0;
-	ax88179_ethtool_set_eee(dev, &eee_data);
-
-	/* Restart autoneg */
-	mii_nway_restart(&dev->mii);
-
-	usbnet_link_change(dev, 0, 0);
-
-	return 0;
-}
-
-static void ax88179_unbind(struct usbnet *dev, struct usb_interface *intf)
-{
-	u16 tmp16;
-
-	/* Configure RX control register => stop operation */
-	tmp16 = AX_RX_CTL_STOP;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &tmp16);
-
-	tmp16 = 0;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, &tmp16);
-
-	/* Power down ethernet PHY */
-	tmp16 = 0;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, &tmp16);
-}
-
-static void
-ax88179_rx_checksum(struct sk_buff *skb, u32 *pkt_hdr)
-{
-	skb->ip_summed = CHECKSUM_NONE;
-
-	/* checksum error bit is set */
-	if ((*pkt_hdr & AX_RXHDR_L3CSUM_ERR) ||
-	    (*pkt_hdr & AX_RXHDR_L4CSUM_ERR))
-		return;
-
-	/* It must be a TCP or UDP packet with a valid checksum */
-	if (((*pkt_hdr & AX_RXHDR_L4_TYPE_MASK) == AX_RXHDR_L4_TYPE_TCP) ||
-	    ((*pkt_hdr & AX_RXHDR_L4_TYPE_MASK) == AX_RXHDR_L4_TYPE_UDP))
-		skb->ip_summed = CHECKSUM_UNNECESSARY;
-}
-
-static int ax88179_rx_fixup(struct usbnet *dev, struct sk_buff *skb)
-{
-	struct sk_buff *ax_skb;
-	int pkt_cnt;
-	u32 rx_hdr;
-	u16 hdr_off;
-	u32 *pkt_hdr;
-
-	/* This check is no longer done by usbnet */
-	if (skb->len < dev->net->hard_header_len)
-		return 0;
-
-	skb_trim(skb, skb->len - 4);
-	memcpy(&rx_hdr, skb_tail_pointer(skb), 4);
-	le32_to_cpus(&rx_hdr);
-
-	pkt_cnt = (u16)rx_hdr;
-	hdr_off = (u16)(rx_hdr >> 16);
-	pkt_hdr = (u32 *)(skb->data + hdr_off);
-
-	while (pkt_cnt--) {
-		u16 pkt_len;
-
-		le32_to_cpus(pkt_hdr);
-		pkt_len = (*pkt_hdr >> 16) & 0x1fff;
-
-		/* Check CRC or runt packet */
-		if ((*pkt_hdr & AX_RXHDR_CRC_ERR) ||
-		    (*pkt_hdr & AX_RXHDR_DROP_ERR)) {
-			skb_pull(skb, (pkt_len + 7) & 0xFFF8);
-			pkt_hdr++;
-			continue;
-		}
-
-		if (pkt_cnt == 0) {
-			/* Skip IP alignment psudo header */
-			skb_pull(skb, 2);
-			skb->len = pkt_len;
-			skb_set_tail_pointer(skb, pkt_len);
-			skb->truesize = pkt_len + sizeof(struct sk_buff);
-			ax88179_rx_checksum(skb, pkt_hdr);
-			return 1;
-		}
-
-		ax_skb = skb_clone(skb, GFP_ATOMIC);
-		if (ax_skb) {
-			ax_skb->len = pkt_len;
-			ax_skb->data = skb->data + 2;
-			skb_set_tail_pointer(ax_skb, pkt_len);
-			ax_skb->truesize = pkt_len + sizeof(struct sk_buff);
-			ax88179_rx_checksum(ax_skb, pkt_hdr);
-			usbnet_skb_return(dev, ax_skb);
-		} else {
-			return 0;
-		}
-
-		skb_pull(skb, (pkt_len + 7) & 0xFFF8);
-		pkt_hdr++;
-	}
-	return 1;
-}
-
-static struct sk_buff *
-ax88179_tx_fixup(struct usbnet *dev, struct sk_buff *skb, gfp_t flags)
-{
-	u32 tx_hdr1, tx_hdr2;
-	int frame_size = dev->maxpacket;
-	int mss = skb_shinfo(skb)->gso_size;
-	int headroom;
-
-	tx_hdr1 = skb->len;
-	tx_hdr2 = mss;
-	if (((skb->len + 8) % frame_size) == 0)
-		tx_hdr2 |= 0x80008000;	/* Enable padding */
-
-	headroom = skb_headroom(skb) - 8;
-
-	if ((skb_header_cloned(skb) || headroom < 0) &&
-	    pskb_expand_head(skb, headroom < 0 ? 8 : 0, 0, GFP_ATOMIC)) {
-		dev_kfree_skb_any(skb);
-		return NULL;
-	}
-
-	skb_push(skb, 4);
-	cpu_to_le32s(&tx_hdr2);
-	skb_copy_to_linear_data(skb, &tx_hdr2, 4);
-
-	skb_push(skb, 4);
-	cpu_to_le32s(&tx_hdr1);
-	skb_copy_to_linear_data(skb, &tx_hdr1, 4);
-
-	return skb;
-}
-
-static int ax88179_link_reset(struct usbnet *dev)
-{
-	struct ax88179_data *ax179_data = (struct ax88179_data *)dev->data;
-	u8 tmp[5], link_sts;
-	u16 mode, tmp16, delay = HZ / 10;
-	u32 tmp32 = 0x40000000;
-	unsigned long jtimeout;
-
-	jtimeout = jiffies + delay;
-	while (tmp32 & 0x40000000) {
-		mode = 0;
-		ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &mode);
-		ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2,
-				  &ax179_data->rxctl);
-
-		/*link up, check the usb device control TX FIFO full or empty*/
-		ax88179_read_cmd(dev, 0x81, 0x8c, 0, 4, &tmp32);
-
-		if (time_after(jiffies, jtimeout))
-			return 0;
-	}
-
-	mode = AX_MEDIUM_RECEIVE_EN | AX_MEDIUM_TXFLOW_CTRLEN |
-	       AX_MEDIUM_RXFLOW_CTRLEN;
-
-	ax88179_read_cmd(dev, AX_ACCESS_MAC, PHYSICAL_LINK_STATUS,
-			 1, 1, &link_sts);
-
-	ax88179_read_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
-			 GMII_PHY_PHYSR, 2, &tmp16);
-
-	if (!(tmp16 & GMII_PHY_PHYSR_LINK)) {
-		return 0;
-	} else if (GMII_PHY_PHYSR_GIGA == (tmp16 & GMII_PHY_PHYSR_SMASK)) {
-		mode |= AX_MEDIUM_GIGAMODE | AX_MEDIUM_EN_125MHZ;
-		if (dev->net->mtu > 1500)
-			mode |= AX_MEDIUM_JUMBO_EN;
-
-		if (link_sts & AX_USB_SS)
-			memcpy(tmp, &AX88179_BULKIN_SIZE[0], 5);
-		else if (link_sts & AX_USB_HS)
-			memcpy(tmp, &AX88179_BULKIN_SIZE[1], 5);
-		else
-			memcpy(tmp, &AX88179_BULKIN_SIZE[3], 5);
-	} else if (GMII_PHY_PHYSR_100 == (tmp16 & GMII_PHY_PHYSR_SMASK)) {
-		mode |= AX_MEDIUM_PS;
-
-		if (link_sts & (AX_USB_SS | AX_USB_HS))
-			memcpy(tmp, &AX88179_BULKIN_SIZE[2], 5);
-		else
-			memcpy(tmp, &AX88179_BULKIN_SIZE[3], 5);
-	} else {
-		memcpy(tmp, &AX88179_BULKIN_SIZE[3], 5);
-	}
-
-	/* RX bulk configuration */
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RX_BULKIN_QCTRL, 5, 5, tmp);
-
-	dev->rx_urb_size = (1024 * (tmp[3] + 2));
-
-	if (tmp16 & GMII_PHY_PHYSR_FULL)
-		mode |= AX_MEDIUM_FULL_DUPLEX;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
-			  2, 2, &mode);
-
-	ax179_data->eee_enabled = ax88179_chk_eee(dev);
-
-	netif_carrier_on(dev->net);
-
-	return 0;
-}
-
-static int ax88179_reset(struct usbnet *dev)
-{
-	u8 buf[5];
-	u16 *tmp16;
-	u8 *tmp;
-	struct ax88179_data *ax179_data = (struct ax88179_data *)dev->data;
-	struct ethtool_eee eee_data;
-
-	tmp16 = (u16 *)buf;
-	tmp = (u8 *)buf;
-
-	/* Power up ethernet PHY */
-	*tmp16 = 0;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, tmp16);
-
-	*tmp16 = AX_PHYPWR_RSTCTL_IPRL;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, tmp16);
-	msleep(200);
-
-	*tmp = AX_CLK_SELECT_ACS | AX_CLK_SELECT_BCS;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, tmp);
-	msleep(100);
-
-	/* Ethernet PHY Auto Detach*/
-	ax88179_auto_detach(dev, 0);
-
-	ax88179_read_cmd(dev, AX_ACCESS_MAC, AX_NODE_ID, ETH_ALEN, ETH_ALEN,
-			 dev->net->dev_addr);
-
-	/* RX bulk configuration */
-	memcpy(tmp, &AX88179_BULKIN_SIZE[0], 5);
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RX_BULKIN_QCTRL, 5, 5, tmp);
-
-	dev->rx_urb_size = 1024 * 20;
-
-	*tmp = 0x34;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_PAUSE_WATERLVL_LOW, 1, 1, tmp);
-
-	*tmp = 0x52;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_PAUSE_WATERLVL_HIGH,
-			  1, 1, tmp);
-
-	dev->net->features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |
-			      NETIF_F_RXCSUM;
-
-	dev->net->hw_features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |
-				 NETIF_F_RXCSUM;
-
-	/* Enable checksum offload */
-	*tmp = AX_RXCOE_IP | AX_RXCOE_TCP | AX_RXCOE_UDP |
-	       AX_RXCOE_TCPV6 | AX_RXCOE_UDPV6;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RXCOE_CTL, 1, 1, tmp);
-
-	*tmp = AX_TXCOE_IP | AX_TXCOE_TCP | AX_TXCOE_UDP |
-	       AX_TXCOE_TCPV6 | AX_TXCOE_UDPV6;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_TXCOE_CTL, 1, 1, tmp);
-
-	/* Configure RX control register => start operation */
-	*tmp16 = AX_RX_CTL_DROPCRCERR | AX_RX_CTL_IPE | AX_RX_CTL_START |
-		 AX_RX_CTL_AP | AX_RX_CTL_AMALL | AX_RX_CTL_AB;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, tmp16);
-
-	*tmp = AX_MONITOR_MODE_PMETYPE | AX_MONITOR_MODE_PMEPOL |
-	       AX_MONITOR_MODE_RWMP;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_MONITOR_MOD, 1, 1, tmp);
-
-	/* Configure default medium type => giga */
-	*tmp16 = AX_MEDIUM_RECEIVE_EN | AX_MEDIUM_TXFLOW_CTRLEN |
-		 AX_MEDIUM_RXFLOW_CTRLEN | AX_MEDIUM_FULL_DUPLEX |
-		 AX_MEDIUM_GIGAMODE;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
-			  2, 2, tmp16);
-
-	ax88179_led_setting(dev);
-
-	ax179_data->eee_enabled = 0;
-	ax179_data->eee_active = 0;
-
-	ax88179_disable_eee(dev);
-
-	ax88179_ethtool_get_eee(dev, &eee_data);
-	eee_data.advertised = 0;
-	ax88179_ethtool_set_eee(dev, &eee_data);
-
-	/* Restart autoneg */
-	mii_nway_restart(&dev->mii);
-
-	usbnet_link_change(dev, 0, 0);
-
-	return 0;
-}
-
-static int ax88179_stop(struct usbnet *dev)
-{
-	u16 tmp16;
-
-	ax88179_read_cmd(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
-			 2, 2, &tmp16);
-	tmp16 &= ~AX_MEDIUM_RECEIVE_EN;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
-			  2, 2, &tmp16);
-
-	return 0;
-}
-
-static const struct driver_info ax88179_info = {
-	.description = "ASIX AX88179 USB 3.0 Gigabit Ethernet",
-	.bind = ax88179_bind,
-	.unbind = ax88179_unbind,
-	.status = ax88179_status,
-	.link_reset = ax88179_link_reset,
-	.reset = ax88179_reset,
-	.stop = ax88179_stop,
-	.flags = FLAG_ETHER | FLAG_FRAMING_AX,
-	.rx_fixup = ax88179_rx_fixup,
-	.tx_fixup = ax88179_tx_fixup,
-};
-
-static const struct driver_info ax88178a_info = {
-	.description = "ASIX AX88178A USB 2.0 Gigabit Ethernet",
-	.bind = ax88179_bind,
-	.unbind = ax88179_unbind,
-	.status = ax88179_status,
-	.link_reset = ax88179_link_reset,
-	.reset = ax88179_reset,
-	.stop = ax88179_stop,
-	.flags = FLAG_ETHER | FLAG_FRAMING_AX,
-	.rx_fixup = ax88179_rx_fixup,
-	.tx_fixup = ax88179_tx_fixup,
-};
-
-static const struct driver_info cypress_GX3_info = {
-	.description = "Cypress GX3 SuperSpeed to Gigabit Ethernet Controller",
-	.bind = ax88179_bind,
-	.unbind = ax88179_unbind,
-	.status = ax88179_status,
-	.link_reset = ax88179_link_reset,
-	.reset = ax88179_reset,
-	.stop = ax88179_stop,
-	.flags = FLAG_ETHER | FLAG_FRAMING_AX,
-	.rx_fixup = ax88179_rx_fixup,
-	.tx_fixup = ax88179_tx_fixup,
-};
-
-static const struct driver_info dlink_dub1312_info = {
-	.description = "D-Link DUB-1312 USB 3.0 to Gigabit Ethernet Adapter",
-	.bind = ax88179_bind,
-	.unbind = ax88179_unbind,
-	.status = ax88179_status,
-	.link_reset = ax88179_link_reset,
-	.reset = ax88179_reset,
-	.stop = ax88179_stop,
-	.flags = FLAG_ETHER | FLAG_FRAMING_AX,
-	.rx_fixup = ax88179_rx_fixup,
-	.tx_fixup = ax88179_tx_fixup,
-};
-
-static const struct driver_info sitecom_info = {
-	.description = "Sitecom USB 3.0 to Gigabit Adapter",
-	.bind = ax88179_bind,
-	.unbind = ax88179_unbind,
-	.status = ax88179_status,
-	.link_reset = ax88179_link_reset,
-	.reset = ax88179_reset,
-	.stop = ax88179_stop,
-	.flags = FLAG_ETHER | FLAG_FRAMING_AX,
-	.rx_fixup = ax88179_rx_fixup,
-	.tx_fixup = ax88179_tx_fixup,
-};
-
-static const struct driver_info samsung_info = {
-	.description = "Samsung USB Ethernet Adapter",
-	.bind = ax88179_bind,
-	.unbind = ax88179_unbind,
-	.status = ax88179_status,
-	.link_reset = ax88179_link_reset,
-	.reset = ax88179_reset,
-	.stop = ax88179_stop,
-	.flags = FLAG_ETHER | FLAG_FRAMING_AX,
-	.rx_fixup = ax88179_rx_fixup,
-	.tx_fixup = ax88179_tx_fixup,
-};
-
-static const struct driver_info lenovo_info = {
-	.description = "Lenovo OneLinkDock Gigabit LAN",
-	.bind = ax88179_bind,
-	.unbind = ax88179_unbind,
-	.status = ax88179_status,
-	.link_reset = ax88179_link_reset,
-	.reset = ax88179_reset,
-	.stop = ax88179_stop,
-	.flags = FLAG_ETHER | FLAG_FRAMING_AX,
-	.rx_fixup = ax88179_rx_fixup,
-	.tx_fixup = ax88179_tx_fixup,
-};
-
-static const struct driver_info belkin_info = {
-	.description = "Belkin USB Ethernet Adapter",
-	.bind	= ax88179_bind,
-	.unbind = ax88179_unbind,
-	.status = ax88179_status,
-	.link_reset = ax88179_link_reset,
-	.reset	= ax88179_reset,
-	.flags	= FLAG_ETHER | FLAG_FRAMING_AX,
-	.rx_fixup = ax88179_rx_fixup,
-	.tx_fixup = ax88179_tx_fixup,
-};
-
-static const struct usb_device_id products[] = {
-{
-	/* ASIX AX88179 10/100/1000 */
-	USB_DEVICE(0x0b95, 0x1790),
-	.driver_info = (unsigned long)&ax88179_info,
-}, {
-	/* ASIX AX88178A 10/100/1000 */
-	USB_DEVICE(0x0b95, 0x178a),
-	.driver_info = (unsigned long)&ax88178a_info,
-}, {
-	/* Cypress GX3 SuperSpeed to Gigabit Ethernet Bridge Controller */
-	USB_DEVICE(0x04b4, 0x3610),
-	.driver_info = (unsigned long)&cypress_GX3_info,
-}, {
-	/* D-Link DUB-1312 USB 3.0 to Gigabit Ethernet Adapter */
-	USB_DEVICE(0x2001, 0x4a00),
-	.driver_info = (unsigned long)&dlink_dub1312_info,
-}, {
-	/* Sitecom USB 3.0 to Gigabit Adapter */
-	USB_DEVICE(0x0df6, 0x0072),
-	.driver_info = (unsigned long)&sitecom_info,
-}, {
-	/* Samsung USB Ethernet Adapter */
-	USB_DEVICE(0x04e8, 0xa100),
-	.driver_info = (unsigned long)&samsung_info,
-}, {
-	/* Lenovo OneLinkDock Gigabit LAN */
-	USB_DEVICE(0x17ef, 0x304b),
-	.driver_info = (unsigned long)&lenovo_info,
-}, {
-	/* Belkin B2B128 USB 3.0 Hub + Gigabit Ethernet Adapter */
-	USB_DEVICE(0x050d, 0x0128),
-	.driver_info = (unsigned long)&belkin_info,
-},
-	{ },
-};
-MODULE_DEVICE_TABLE(usb, products);
-
-static struct usb_driver ax88179_178a_driver = {
-	.name =		"ax88179_178a",
-	.id_table =	products,
-	.probe =	usbnet_probe,
-	.suspend =	ax88179_suspend,
-	.resume =	ax88179_resume,
-	.reset_resume =	ax88179_resume,
-	.disconnect =	usbnet_disconnect,
-	.supports_autosuspend = 1,
-	.disable_hub_initiated_lpm = 1,
-};
-
-module_usb_driver(ax88179_178a_driver);
-
-MODULE_DESCRIPTION("ASIX AX88179/178A based USB 3.0/2.0 Gigabit Ethernet Devices");
-MODULE_LICENSE("GPL");
diff --git a/drivers/net/usb/axusbnet.c b/drivers/net/usb/axusbnet.c
new file mode 100644
index 00000000..f2f9ea6
--- /dev/null
+++ b/drivers/net/usb/axusbnet.c
@@ -0,0 +1,1480 @@
+/*
+ * USB Network driver infrastructure
+ * Copyright (C) 2000-2005 by David Brownell
+ * Copyright (C) 2003-2005 David Hollis <dhollis@davehollis.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * This is a generic "USB networking" framework that works with several
+ * kinds of full and high speed networking devices:  host-to-host cables,
+ * smart usb peripherals, and actual Ethernet adapters.
+ *
+ * These devices usually differ in terms of control protocols (if they
+ * even have one!) and sometimes they define new framing to wrap or batch
+ * Ethernet packets.  Otherwise, they talk to USB pretty much the same,
+ * so interface (un)binding, endpoint I/O queues, fault handling, and other
+ * issues can usefully be addressed by this framework.
+ */
+
+/* error path messages, extra info */
+#define	DEBUG
+/* more; success messages */
+/* #define	VERBOSE	*/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/ctype.h>
+#include <linux/ethtool.h>
+#include <linux/workqueue.h>
+#include <linux/mii.h>
+#include <linux/usb.h>
+/*#include <linux/usb/usbnet.h>*/
+
+#include "asix.h"
+#include "axusbnet.h"
+
+#define DRIVER_VERSION		"22-Aug-2005"
+
+static void axusbnet_unlink_rx_urbs(struct usbnet *);
+
+static void
+ax8817x_write_cmd_async(struct usbnet *dev, u8 cmd, u16 value, u16 index,
+				    u16 size, void *data);
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * Nineteen USB 1.1 max size bulk transactions per frame (ms), max.
+ * Several dozen bytes of IPv4 data can fit in two such transactions.
+ * One maximum size Ethernet packet takes twenty four of them.
+ * For high speed, each frame comfortably fits almost 36 max size
+ * Ethernet packets (so queues should be bigger).
+ *
+ * REVISIT qlens should be members of 'struct usbnet'; the goal is to
+ * let the USB host controller be busy for 5msec or more before an irq
+ * is required, under load.  Jumbograms change the equation.
+ */
+#define RX_MAX_QUEUE_MEMORY (60 * 1518)
+#define	RX_QLEN(dev) (((dev)->udev->speed == USB_SPEED_HIGH) ? \
+			(RX_MAX_QUEUE_MEMORY/(dev)->rx_urb_size) : 4)
+#define	TX_QLEN(dev) (((dev)->udev->speed == USB_SPEED_HIGH) ? \
+			(RX_MAX_QUEUE_MEMORY/(dev)->hard_mtu) : 4)
+
+/* reawaken network queue this soon after stopping; else watchdog barks */
+/* #define TX_TIMEOUT_JIFFIES	(5 * HZ) */
+#define TX_TIMEOUT_JIFFIES	(30 * HZ)
+
+/* throttle rx/tx briefly after some faults, so khubd might disconnect() */
+/* us (it polls at HZ/4 usually) before we report too many false errors. */
+#define THROTTLE_JIFFIES	(HZ / 8)
+
+/* between wakeups */
+#define UNLINK_TIMEOUT_MS	3
+
+/*-------------------------------------------------------------------------*/
+
+static const char driver_name[] = "axusbnet";
+
+/* use ethtool to change the level for any given device */
+static int msg_level = -1;
+module_param(msg_level, int, 0);
+MODULE_PARM_DESC(msg_level, "Override default message level");
+
+/*-------------------------------------------------------------------------*/
+
+/* handles CDC Ethernet and many other network "bulk data" interfaces */
+static
+int axusbnet_get_endpoints(struct usbnet *dev, struct usb_interface *intf)
+{
+	int				tmp;
+	struct usb_host_interface	*alt = NULL;
+	struct usb_host_endpoint	*in = NULL, *out = NULL;
+	struct usb_host_endpoint	*status = NULL;
+
+	for (tmp = 0; tmp < intf->num_altsetting; tmp++) {
+		unsigned	ep;
+
+		in = out = status = NULL;
+		alt = intf->altsetting + tmp;
+
+		/* take the first altsetting with in-bulk + out-bulk;
+		 * remember any status endpoint, just in case;
+		 * ignore other endpoints and altsetttings.
+		 */
+		for (ep = 0; ep < alt->desc.bNumEndpoints; ep++) {
+			struct usb_host_endpoint	*e;
+			int				intr = 0;
+
+			e = alt->endpoint + ep;
+			switch (e->desc.bmAttributes) {
+			case USB_ENDPOINT_XFER_INT:
+				if (!(e->desc.bEndpointAddress & USB_DIR_IN))
+					continue;
+				intr = 1;
+				/* FALLTHROUGH */
+			case USB_ENDPOINT_XFER_BULK:
+				break;
+			default:
+				continue;
+			}
+			if (e->desc.bEndpointAddress & USB_DIR_IN) {
+				if (!intr && !in)
+					in = e;
+				else if (intr && !status)
+					status = e;
+			} else {
+				if (!out)
+					out = e;
+			}
+		}
+		if (in && out)
+			break;
+	}
+	if (!alt || !in || !out)
+		return -EINVAL;
+
+	if (alt->desc.bAlternateSetting != 0
+			|| !(dev->driver_info->flags & FLAG_NO_SETINT)) {
+		tmp = usb_set_interface(dev->udev, alt->desc.bInterfaceNumber,
+				alt->desc.bAlternateSetting);
+		if (tmp < 0)
+			return tmp;
+	}
+
+	dev->in = usb_rcvbulkpipe(dev->udev,
+			in->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);
+	dev->out = usb_sndbulkpipe(dev->udev,
+			out->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);
+	dev->status = status;
+	return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+static void intr_complete(struct urb *urb, struct pt_regs *regs);
+#else
+static void intr_complete(struct urb *urb);
+#endif
+
+static int init_status(struct usbnet *dev, struct usb_interface *intf)
+{
+	char		*buf = NULL;
+	unsigned	pipe = 0;
+	unsigned	maxp;
+	unsigned	period;
+
+	if (!dev->driver_info->status)
+		return 0;
+
+	pipe = usb_rcvintpipe(dev->udev,
+			dev->status->desc.bEndpointAddress
+				& USB_ENDPOINT_NUMBER_MASK);
+	maxp = usb_maxpacket(dev->udev, pipe, 0);
+
+	/* avoid 1 msec chatter:  min 8 msec poll rate */
+	period = max((int) dev->status->desc.bInterval,
+		(dev->udev->speed == USB_SPEED_HIGH) ? 7 : 3);
+
+	buf = kmalloc(maxp, GFP_KERNEL);
+	if (buf) {
+		dev->interrupt = usb_alloc_urb(0, GFP_KERNEL);
+		if (!dev->interrupt) {
+			kfree(buf);
+			return -ENOMEM;
+		} else {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 14)
+			dev->interrupt->transfer_flags |= URB_ASYNC_UNLINK;
+#endif
+			usb_fill_int_urb(dev->interrupt, dev->udev, pipe,
+				buf, maxp, intr_complete, dev, period);
+			devdbg(dev,
+			       "status ep%din, %d bytes period %d",
+			       usb_pipeendpoint(pipe), maxp, period);
+		}
+	}
+	return 0;
+}
+
+/* Passes this packet up the stack, updating its accounting.
+ * Some link protocols batch packets, so their rx_fixup paths
+ * can return clones as well as just modify the original skb.
+ */
+static
+void axusbnet_skb_return(struct usbnet *dev, struct sk_buff *skb)
+{
+	int	status;
+
+	skb->dev = dev->net;
+	skb->protocol = eth_type_trans(skb, dev->net);
+	dev->stats.rx_packets++;
+	dev->stats.rx_bytes += skb->len;
+
+	if (netif_msg_rx_status(dev))
+		devdbg(dev, "< rx, len %zu, type 0x%x",
+		       skb->len + sizeof(struct ethhdr), skb->protocol);
+	memset(skb->cb, 0, sizeof(struct skb_data));
+	status = netif_rx(skb);
+	if (status != NET_RX_SUCCESS && netif_msg_rx_err(dev))
+		devdbg(dev, "netif_rx status %d", status);
+}
+
+/*-------------------------------------------------------------------------
+ *
+ * Network Device Driver (peer link to "Host Device", from USB host)
+ *
+ *-------------------------------------------------------------------------*/
+
+static
+int axusbnet_change_mtu(struct net_device *net, int new_mtu)
+{
+	struct usbnet	*dev = netdev_priv(net);
+	int		ll_mtu = new_mtu + net->hard_header_len;
+	int		old_hard_mtu = dev->hard_mtu;
+	int		old_rx_urb_size = dev->rx_urb_size;
+
+	if (new_mtu <= 0)
+		return -EINVAL;
+	/* no second zero-length packet read wanted after mtu-sized packets */
+	if ((ll_mtu % dev->maxpacket) == 0)
+		return -EDOM;
+	net->mtu = new_mtu;
+
+	dev->hard_mtu = net->mtu + net->hard_header_len;
+	if (dev->rx_urb_size == old_hard_mtu) {
+		dev->rx_urb_size = dev->hard_mtu;
+		if (dev->rx_urb_size > old_rx_urb_size)
+			axusbnet_unlink_rx_urbs(dev);
+	}
+
+	return 0;
+}
+
+static struct net_device_stats *axusbnet_get_stats(struct net_device *net)
+{
+	struct usbnet *dev = netdev_priv(net);
+	return &dev->stats;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* some LK 2.4 HCDs oopsed if we freed or resubmitted urbs from
+ * completion callbacks.  2.5 should have fixed those bugs...
+ */
+
+static enum skb_state defer_bh(struct usbnet *dev, struct sk_buff *skb,
+                struct sk_buff_head *list, enum skb_state state)
+{
+        unsigned long           flags;
+        enum skb_state          old_state;
+        struct skb_data *entry = (struct skb_data *) skb->cb;
+
+        spin_lock_irqsave(&list->lock, flags);
+        old_state = entry->state;
+        entry->state = state;
+        __skb_unlink(skb, list);
+
+        /* defer_bh() is never called with list == &dev->done.
+         * spin_lock_nested() tells lockdep that it is OK to take
+         * dev->done.lock here with list->lock held.
+         */
+        spin_lock_nested(&dev->done.lock, SINGLE_DEPTH_NESTING);
+
+        __skb_queue_tail(&dev->done, skb);
+        if (dev->done.qlen == 1)
+                tasklet_schedule(&dev->bh);
+
+        spin_unlock(&dev->done.lock);
+        spin_unlock_irqrestore(&list->lock, flags);
+	
+        return old_state;
+}
+
+/* some work can't be done in tasklets, so we use keventd
+ *
+ * NOTE:  annoying asymmetry:  if it's active, schedule_work() fails,
+ * but tasklet_schedule() doesn't.  hope the failure is rare.
+ */
+static
+void axusbnet_defer_kevent(struct usbnet *dev, int work)
+{
+	set_bit(work, &dev->flags);
+	if (!schedule_work(&dev->kevent))
+		deverr(dev, "kevent %d may have been dropped", work);
+	else
+		devdbg(dev, "kevent %d scheduled", work);
+}
+
+/*-------------------------------------------------------------------------*/
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+static void rx_complete(struct urb *urb, struct pt_regs *regs);
+#else
+static void rx_complete(struct urb *urb);
+#endif
+
+static void rx_submit(struct usbnet *dev, struct urb *urb, gfp_t flags)
+{
+	struct sk_buff		*skb;
+	struct skb_data		*entry;
+	int			retval = 0;
+	unsigned long		lockflags;
+	size_t			size = dev->rx_urb_size;
+	struct driver_info	*info = dev->driver_info;
+	u8			align;
+
+	/* prevent rx skb allocation when error ratio is high */
+	if (test_bit(EVENT_RX_KILL, &dev->flags)) {
+		    usb_free_urb(urb);
+		    return;
+	}
+
+#if (AX_FORCE_BUFF_ALIGN)
+	align = 0;
+#else
+	if (!(info->flags & FLAG_HW_IP_ALIGNMENT))
+		align = NET_IP_ALIGN;
+	else
+		align = 0;
+#endif
+	skb = alloc_skb(size + align, flags);
+	if (skb == NULL) {
+
+		if (netif_msg_rx_err(dev))
+			devdbg(dev, "no rx skb");
+
+		if ((dev->rx_urb_size > 2048) && dev->rx_size) {
+			dev->rx_size--;
+			dev->rx_urb_size =
+				AX88772B_BULKIN_SIZE[dev->rx_size].size;
+
+			ax8817x_write_cmd_async(dev, 0x2A,
+				AX88772B_BULKIN_SIZE[dev->rx_size].byte_cnt,
+				AX88772B_BULKIN_SIZE[dev->rx_size].threshold,
+				0, NULL);
+		}
+
+		if (!(dev->flags & EVENT_RX_MEMORY))
+			axusbnet_defer_kevent(dev, EVENT_RX_MEMORY);
+		usb_free_urb(urb);
+		return;
+	}
+
+	if (align)
+		skb_reserve(skb, NET_IP_ALIGN);
+
+	entry = (struct skb_data *) skb->cb;
+	entry->urb = urb;
+	entry->dev = dev;
+	entry->state = rx_start;
+	entry->length = 0;
+
+	usb_fill_bulk_urb(urb, dev->udev, dev->in, skb->data,
+			  size, rx_complete, skb);
+
+	spin_lock_irqsave(&dev->rxq.lock, lockflags);
+
+	if (netif_running(dev->net)
+			&& netif_device_present(dev->net)
+			&& !test_bit(EVENT_RX_HALT, &dev->flags)) {
+		switch (retval = usb_submit_urb(urb, GFP_ATOMIC)) {
+		case -EPIPE:
+			axusbnet_defer_kevent(dev, EVENT_RX_HALT);
+			break;
+		case -ENOMEM:
+			axusbnet_defer_kevent(dev, EVENT_RX_MEMORY);
+			break;
+		case -ENODEV:
+			if (netif_msg_ifdown(dev))
+				devdbg(dev, "device gone");
+			netif_device_detach(dev->net);
+			break;
+		default:
+			if (netif_msg_rx_err(dev))
+				devdbg(dev, "rx submit, %d", retval);
+			tasklet_schedule(&dev->bh);
+			break;
+		case 0:
+			__skb_queue_tail(&dev->rxq, skb);
+		}
+	} else {
+		if (netif_msg_ifdown(dev))
+			devdbg(dev, "rx: stopped");
+		retval = -ENOLINK;
+	}
+	spin_unlock_irqrestore(&dev->rxq.lock, lockflags);
+	if (retval) {
+		dev_kfree_skb_any(skb);
+		usb_free_urb(urb);
+	}
+}
+
+
+/*-------------------------------------------------------------------------*/
+
+static inline void rx_process(struct usbnet *dev, struct sk_buff *skb)
+{
+	if (dev->driver_info->rx_fixup
+			&& !dev->driver_info->rx_fixup(dev, skb))
+		goto error;
+	/* else network stack removes extra byte if we forced a short packet */
+
+	if (skb->len)
+		axusbnet_skb_return(dev, skb);
+	else {
+		if (netif_msg_rx_err(dev))
+			devdbg(dev, "drop");
+error:
+		dev->stats.rx_errors++;
+		skb_queue_tail(&dev->done, skb);
+	}
+}
+
+/*-------------------------------------------------------------------------*/
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+static void rx_complete(struct urb *urb, struct pt_regs *regs)
+#else
+static void rx_complete(struct urb *urb)
+#endif
+{
+	struct sk_buff		*skb = (struct sk_buff *) urb->context;
+	struct skb_data		*entry = (struct skb_data *) skb->cb;
+	struct usbnet		*dev = entry->dev;
+	int			urb_status = urb->status;
+	enum skb_state          state;
+
+	skb_put(skb, urb->actual_length);
+	state = rx_done;
+	entry->urb = NULL;
+
+	switch (urb_status) {
+	/* success */
+	case 0:
+		if (skb->len < dev->net->hard_header_len) {
+			entry->state = rx_cleanup;
+			dev->stats.rx_errors++;
+			dev->stats.rx_length_errors++;
+			if (netif_msg_rx_err(dev))
+				devdbg(dev, "rx length %d", skb->len);
+		}
+		break;
+
+	/* stalls need manual reset. this is rare ... except that
+	 * when going through USB 2.0 TTs, unplug appears this way.
+	 * we avoid the highspeed version of the ETIMEDOUT/EILSEQ
+	 * storm, recovering as needed.
+	 */
+	case -EPIPE:
+		dev->stats.rx_errors++;
+		axusbnet_defer_kevent(dev, EVENT_RX_HALT);
+		/* FALLTHROUGH */
+
+	/* software-driven interface shutdown */
+	case -ECONNRESET:		/* async unlink */
+	case -ESHUTDOWN:		/* hardware gone */
+		if (netif_msg_ifdown(dev))
+			devdbg(dev, "rx shutdown, code %d", urb_status);
+		goto block;
+
+	/* we get controller i/o faults during khubd disconnect() delays.
+	 * throttle down resubmits, to avoid log floods; just temporarily,
+	 * so we still recover when the fault isn't a khubd delay.
+	 */
+	case -EPROTO:
+	case -ETIME:
+	case -EILSEQ:
+		dev->stats.rx_errors++;
+		if (!timer_pending(&dev->delay)) {
+			mod_timer(&dev->delay, jiffies + THROTTLE_JIFFIES);
+			if (netif_msg_link(dev))
+				devdbg(dev, "rx throttle %d", urb_status);
+		}
+block:
+		state = rx_cleanup;
+		entry->urb = urb;
+		urb = NULL;
+		break;
+
+	/* data overrun ... flush fifo? */
+	case -EOVERFLOW:
+		dev->stats.rx_over_errors++;
+		/* FALLTHROUGH */
+
+	default:
+		state = rx_cleanup;
+		dev->stats.rx_errors++;
+		if (netif_msg_rx_err(dev))
+			devdbg(dev, "rx status %d", urb_status);
+		break;
+	}
+
+	/* stop rx if packet error rate is high */
+        if (++dev->pkt_cnt > 30) {
+                dev->pkt_cnt = 0;
+                dev->pkt_err = 0;
+        } else {
+                if (state == rx_cleanup)
+                        dev->pkt_err++;
+                if (dev->pkt_err > 20)
+                        set_bit(EVENT_RX_KILL, &dev->flags);
+        }
+
+	state = defer_bh(dev, skb, &dev->rxq, state);
+
+	if (urb) {
+		if (netif_running(dev->net) &&
+		    !test_bit(EVENT_RX_HALT, &dev->flags) &&
+			 state != unlink_start) {
+			rx_submit(dev, urb, GFP_ATOMIC);
+			return;
+		}
+		usb_free_urb(urb);
+	}
+	if (netif_msg_rx_err(dev))
+		devdbg(dev, "no read resubmitted");
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+static void intr_complete(struct urb *urb, struct pt_regs *regs)
+#else
+static void intr_complete(struct urb *urb)
+#endif
+{
+	struct usbnet	*dev = urb->context;
+	int		status = urb->status;
+
+	switch (status) {
+	/* success */
+	case 0:
+		dev->driver_info->status(dev, urb);
+		break;
+
+	/* software-driven interface shutdown */
+	case -ENOENT:		/* urb killed */
+	case -ESHUTDOWN:	/* hardware gone */
+		if (netif_msg_ifdown(dev))
+			devdbg(dev, "intr shutdown, code %d", status);
+		return;
+
+	/* NOTE:  not throttling like RX/TX, since this endpoint
+	 * already polls infrequently
+	 */
+	default:
+		devdbg(dev, "intr status %d", status);
+		break;
+	}
+
+	if (!netif_running(dev->net))
+		return;
+
+	memset(urb->transfer_buffer, 0, urb->transfer_buffer_length);
+	status = usb_submit_urb(urb, GFP_ATOMIC);
+	if (status != 0 && netif_msg_timer(dev))
+		deverr(dev, "intr resubmit --> %d", status);
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* unlink pending rx/tx; completion handlers do all other cleanup */
+
+static int unlink_urbs (struct usbnet *dev, struct sk_buff_head *q)
+{
+        unsigned long           flags;
+        struct sk_buff          *skb = NULL;
+        int                     count = 0;
+
+        spin_lock_irqsave (&q->lock, flags);
+        while (!skb_queue_empty(q)) {
+                struct skb_data         *entry;
+                struct urb              *urb;
+                int                     retval;
+
+                skb_queue_walk(q, skb) {
+                        entry = (struct skb_data *) skb->cb;
+                        if (entry->state != unlink_start)
+                                goto found;
+                }
+                break;
+found:
+                entry->state = unlink_start;
+                urb = entry->urb;
+
+                /*
+                 * Get reference count of the URB to avoid it to be
+                 * freed during usb_unlink_urb, which may trigger
+                 * use-after-free problem inside usb_unlink_urb since
+                 * usb_unlink_urb is always racing with .complete
+                 * handler(include defer_bh).
+                 */
+                usb_get_urb(urb);
+                spin_unlock_irqrestore(&q->lock, flags);
+                // during some PM-driven resume scenarios,
+                // these (async) unlinks complete immediately
+                retval = usb_unlink_urb (urb);
+                if (retval != -EINPROGRESS && retval != 0)
+                        printk(DEBUG "unlink urb err, %d\n", retval);
+                else
+                        count++;
+                usb_put_urb(urb);
+                spin_lock_irqsave(&q->lock, flags);
+        }
+        spin_unlock_irqrestore (&q->lock, flags);
+
+        return count;
+}
+
+/* Flush all pending rx urbs */
+/* minidrivers may need to do this when the MTU changes */
+
+static
+void axusbnet_unlink_rx_urbs(struct usbnet *dev)
+{
+	if (netif_running(dev->net)) {
+		(void) unlink_urbs(dev, &dev->rxq);
+		tasklet_schedule(&dev->bh);
+	}
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* precondition: never called in_interrupt */
+
+static
+int axusbnet_stop(struct net_device *net)
+{
+	struct usbnet		*dev = netdev_priv(net);
+	struct driver_info	*info = dev->driver_info;	
+	
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 18)
+	DECLARE_WAIT_QUEUE_HEAD_ONSTACK(unlink_wakeup);
+#else
+	DECLARE_WAIT_QUEUE_HEAD(unlink_wakeup);
+#endif
+	DECLARE_WAITQUEUE(wait, current);
+
+	netif_stop_queue(net);
+
+	if (netif_msg_ifdown(dev))
+		devinfo(dev, "stop stats: rx/tx %ld/%ld, errs %ld/%ld",
+			dev->stats.rx_packets, dev->stats.tx_packets,
+			dev->stats.rx_errors, dev->stats.tx_errors);
+
+	/* allow minidriver to stop correctly (wireless devices to turn off
+	 * radio etc) */
+	if (info->stop) {
+		int retval;
+		retval = info->stop(dev);
+		if (retval < 0 && netif_msg_ifdown(dev))
+			devinfo(dev,
+				"stop fail (%d) usbnet usb-%s-%s, %s",
+				retval,
+				dev->udev->bus->bus_name, dev->udev->devpath,
+				info->description);
+	}
+
+	if (!(info->flags & FLAG_AVOID_UNLINK_URBS)) {
+		int temp;
+		/* ensure there are no more active urbs */
+		add_wait_queue(&unlink_wakeup, &wait);
+		dev->wait = &unlink_wakeup;
+		temp = unlink_urbs(dev, &dev->txq) +
+			unlink_urbs(dev, &dev->rxq);
+
+		/* maybe wait for deletions to finish. */
+		while (!skb_queue_empty(&dev->rxq)
+				&& !skb_queue_empty(&dev->txq)
+				&& !skb_queue_empty(&dev->done)) {
+			msleep(UNLINK_TIMEOUT_MS);
+			if (netif_msg_ifdown(dev))
+				devdbg(dev, "waited for %d urb completions",
+				       temp);
+		}
+		dev->wait = NULL;
+		remove_wait_queue(&unlink_wakeup, &wait);
+	}
+
+	usb_kill_urb(dev->interrupt);
+
+	/* deferred work (task, timer, softirq) must also stop.
+	 * can't flush_scheduled_work() until we drop rtnl (later),
+	 * else workers could deadlock; so make workers a NOP.
+	 */
+	dev->flags = 0;
+	del_timer_sync(&dev->delay);
+	tasklet_kill(&dev->bh);
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* posts reads, and enables write queuing */
+
+/* precondition: never called in_interrupt */
+
+static
+int axusbnet_open(struct net_device *net)
+{
+	struct usbnet		*dev = netdev_priv(net);
+	int			retval = 0;
+	struct driver_info	*info = dev->driver_info;
+
+	/* put into "known safe" state */
+	if (info->reset) {
+		retval = info->reset(dev);
+		if (retval < 0) {
+			if (netif_msg_ifup(dev))
+				devinfo(dev,
+					"open reset fail (%d) usbnet usb-%s-%s, %s",
+					retval,
+					dev->udev->bus->bus_name,
+					dev->udev->devpath,
+					info->description);
+			goto done;
+		}
+	}
+
+	/* insist peer be connected */
+	if (info->check_connect) {
+		retval = info->check_connect(dev);
+		if (retval < 0) {
+			if (netif_msg_ifup(dev))
+				devdbg(dev, "can't open; %d", retval);
+			goto done;
+		}
+	}
+
+	/* start any status interrupt transfer */
+	if (dev->interrupt) {
+		retval = usb_submit_urb(dev->interrupt, GFP_KERNEL);
+		if (retval < 0) {
+			if (netif_msg_ifup(dev))
+				deverr(dev, "intr submit %d", retval);
+			goto done;
+		}
+	}
+
+	/* reset rx error state */
+    dev->pkt_cnt = 0;
+    dev->pkt_err = 0;
+	clear_bit(EVENT_RX_KILL, &dev->flags);
+
+	netif_start_queue(net);
+	if (netif_msg_ifup(dev)) {
+		char	*framing;
+
+		if (dev->driver_info->flags & FLAG_FRAMING_NC)
+			framing = "NetChip";
+		else if (dev->driver_info->flags & FLAG_FRAMING_GL)
+			framing = "GeneSys";
+		else if (dev->driver_info->flags & FLAG_FRAMING_Z)
+			framing = "Zaurus";
+		else if (dev->driver_info->flags & FLAG_FRAMING_RN)
+			framing = "RNDIS";
+		else if (dev->driver_info->flags & FLAG_FRAMING_AX)
+			framing = "ASIX";
+		else
+			framing = "simple";
+
+		devinfo(dev, "open: enable queueing (rx %d, tx %d) mtu %d %s framing",
+			(int)RX_QLEN(dev), (int)TX_QLEN(dev), dev->net->mtu,
+			framing);
+	}
+
+	/* delay posting reads until we're fully open */
+	tasklet_schedule(&dev->bh);
+	return retval;
+done:
+	return retval;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* ethtool methods; minidrivers may need to add some more, but
+ * they'll probably want to use this base set.
+ */
+
+static
+int axusbnet_get_settings(struct net_device *net, struct ethtool_cmd *cmd)
+{
+	struct usbnet *dev = netdev_priv(net);
+
+	if (!dev->mii.mdio_read)
+		return -EOPNOTSUPP;
+
+	return mii_ethtool_gset(&dev->mii, cmd);
+}
+
+static
+int axusbnet_set_settings(struct net_device *net, struct ethtool_cmd *cmd)
+{
+	struct usbnet *dev = netdev_priv(net);
+	int retval;
+
+	if (!dev->mii.mdio_write)
+		return -EOPNOTSUPP;
+
+	retval = mii_ethtool_sset(&dev->mii, cmd);
+
+	/* link speed/duplex might have changed */
+	if (dev->driver_info->link_reset)
+		dev->driver_info->link_reset(dev);
+
+	return retval;
+
+}
+
+static
+u32 axusbnet_get_link(struct net_device *net)
+{
+	struct usbnet *dev = netdev_priv(net);
+
+	/* If a check_connect is defined, return its result */
+	if (dev->driver_info->check_connect)
+		return dev->driver_info->check_connect(dev) == 0;
+
+	/* if the device has mii operations, use those */
+	if (dev->mii.mdio_read)
+		return mii_link_ok(&dev->mii);
+
+	/* Otherwise, dtrt for drivers calling netif_carrier_{on,off} */
+	return ethtool_op_get_link(net);
+}
+
+static
+int axusbnet_nway_reset(struct net_device *net)
+{
+	struct usbnet *dev = netdev_priv(net);
+
+	if (!dev->mii.mdio_write)
+		return -EOPNOTSUPP;
+
+	return mii_nway_restart(&dev->mii);
+}
+
+static
+void axusbnet_get_drvinfo(struct net_device *net, struct ethtool_drvinfo *info)
+{
+	struct usbnet *dev = netdev_priv(net);
+
+	strncpy(info->driver, dev->driver_name, sizeof(info->driver));
+	strncpy(info->version, DRIVER_VERSION, sizeof(info->version));
+	strncpy(info->fw_version, dev->driver_info->description,
+		sizeof(info->fw_version));
+	usb_make_path(dev->udev, info->bus_info, sizeof(info->bus_info));
+}
+
+static
+u32 axusbnet_get_msglevel(struct net_device *net)
+{
+	struct usbnet *dev = netdev_priv(net);
+
+	return dev->msg_enable;
+}
+
+static
+void axusbnet_set_msglevel(struct net_device *net, u32 level)
+{
+	struct usbnet *dev = netdev_priv(net);
+
+	dev->msg_enable = level;
+}
+
+/* drivers may override default ethtool_ops in their bind() routine */
+static struct ethtool_ops axusbnet_ethtool_ops = {
+	.get_settings		= axusbnet_get_settings,
+	.set_settings		= axusbnet_set_settings,
+	.get_link		= axusbnet_get_link,
+	.nway_reset		= axusbnet_nway_reset,
+	.get_drvinfo		= axusbnet_get_drvinfo,
+	.get_msglevel		= axusbnet_get_msglevel,
+	.set_msglevel		= axusbnet_set_msglevel,
+};
+
+/*-------------------------------------------------------------------------*/
+
+/* work that cannot be done in interrupt context uses keventd.
+ *
+ * NOTE:  with 2.5 we could do more of this using completion callbacks,
+ * especially now that control transfers can be queued.
+ */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20)
+static void kevent(void *data)
+{
+	struct usbnet *dev = (struct usbnet *)data;
+#else
+static void kevent(struct work_struct *work)
+{
+	struct usbnet		*dev =
+		container_of(work, struct usbnet, kevent);
+#endif
+	int			status;
+
+	/* usb_clear_halt() needs a thread context */
+	if (test_bit(EVENT_TX_HALT, &dev->flags)) {
+
+		unlink_urbs(dev, &dev->txq);
+		status = usb_clear_halt(dev->udev, dev->out);
+		if (status < 0
+				&& status != -EPIPE
+				&& status != -ESHUTDOWN) {
+			if (netif_msg_tx_err(dev))
+				deverr(dev, "can't clear tx halt, status %d",
+				       status);
+		} else {
+			clear_bit(EVENT_TX_HALT, &dev->flags);
+			if (status != -ESHUTDOWN)
+				netif_wake_queue(dev->net);
+		}
+	}
+	if (test_bit(EVENT_RX_HALT, &dev->flags)) {
+
+		unlink_urbs(dev, &dev->rxq);
+		status = usb_clear_halt(dev->udev, dev->in);
+		if (status < 0
+				&& status != -EPIPE
+				&& status != -ESHUTDOWN) {
+			if (netif_msg_rx_err(dev))
+				deverr(dev, "can't clear rx halt, status %d",
+				       status);
+		} else {
+			clear_bit(EVENT_RX_HALT, &dev->flags);
+			tasklet_schedule(&dev->bh);
+		}
+	}
+
+	/* tasklet could resubmit itself forever if memory is tight */
+	if (test_bit(EVENT_RX_MEMORY, &dev->flags)) {
+		struct urb	*urb = NULL;
+
+		if (netif_running(dev->net))
+			urb = usb_alloc_urb(0, GFP_KERNEL);
+		else
+			clear_bit(EVENT_RX_MEMORY, &dev->flags);
+		if (urb != NULL) {
+			clear_bit(EVENT_RX_MEMORY, &dev->flags);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 14)
+			urb->transfer_flags |= URB_ASYNC_UNLINK;
+#endif
+			rx_submit(dev, urb, GFP_KERNEL);
+			tasklet_schedule(&dev->bh);
+		}
+	}
+
+	if (test_bit(EVENT_LINK_RESET, &dev->flags)) {
+		struct driver_info	*info = dev->driver_info;	
+
+		clear_bit(EVENT_LINK_RESET, &dev->flags);
+		if (info->link_reset) {
+			int retval;
+			retval = info->link_reset(dev);
+			if (retval < 0) {
+				devinfo(dev,
+					"link reset failed (%d) usbnet usb-%s-%s, %s",
+					retval,
+					dev->udev->bus->bus_name,
+					dev->udev->devpath,
+					info->description);
+			}
+		}
+	}
+
+	if (dev->flags)
+		devdbg(dev, "kevent done, flags = 0x%lx", dev->flags);
+}
+
+/*-------------------------------------------------------------------------*/
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+static void tx_complete(struct urb *urb, struct pt_regs *regs)
+#else
+static void tx_complete(struct urb *urb)
+#endif
+{
+	struct sk_buff		*skb = (struct sk_buff *) urb->context;
+	struct skb_data		*entry = (struct skb_data *) skb->cb;
+	struct usbnet		*dev = entry->dev;
+
+	if (urb->status == 0) {
+		dev->stats.tx_packets++;
+		dev->stats.tx_bytes += entry->length;
+	} else {
+		dev->stats.tx_errors++;
+
+		switch (urb->status) {
+		case -EPIPE:
+			axusbnet_defer_kevent(dev, EVENT_TX_HALT);
+			break;
+
+		/* software-driven interface shutdown */
+		case -ECONNRESET:		/* async unlink */
+		case -ESHUTDOWN:		/* hardware gone */
+			break;
+
+		/* like rx, tx gets controller i/o faults during khubd delays */
+		/* and so it uses the same throttling mechanism. */
+		case -EPROTO:
+		case -ETIME:
+		case -EILSEQ:
+			if (!timer_pending(&dev->delay)) {
+				mod_timer(&dev->delay,
+					  jiffies + THROTTLE_JIFFIES);
+				if (netif_msg_link(dev))
+					devdbg(dev, "tx throttle %d",
+					       urb->status);
+			}
+			netif_stop_queue(dev->net);
+			break;
+		default:
+			if (netif_msg_tx_err(dev))
+				devdbg(dev, "tx err %d", entry->urb->status);
+			break;
+		}
+	}
+
+	urb->dev = NULL;
+	entry->state = tx_done;
+	(void) defer_bh(dev, skb, &dev->txq, tx_done);
+}
+
+/*-------------------------------------------------------------------------*/
+
+static
+void axusbnet_tx_timeout(struct net_device *net)
+{
+	struct usbnet *dev = netdev_priv(net);
+	struct driver_info	*info = dev->driver_info;
+
+	if (!(info->flags & FLAG_AVOID_UNLINK_URBS)) {
+		unlink_urbs(dev, &dev->txq);
+	}	
+	tasklet_schedule(&dev->bh);
+
+	/* FIXME: device recovery -- reset? */
+}
+
+/*-------------------------------------------------------------------------*/
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 32)
+static int
+#else
+static netdev_tx_t
+#endif
+axusbnet_start_xmit(struct sk_buff *skb, struct net_device *net)
+{
+	struct usbnet		*dev = netdev_priv(net);
+	int			length;
+	struct urb		*urb = NULL;
+	struct skb_data		*entry;
+	struct driver_info	*info = dev->driver_info;
+	unsigned long		flags;
+	int retval;
+
+	/* some devices want funky USB-level framing, for */
+	/* win32 driver (usually) and/or hardware quirks */
+	if (info->tx_fixup) {
+		skb = info->tx_fixup(dev, skb, GFP_ATOMIC);
+		if (!skb) {
+			if (netif_msg_tx_err(dev))
+				devdbg(dev, "can't tx_fixup skb");
+			goto drop;
+		}
+	}
+	length = skb->len;
+
+	urb = usb_alloc_urb(0, GFP_ATOMIC);
+	if (!urb) {
+		if (netif_msg_tx_err(dev))
+			devdbg(dev, "no urb");
+		goto drop;
+	}
+
+	entry = (struct skb_data *) skb->cb;
+	entry->urb = urb;
+	entry->dev = dev;
+	entry->state = tx_start;
+	entry->length = length;
+
+	usb_fill_bulk_urb(urb, dev->udev, dev->out, skb->data,
+			  skb->len, tx_complete, skb);
+
+	/* don't assume the hardware handles USB_ZERO_PACKET
+	 * NOTE:  strictly conforming cdc-ether devices should expect
+	 * the ZLP here, but ignore the one-byte packet.
+	 */
+	if (!(info->flags & FLAG_SEND_ZLP) && (length % dev->maxpacket) == 0) {
+		urb->transfer_buffer_length++;
+		if (skb_tailroom(skb)) {
+			skb->data[skb->len] = 0;
+			__skb_put(skb, 1);
+		}
+	}
+
+	spin_lock_irqsave(&dev->txq.lock, flags);
+
+	switch ((retval = usb_submit_urb(urb, GFP_ATOMIC))) {
+	case -EPIPE:
+		netif_stop_queue(net);
+		axusbnet_defer_kevent(dev, EVENT_TX_HALT);
+		break;
+	default:
+		if (netif_msg_tx_err(dev))
+			devdbg(dev, "tx: submit urb err %d", retval);
+		break;
+	case 0:
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 7, 0)
+		net->trans_start = jiffies;
+#else		
+		netif_trans_update(net);
+#endif
+		__skb_queue_tail(&dev->txq, skb);
+		if (dev->txq.qlen >= TX_QLEN(dev))
+			netif_stop_queue(net);
+	}
+	spin_unlock_irqrestore(&dev->txq.lock, flags);
+
+	if (retval) {
+		if (netif_msg_tx_err(dev))
+			devdbg(dev, "drop, code %d", retval);
+drop:
+		dev->stats.tx_dropped++;
+		if (skb)
+			dev_kfree_skb_any(skb);
+		usb_free_urb(urb);
+	} else if (netif_msg_tx_queued(dev)) {
+		devdbg(dev, "> tx, len %d, type 0x%x",
+		       length, skb->protocol);
+	}
+	return NETDEV_TX_OK;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* tasklet (work deferred from completions, in_irq) or timer */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+static void axusbnet_bh(unsigned long param)
+#else
+static void axusbnet_bh (struct timer_list *t)
+#endif
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+	struct usbnet		*dev = (struct usbnet *) param;
+#else
+	struct usbnet		*dev = from_timer(dev, t, delay);
+#endif	
+	struct sk_buff		*skb;
+	struct skb_data		*entry = NULL;
+
+	while ((skb = skb_dequeue(&dev->done))) {
+		entry = (struct skb_data *) skb->cb;
+		switch (entry->state) {
+		case rx_done:
+			entry->state = rx_cleanup;
+			rx_process(dev, skb);
+			continue;
+		case tx_done:
+		case rx_cleanup:
+			usb_free_urb(entry->urb);
+			dev_kfree_skb(skb);
+			continue;
+		default:
+			devdbg(dev, "bogus skb state %d", entry->state);
+		}
+	}
+
+	/* restart RX again after disabling due to high error rate */
+         clear_bit(EVENT_RX_KILL, &dev->flags);
+
+	/* waiting for all pending urbs to complete? */
+	if (dev->wait) {
+		if ((dev->txq.qlen + dev->rxq.qlen + dev->done.qlen) == 0)
+			wake_up(dev->wait);
+
+	/* or are we maybe short a few urbs? */
+	} else if (netif_running(dev->net)
+			&& netif_device_present(dev->net)
+			&& !timer_pending(&dev->delay)
+			&& !test_bit(EVENT_RX_HALT, &dev->flags)) {
+		int	temp = dev->rxq.qlen;
+		int	qlen = RX_QLEN(dev);
+
+		if (temp < qlen) {
+			struct urb	*urb = NULL;
+			int		i;
+
+			/* don't refill the queue all at once */
+			for (i = 0; i < 10 && dev->rxq.qlen < qlen; i++) {
+				urb = usb_alloc_urb(0, GFP_ATOMIC);
+				if (urb != NULL) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 14)
+					urb->transfer_flags |= URB_ASYNC_UNLINK;
+#endif
+					rx_submit(dev, urb, GFP_ATOMIC);
+				}
+			}
+			if (temp != dev->rxq.qlen && netif_msg_link(dev))
+				devdbg(dev, "rxqlen %d --> %d",
+				       temp, dev->rxq.qlen);
+			if (dev->rxq.qlen < qlen)
+				tasklet_schedule(&dev->bh);
+		}
+		if (dev->txq.qlen < TX_QLEN(dev))
+			netif_wake_queue(dev->net);
+	}
+}
+
+
+/*-------------------------------------------------------------------------
+ *
+ * USB Device Driver support
+ *
+ *-------------------------------------------------------------------------*/
+
+/* precondition: never called in_interrupt */
+
+static
+void axusbnet_disconnect(struct usb_interface *intf)
+{
+	struct usbnet		*dev;
+	struct usb_device	*xdev;
+	struct net_device	*net;
+
+	dev = usb_get_intfdata(intf);
+	usb_set_intfdata(intf, NULL);
+	if (!dev)
+		return;
+
+	xdev = interface_to_usbdev(intf);
+
+	if (netif_msg_probe(dev))
+		devinfo(dev, "unregister '%s' usb-%s-%s, %s",
+			intf->dev.driver->name,
+			xdev->bus->bus_name, xdev->devpath,
+			dev->driver_info->description);
+
+	net = dev->net;
+	unregister_netdev(net);
+
+	/* we don't hold rtnl here ... */
+	flush_scheduled_work();
+
+	if (dev->driver_info->unbind)
+		dev->driver_info->unbind(dev, intf);
+
+	free_netdev(net);
+	usb_put_dev(xdev);
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* precondition: never called in_interrupt */
+
+static int
+axusbnet_probe(struct usb_interface *udev, const struct usb_device_id *prod)
+{
+	struct usbnet			*dev;
+	struct net_device		*net;
+	struct usb_host_interface	*interface;
+	struct driver_info		*info;
+	struct usb_device		*xdev;
+	int				status;
+	const char			*name;
+
+	name = udev->dev.driver->name;
+	info = (struct driver_info *) prod->driver_info;
+	if (!info) {
+		printk(KERN_ERR "blacklisted by %s\n", name);
+		return -ENODEV;
+	}
+	xdev = interface_to_usbdev(udev);
+	interface = udev->cur_altsetting;
+
+	usb_get_dev(xdev);
+
+	status = -ENOMEM;
+
+	/* set up our own records */
+	net = alloc_etherdev(sizeof(*dev));
+	if (!net) {
+		printk(KERN_ERR "can't kmalloc dev");
+		goto out;
+	}
+
+	dev = netdev_priv(net);
+	dev->udev = xdev;
+	dev->intf = udev;
+	dev->driver_info = info;
+	dev->driver_name = name;
+	dev->msg_enable = netif_msg_init(msg_level, NETIF_MSG_DRV |
+					 NETIF_MSG_PROBE | NETIF_MSG_LINK);
+	skb_queue_head_init(&dev->rxq);
+	skb_queue_head_init(&dev->txq);
+	skb_queue_head_init(&dev->done);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+	dev->bh.func = axusbnet_bh;
+	dev->bh.data = (unsigned long) dev;
+#else
+	dev->bh.func = (void (*)(unsigned long))axusbnet_bh;
+	dev->bh.data = (unsigned long)&dev->delay;
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20)
+	INIT_WORK(&dev->kevent, kevent, dev);
+#else
+	INIT_WORK(&dev->kevent, kevent);
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+	dev->delay.function = axusbnet_bh;
+	dev->delay.data = (unsigned long) dev;
+	init_timer(&dev->delay);
+#else
+	timer_setup(&dev->delay, axusbnet_bh, 0);
+#endif
+	/* mutex_init(&dev->phy_mutex); */
+
+	dev->net = net;
+
+	/* rx and tx sides can use different message sizes;
+	 * bind() should set rx_urb_size in that case.
+	 */
+	dev->hard_mtu = net->mtu + net->hard_header_len;
+
+#if 0
+	/* dma_supported() is deeply broken on almost all architectures */
+	/* possible with some EHCI controllers */
+	if (dma_supported(&udev->dev, DMA_BIT_MASK(64)))
+		net->features |= NETIF_F_HIGHDMA;
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 30)
+	net->open		= axusbnet_open,
+	net->stop		= axusbnet_stop,
+	net->hard_start_xmit	= axusbnet_start_xmit,
+	net->tx_timeout	= axusbnet_tx_timeout,
+	net->get_stats = axusbnet_get_stats;
+#endif
+
+	net->watchdog_timeo = TX_TIMEOUT_JIFFIES;
+	net->ethtool_ops = &axusbnet_ethtool_ops;
+
+	/* allow device-specific bind/init procedures */
+	/* NOTE net->name still not usable ... */
+	status = info->bind(dev, udev);
+	if (status < 0) {
+		deverr(dev, "Binding device failed: %d", status);
+		goto out1;
+	}
+
+	/* maybe the remote can't receive an Ethernet MTU */
+	if (net->mtu > (dev->hard_mtu - net->hard_header_len))
+		net->mtu = dev->hard_mtu - net->hard_header_len;
+
+	status = init_status(dev, udev);
+	if (status < 0)
+		goto out3;
+
+	if (!dev->rx_urb_size)
+		dev->rx_urb_size = dev->hard_mtu;
+	dev->maxpacket = usb_maxpacket(dev->udev, dev->out, 1);
+
+	SET_NETDEV_DEV(net, &udev->dev);
+	status = register_netdev(net);
+	if (status) {
+		deverr(dev, "net device registration failed: %d", status);
+		goto out3;
+	}
+
+	if (netif_msg_probe(dev))
+		devinfo(dev, "register '%s' at usb-%s-%s, %s, %pM",
+			udev->dev.driver->name,
+			xdev->bus->bus_name, xdev->devpath,
+			dev->driver_info->description,
+			net->dev_addr);
+
+	/* ok, it's ready to go. */
+	usb_set_intfdata(udev, dev);
+
+	/* start as if the link is up */
+	netif_device_attach(net);
+
+	return 0;
+
+out3:
+	if (info->unbind)
+		info->unbind(dev, udev);
+out1:
+	free_netdev(net);
+out:
+	usb_put_dev(xdev);
+	return status;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * suspend the whole driver as soon as the first interface is suspended
+ * resume only when the last interface is resumed
+ */
+
+static int axusbnet_suspend(struct usb_interface *intf,
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 10)
+pm_message_t message)
+#else
+u32 message)
+#endif
+{
+	struct usbnet *dev = usb_get_intfdata(intf);
+
+	if (!dev->suspend_count++) {
+		/*
+		 * accelerate emptying of the rx and queues, to avoid
+		 * having everything error out.
+		 */
+		netif_device_detach(dev->net);
+		(void) unlink_urbs(dev, &dev->rxq);
+		(void) unlink_urbs(dev, &dev->txq);
+		usb_kill_urb(dev->interrupt);
+		/*
+		 * reattach so runtime management can use and
+		 * wake the device
+		 */
+		netif_device_attach(dev->net);
+	}
+	return 0;
+}
+
+static int
+axusbnet_resume(struct usb_interface *intf)
+{
+	struct usbnet	*dev = usb_get_intfdata(intf);
+	int	retval = 0;
+
+	if (!--dev->suspend_count)
+		tasklet_schedule(&dev->bh);
+
+	retval = init_status(dev, intf);
+	if (retval < 0)
+		return retval;
+
+	if (dev->interrupt) {
+		retval = usb_submit_urb(dev->interrupt, GFP_KERNEL);
+		if (retval < 0 && netif_msg_ifup(dev))
+			deverr(dev, "intr submit %d", retval);
+	}
+
+	return retval;
+}
+
diff --git a/drivers/net/usb/axusbnet.h b/drivers/net/usb/axusbnet.h
new file mode 100644
index 00000000..449ef6b
--- /dev/null
+++ b/drivers/net/usb/axusbnet.h
@@ -0,0 +1,211 @@
+/*
+ * USB Networking Link Interface
+ *
+ * Copyright (C) 2000-2005 by David Brownell <dbrownell@users.sourceforge.net>
+ * Copyright (C) 2003-2005 David Hollis <dhollis@davehollis.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef	__LINUX_USB_USBNET_H
+#define	__LINUX_USB_USBNET_H
+
+#ifndef gfp_t
+#define gfp_t int
+#endif
+
+/* interface from usbnet core to each USB networking link we handle */
+struct usbnet {
+	/* housekeeping */
+	struct usb_device	*udev;
+	struct usb_interface	*intf;
+	struct driver_info	*driver_info;
+	const char		*driver_name;
+	void			*driver_priv;
+	wait_queue_head_t	*wait;
+	/* struct mutex		phy_mutex; */
+	unsigned char		suspend_count;
+	unsigned char           pkt_cnt, pkt_err;
+
+	/* i/o info: pipes etc */
+	unsigned		in, out;
+	struct usb_host_endpoint *status;
+	unsigned		maxpacket;
+	struct timer_list	delay;
+
+	/* protocol/interface state */
+	struct net_device	*net;
+	struct net_device_stats stats;
+	int			msg_enable;
+	unsigned long		data[5];
+	u32			xid;
+	u32			hard_mtu;	/* count any extra framing */
+	size_t			rx_urb_size;	/* size for rx urbs */
+	struct mii_if_info	mii;
+
+	/* various kinds of pending driver work */
+	struct sk_buff_head	rxq;
+	struct sk_buff_head	txq;
+	struct sk_buff_head	done;
+	struct sk_buff_head	rxq_pause;
+	struct urb		*interrupt;
+	struct tasklet_struct	bh;
+
+	struct work_struct	kevent;
+	unsigned long		flags;
+#		define EVENT_TX_HALT	0
+#		define EVENT_RX_HALT	1
+#		define EVENT_RX_MEMORY	2
+#		define EVENT_STS_SPLIT	3
+#		define EVENT_LINK_RESET	4
+#		define EVENT_RX_PAUSED	5
+#		define EVENT_RX_KILL    10
+
+	void			*priv;	/* point to minidriver private data */
+	unsigned char		rx_size;
+};
+
+static inline struct usb_driver *driver_of(struct usb_interface *intf)
+{
+	return to_usb_driver(intf->dev.driver);
+}
+
+/* interface from the device/framing level "minidriver" to core */
+struct driver_info {
+	char		*description;
+
+	int		flags;
+/* framing is CDC Ethernet, not writing ZLPs (hw issues), or optionally: */
+#define FLAG_FRAMING_NC	0x0001		/* guard against device dropouts */
+#define FLAG_FRAMING_GL	0x0002		/* genelink batches packets */
+#define FLAG_FRAMING_Z	0x0004		/* zaurus adds a trailer */
+#define FLAG_FRAMING_RN	0x0008		/* RNDIS batches, plus huge header */
+
+#define FLAG_NO_SETINT	0x0010		/* device can't set_interface() */
+#define FLAG_ETHER	0x0020		/* maybe use "eth%d" names */
+
+#define FLAG_FRAMING_AX 0x0040		/* AX88772/178 packets */
+#define FLAG_WLAN	0x0080		/* use "wlan%d" names */
+#define FLAG_AVOID_UNLINK_URBS	0x0100	/* don't unlink urbs at usbnet_stop() */
+#define FLAG_SEND_ZLP	0x0200		/* hw requires ZLPs are sent */
+#define FLAG_HW_IP_ALIGNMENT	0x0400	/* AX88772B support hardware IP alignment */
+
+
+	/* init device ... can sleep, or cause probe() failure */
+	int	(*bind)(struct usbnet *, struct usb_interface *);
+
+	/* cleanup device ... can sleep, but can't fail */
+	void	(*unbind)(struct usbnet *, struct usb_interface *);
+
+	/* reset device ... can sleep */
+	int	(*reset)(struct usbnet *);
+
+	/* stop device ... can sleep */
+	int	(*stop)(struct usbnet *);
+
+	/* see if peer is connected ... can sleep */
+	int	(*check_connect)(struct usbnet *);
+
+	/* for status polling */
+	void	(*status)(struct usbnet *, struct urb *);
+
+	/* link reset handling, called from defer_kevent */
+	int	(*link_reset)(struct usbnet *);
+
+	/* fixup rx packet (strip framing) */
+	int	(*rx_fixup)(struct usbnet *dev, struct sk_buff *skb);
+
+	/* fixup tx packet (add framing) */
+	struct sk_buff	*(*tx_fixup)(struct usbnet *dev,
+				struct sk_buff *skb, gfp_t flags);
+
+	/* early initialization code, can sleep. This is for minidrivers
+	 * having 'subminidrivers' that need to do extra initialization
+	 * right after minidriver have initialized hardware. */
+	int	(*early_init)(struct usbnet *dev);
+
+	/* called by minidriver when receiving indication */
+	void	(*indication)(struct usbnet *dev, void *ind, int indlen);
+
+	/* for new devices, use the descriptor-reading code instead */
+	int		in;		/* rx endpoint */
+	int		out;		/* tx endpoint */
+
+	unsigned long	data;		/* Misc driver specific data */
+};
+
+/* Drivers that reuse some of the standard USB CDC infrastructure
+ * (notably, using multiple interfaces according to the CDC
+ * union descriptor) get some helper code.
+ */
+struct cdc_state {
+	struct usb_cdc_header_desc	*header;
+	struct usb_cdc_union_desc	*u;
+	struct usb_cdc_ether_desc	*ether;
+	struct usb_interface		*control;
+	struct usb_interface		*data;
+};
+
+/* CDC and RNDIS support the same host-chosen packet filters for IN transfers */
+#define	DEFAULT_FILTER	(USB_CDC_PACKET_TYPE_BROADCAST \
+			|USB_CDC_PACKET_TYPE_ALL_MULTICAST \
+			|USB_CDC_PACKET_TYPE_PROMISCUOUS \
+			|USB_CDC_PACKET_TYPE_DIRECTED)
+
+
+/* we record the state for each of our queued skbs */
+enum skb_state {
+	illegal = 0,
+	tx_start, tx_done,
+	rx_start, rx_done, rx_cleanup,
+	unlink_start
+};
+
+struct skb_data {	/* skb->cb is one of these */
+	struct urb		*urb;
+	struct usbnet		*dev;
+	enum skb_state		state;
+	size_t			length;
+};
+
+#ifndef skb_queue_walk_safe
+#define skb_queue_walk_safe(queue, skb, tmp)				\
+			for (skb = (queue)->next, tmp = skb->next;	\
+			skb != (struct sk_buff *)(queue);		\
+			skb = tmp, tmp = skb->next)
+#endif
+
+/* messaging support includes the interface name, so it must not be
+ * used before it has one ... notably, in minidriver bind() calls.
+ */
+#ifdef DEBUG
+#define devdbg(usbnet, fmt, arg...) \
+	printk("%s: " fmt "\n" , (usbnet)->net->name , ## arg)
+#else
+#define devdbg(usbnet, fmt, arg...) \
+	({ if (0) printk("%s: " fmt "\n" , (usbnet)->net->name , \
+		## arg); 0; })
+#endif
+
+#define deverr(usbnet, fmt, arg...) \
+	printk(KERN_ERR "%s: " fmt "\n" , (usbnet)->net->name , ## arg)
+#define devwarn(usbnet, fmt, arg...) \
+	printk(KERN_WARNING "%s: " fmt "\n" , (usbnet)->net->name , ## arg)
+
+#define devinfo(usbnet, fmt, arg...) \
+	printk(KERN_INFO "%s: " fmt "\n" , (usbnet)->net->name , ## arg); \
+
+
+#endif /* __LINUX_USB_USBNET_H */
-- 
2.7.4
