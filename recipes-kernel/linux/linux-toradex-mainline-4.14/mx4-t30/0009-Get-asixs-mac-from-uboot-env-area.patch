From 144699d517b3719b3483aabbc5bfacbca7d29d06 Mon Sep 17 00:00:00 2001
From: rikardo <rikard.olander@hostmobility.com>
Date: Fri, 30 Aug 2019 14:42:52 +0200
Subject: [PATCH] Get asixs mac from uboot env area

---
 drivers/net/usb/asix_devices.c | 113 +++++++++++++++++++++++++++++++++++------
 1 file changed, 97 insertions(+), 16 deletions(-)

diff --git a/drivers/net/usb/asix_devices.c b/drivers/net/usb/asix_devices.c
index 2eca416..e7ba794 100644
--- a/drivers/net/usb/asix_devices.c
+++ b/drivers/net/usb/asix_devices.c
@@ -18,7 +18,7 @@
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
-
+#include <linux/ctype.h>
 #include "asix.h"
 
 #define PHY_MODE_MARVELL	0x0000
@@ -52,6 +52,55 @@ struct ax88172_int_data {
 	__le16 res3;
 } __packed;
 
+static char g_mac_addr[2][ETH_ALEN];
+static int g_usr_mac = 0;
+static int g_mac_alloc[2] = {-1, -1};
+
+/* Retrieve user set MAC address */
+static int setup_mac(char *macstr, int mac_nr) 
+{
+	int i, j;
+	unsigned char result, value;
+
+	for (i = 0; i < ETH_ALEN; i++) {
+		result = 0;
+
+		if (i != 5 && *(macstr + 2) != ':')
+			return -1;
+
+		for (j = 0; j < 2; j++) {
+			if (isxdigit(*macstr)
+			    && (value =
+				isdigit(*macstr) ? *macstr -
+				'0' : toupper(*macstr) - 'A' + 10) < 16) {
+				result = result * 16 + value;
+				macstr++;
+			} else
+				return -1;
+		}
+
+		macstr++;
+		g_mac_addr[mac_nr][i] = result;
+	}
+
+	g_usr_mac = 1;
+
+	return 0;
+}
+static int __init setup_asix_mac(char *macstr)
+{
+    g_mac_alloc[0] = setup_mac(macstr, 0);
+    return g_mac_alloc[0];
+}
+static int __init setup_asix_mac2(char *macstr) 
+{
+    g_mac_alloc[1] = setup_mac(macstr, 1);
+    return g_mac_alloc[1];
+}
+
+__setup("asix_mac=", setup_asix_mac);
+__setup("asix_mac2=", setup_asix_mac2);
+
 static void asix_status(struct usbnet *dev, struct urb *urb)
 {
 	struct ax88172_int_data *event;
@@ -692,34 +741,54 @@ static int ax88772_bind(struct usbnet *dev, struct usb_interface *intf)
 	u8 buf[ETH_ALEN] = {0}, chipcode = 0;
 	u32 phyid;
 	struct asix_common_private *priv;
+	u8 default_asix_mac[ETH_ALEN] = { 0x00, 0x0e, 0xc6, 0x87, 0x72, 0x01 };
 
 	usbnet_get_endpoints(dev, intf);
-
 	/* Maybe the boot loader passed the MAC address via device tree */
 	if (!eth_platform_get_mac_address(&dev->udev->dev, buf)) {
 		netif_dbg(dev, ifup, dev->net,
 			  "MAC address read from device tree");
-	} else {
 		/* Try getting the MAC address from EEPROM */
-		if (dev->driver_info->data & FLAG_EEPROM_MAC) {
-			for (i = 0; i < (ETH_ALEN >> 1); i++) {
-				ret = asix_read_cmd(dev, AX_CMD_READ_EEPROM,
-						    0x04 + i, 0, 2, buf + i * 2,
-						    0);
-				if (ret < 0)
-					break;
-			}
-		} else {
-			ret = asix_read_cmd(dev, AX_CMD_READ_NODE_ID,
-					    0, 0, ETH_ALEN, buf, 0);
+	} else if (dev->driver_info->data & FLAG_EEPROM_MAC) {
+		for (i = 0; i < (ETH_ALEN >> 1); i++) {
+			ret = asix_read_cmd(dev, AX_CMD_READ_EEPROM,
+						0x04 + i, 0, 2, buf + i * 2,
+						0);
+			if (ret < 0)
+				break;
 		}
-
+	} else {
+		/* No user configured mac free. Use default asix mac. */
+		ret = asix_read_cmd(dev, AX_CMD_READ_NODE_ID,
+					0, 0, ETH_ALEN, buf, 0);
+	}
+	
+	/* Check for default ASIX MAC (e.g. 00:0e:c6:87:72:01) in case of no EEPROM being present */
+	if (!memcmp(buf, default_asix_mac, ETH_ALEN)) {
+		if (g_usr_mac && (g_usr_mac < 3)) {
+			/* Get user set MAC address */
+            if (!g_mac_alloc[0]) {
+                g_mac_alloc[0] = 1;
+                memcpy(buf, g_mac_addr[0], ETH_ALEN);
+                g_usr_mac++;
+            }
+            else if (!g_mac_alloc[1]) {
+                g_mac_alloc[1] = 1;
+                memcpy(buf, g_mac_addr[1], ETH_ALEN);
+                g_usr_mac++;
+            }
+            else {
+                /* No user configured mac free. Use default asix mac. */
+                memcpy(buf, default_asix_mac, ETH_ALEN);
+            }
+
+		} else netdev_warn(dev->net, "using default ASIX MAC, %d", g_usr_mac);
+	}
 		if (ret < 0) {
 			netdev_dbg(dev->net, "Failed to read MAC address: %d\n",
 				   ret);
 			return ret;
 		}
-	}
 
 	asix_set_netdev_dev_addr(dev, buf);
 
@@ -779,6 +848,18 @@ static int ax88772_bind(struct usbnet *dev, struct usb_interface *intf)
 
 static void ax88772_unbind(struct usbnet *dev, struct usb_interface *intf)
 {
+	/* Check for user set MAC address */
+	if (!memcmp(dev->net->dev_addr, g_mac_addr[0], ETH_ALEN))
+	{
+		/* Release user set MAC address */
+		g_mac_alloc[0] = 0;
+		g_usr_mac--;
+	}
+	if (!memcmp(dev->net->dev_addr, g_mac_addr[1], ETH_ALEN)) {
+		/* Release user set MAC address */
+		g_mac_alloc[1] = 0;
+		g_usr_mac--;
+	}
 	asix_rx_fixup_common_free(dev->driver_priv);
 	kfree(dev->driver_priv);
 }
-- 
2.7.4
