From de841329329217b487ab8ba79af4d91c6e0ba1c6 Mon Sep 17 00:00:00 2001
From: Andreas Ternstedt <a.ternstedt@setek.se>
Date: Thu, 14 Aug 2025 16:13:35 +0200
Subject: [PATCH 3/4] imx8mp-var-dart: Add HMX board-specific customizations

Implement HMX-specific U-Boot customizations for imx8mp-var-dart:

Hardware Configuration:
- Change console from UART1 to UART3
- Add RGB LED controller support with boot indication 
-    (blue on boot, white blinking during flash)
- Add USB upgrade button (USB_BOOT) detection
- Add watchdog initialization

Environment and Boot:
- Set device tree to imx8mp-var-dart-hmx1.dtb
- Read HM variables from HMX EEPROM
- Set serial-number, part-number, and product-number in device tree
- Set RGB LED controller register in device tree
- Change default BSP script from boot.scr to hmx_boot.scr
- Add USB flash support with try_usb_flash for recovery

M7 Co-processor Support:
- Load M7 firmware (hmx-m7-fw.bin) from DDR memory
- Delay M7 loading until after flashing to prevent watchdog timeout

Based on Variscite U-boot version: lf_v2024.04_6.6.52-2.2.0_var01

Co-developed-by: rikardo <rikard.olander@hostmobility.com>
Signed-off-by: Andreas Ternstedt <a.ternstedt@setek.se>

---

Notes:
    v3: Adapted patch for Variscite U-boot lf_v2024.04_6.6.52-2.2.0_var01
    v2: - Fixed USB hub activation on boot
        - Added EEPROM support
        - Fixed SD card detection (changed pinctrl)
    v1: - Changed serial console port to UART3
        - Disabled FEC ethernet

 .../imx8mp_var_dart/imx8mp_var_dart.c         | 125 ++++++++++++++++++
 board/variscite/imx8mp_var_dart/spl.c         |   7 +-
 include/configs/imx8mp_var_dart.h             |  35 +++--
 3 files changed, 152 insertions(+), 15 deletions(-)

diff --git a/board/variscite/imx8mp_var_dart/imx8mp_var_dart.c b/board/variscite/imx8mp_var_dart/imx8mp_var_dart.c
index 4a550e802fc..7d2f1efcc05 100644
--- a/board/variscite/imx8mp_var_dart/imx8mp_var_dart.c
+++ b/board/variscite/imx8mp_var_dart/imx8mp_var_dart.c
@@ -29,6 +29,7 @@
 #include "../common/extcon-ptn5150.h"
 #include "../common/imx8_eeprom.h"
 #include "imx8mp_var_dart.h"
+#include "../common/hmx_eeprom.h"
 
 int var_setup_mac(struct var_eeprom *eeprom);
 
@@ -52,6 +53,11 @@ static iomux_v3_cfg_t const board_detect_pads[] = {
 };
 #endif
 
+#define USB_UPGRADE_BUTTON_GPIO IMX_GPIO_NR(3, 0)
+static iomux_v3_cfg_t const usb_upgrade_button_pad[] = {
+	MX8MP_PAD_NAND_ALE__GPIO3_IO00 | MUX_PAD_CTRL(GPIO_PAD_CTRL),
+};
+
 int var_detect_board_id(void)
 {
 	static int board_id = BOARD_ID_UNDEF;
@@ -171,8 +177,105 @@ int board_early_init_f(void)
 }
 
 #ifdef CONFIG_OF_BOARD_SETUP
+/* Set serial number and part number from environment to device tree blob chosen.
+		serial-number = "23078888";
+		part-number = "hmp00xx"; 
+		product-number = hmxxx;
+	Set RGB controller register id (0x30,0x31 or 0x32) to device tree blob.
+*/
 int ft_board_setup(void *blob, struct bd_info *bd)
 {
+#if defined(CONFIG_OF_LIBFDT)
+	char *serial;
+	char *part;
+	char *product;
+	int offset;
+	int err = 1;
+	const char *path;
+
+	path = "/chosen";
+	offset = fdt_path_offset(blob, path);
+	if (offset < 0) {
+		debug("Node %s not found.\n", path);
+		return err;
+	}
+
+	debug("ft_board_setup: config FDT\n");
+
+	serial = env_get("serial");
+	if (serial) {
+		err = fdt_setprop(blob, offset, "serial-number", serial,
+				  strlen(serial) + 1);
+
+		if (err < 0) {
+			printf("WARNING: could not set serial-number %s.\n",
+			       fdt_strerror(err));
+			return err;
+		}
+	} else {
+		printf("WARNING: could not read serial-number from env list.\n");
+	}
+	part = env_get("part_nr");
+	if (part) {
+		err = fdt_setprop(blob, offset, "part-number", part,
+				  strlen(part) + 1);
+
+		if (err < 0) {
+			printf("WARNING: could not set part-number %s.\n",
+			       fdt_strerror(err));
+			return err;
+		}
+	} else {
+		printf("WARNING: could not read part-number from env list.\n");
+	}
+	product = env_get("product_nr");
+	if (product) {
+		err = fdt_setprop(blob, offset, "product-number", product,
+				  strlen(product) + 1);
+
+		if (err < 0) {
+			printf("WARNING: could not set product-number %s.\n",
+			       fdt_strerror(err));
+			return err;
+		}
+	} else {
+		printf("WARNING: could not read product-number from env list.\n");
+	}
+	/*Set RGB led register*/
+	char *rgb_env;
+	const char *subnode_name = "led-controller@30";
+	const char *alias_name = "i2c1";
+	unsigned int rgb_controller_register_id;
+	const char *i2c1_path = fdt_get_alias(blob, alias_name);
+	offset = fdt_path_offset(blob, i2c1_path);
+	if (offset < 0) {
+		debug("Node %s not found.\n", i2c1_path);
+		return err;
+	}
+	offset = fdt_subnode_offset(blob, offset, subnode_name);
+	if (offset < 0) {
+		debug("subnode node offset: %d not found.\n", offset);
+		return err;
+	}
+	rgb_env = env_get("RGB_I2C_ID");
+	/* Convert to byte */
+	if (rgb_env) {
+		if (strict_strtoul(rgb_env, 16, (unsigned long *)&rgb_controller_register_id)) {
+			printf("Error parsing the hexadecimal string\n");
+			return -EINVAL;
+		}
+		printf("RGB_I2C_ID: %u\n", rgb_controller_register_id);
+		err = fdt_setprop_u32(blob, offset, "reg", rgb_controller_register_id);
+
+		if (err < 0) {
+			printf("WARNING: could not set /i2c2/led-controller@30/reg %s.\n",
+				fdt_strerror(err));
+			return err;
+		}
+	} else {
+		printf("WARNING: could not read RGB_I2C_ID from env list.\n");
+	}
+#endif
 #ifdef CONFIG_IMX8M_DRAM_INLINE_ECC
 	int rc;
 	phys_addr_t ecc0_start = 0xb0000000;
@@ -425,6 +528,8 @@ int board_late_init(void)
 	struct var_carrier_eeprom carrier_eeprom;
 	char carrier_rev[CARRIER_REV_LEN] = {0};
 	char som_rev[CARRIER_REV_LEN] = {0};
+	uchar eeprom_data [0xffff];
+	int err = 1;
 
 #ifdef CONFIG_ENV_IS_IN_MMC
 	board_late_mmc_env_init();
@@ -468,6 +573,26 @@ int board_late_init(void)
 	var_setup_mac(ep);
 	var_eeprom_print_prod_info(ep);
 
+	/*HMX detect usb boot button for upgrade mmc from usb memory*/
+	imx_iomux_v3_setup_multiple_pads(usb_upgrade_button_pad,
+				ARRAY_SIZE(usb_upgrade_button_pad));
+	gpio_request(USB_UPGRADE_BUTTON_GPIO, "USB_UPGRADE_BUTTON");
+	gpio_direction_input(USB_UPGRADE_BUTTON_GPIO);
+	if (gpio_get_value(USB_UPGRADE_BUTTON_GPIO) == 0) {
+		env_set("usb_flash_wanted", "true");
+	}
+	gpio_free(USB_UPGRADE_BUTTON_GPIO);
+	/* HMX get env from eeprom serial number, partnumber and mac adress(eth2addr, eth3addr) and more */
+	err = get_environment_data_from_eeprom(eeprom_data);
+	if (err != 0) {
+		printf("Get environment data from eeprom failed, error:%x\n", err);
+	} else {
+		err = set_environment_data_from_eeprom((char *)eeprom_data);
+		if (err != 0) {
+			printf("Set environment data to environment area failed, error: %x\n", err);
+		}
+	}
+
 	return 0;
 }
 
diff --git a/board/variscite/imx8mp_var_dart/spl.c b/board/variscite/imx8mp_var_dart/spl.c
index 17fadec5cfb..c8df98576bc 100644
--- a/board/variscite/imx8mp_var_dart/spl.c
+++ b/board/variscite/imx8mp_var_dart/spl.c
@@ -41,8 +41,8 @@ DECLARE_GLOBAL_DATA_PTR;
 #define UART_PAD_CTRL	(PAD_CTL_DSE6 | PAD_CTL_FSEL1)
 
 static iomux_v3_cfg_t const uart_pads_dart[] = {
-	MX8MP_PAD_UART1_RXD__UART1_DCE_RX | MUX_PAD_CTRL(UART_PAD_CTRL),
-	MX8MP_PAD_UART1_TXD__UART1_DCE_TX | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX8MP_PAD_UART3_RXD__UART3_DCE_RX | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX8MP_PAD_UART3_TXD__UART3_DCE_TX | MUX_PAD_CTRL(UART_PAD_CTRL),
 };
 
 static iomux_v3_cfg_t const uart_pads_som[] = {
@@ -96,7 +96,8 @@ static void spl_uart_init(void)
 	if (board_id == BOARD_ID_DART) {
 		imx_iomux_v3_setup_multiple_pads(uart_pads_dart,
 			ARRAY_SIZE(uart_pads_dart));
-		init_uart_clk(0);
+		/* Init clock for HMX on UART3, also in CFG_MXC_UART_BASE */
+		init_uart_clk(2);
 	} else if (board_id == BOARD_ID_SOM) {
 		imx_iomux_v3_setup_multiple_pads(uart_pads_som,
 			ARRAY_SIZE(uart_pads_som));
diff --git a/include/configs/imx8mp_var_dart.h b/include/configs/imx8mp_var_dart.h
index 40cb11d350a..853f0c545aa 100644
--- a/include/configs/imx8mp_var_dart.h
+++ b/include/configs/imx8mp_var_dart.h
@@ -56,11 +56,11 @@
 	"prepare_mcore=setenv mcore_clk clk-imx8mp.mcore_booted;\0" \
 	"scriptaddr=0x43500000\0" \
 	"kernel_addr_r=" __stringify(CONFIG_SYS_LOAD_ADDR) "\0" \
-	"bsp_script=boot.scr\0" \
+	"bsp_script=hmx_boot.scr\0" \
 	"image=Image.gz\0" \
 	"img_addr=0x42000000\0" \
 	"splashimage=0x4F600000\0" \
-	"console=ttymxc0,115200\0" \
+	"console=ttymxc2,115200\0" \
 	"fdt_addr_r=0x43000000\0" \
 	"fdt_addr=0x43000000\0"			\
 	"fdt_high=0xffffffffffffffff\0"		\
@@ -73,12 +73,12 @@
 	"mmcblk=1\0" \
 	"mmcpart=1\0" \
 	"mmcautodetect=yes\0" \
-	"m7_addr=0x7e0000\0" \
-	"m7_bin=hello_world.bin\0" \
-	"use_m7=no\0" \
+	"m7_addr=0x80000000\0" \
+	"m7_bin=rpmsg_lite_host_watchdog.bin\0" \
+	"use_m7=yes\0" \
 	"dfu_alt_info=mmc 2=1 raw 0x40 0x1000 mmcpart\0" \
 	"loadm7bin=" \
-				"load mmc ${mmcdev}:${mmcpart} ${loadaddr} ${bootdir}/${m7_bin} && " \
+				"load mmc ${mmcdev}:${mmcpart} ${loadaddr} /lib/firmware/${m7_bin} && " \
 				"cp.b ${loadaddr} ${m7_addr} ${filesize}; " \
 				"echo Init rsc_table region memory; " \
 				"mw.b 400ff000 0 10\0" \
@@ -118,7 +118,7 @@
 				"elif test ${som_has_wbe} = 1; then " \
 					"setenv fdt_file imx8mp-var-dart-wbe-dt8mcustomboard.dtb; " \
 				"else " \
-					"setenv fdt_file imx8mp-var-dart-dt8mcustomboard.dtb;" \
+					"setenv fdt_file imx8mp-var-dart-hmx1.dtb;" \
 				"fi; " \
 			"fi; " \
 		"fi; \0" \
@@ -171,23 +171,34 @@
 				"echo WARN: Cannot load the DT; " \
 			"fi; " \
 		"fi;\0" \
-	"bsp_bootcmd=echo Running BSP bootcmd ...; " \
+	"set_blue_led=i2c dev 1; if i2c probe ${RGB_I2C_ID} ; then i2c mw ${RGB_I2C_ID} 6.1 0x50 1;i2c mw ${RGB_I2C_ID} 4.1 1 1;fi\0" \
+	"set_white_flashing_led=i2c dev 1; if i2c probe ${RGB_I2C_ID} ; then i2c mw ${RGB_I2C_ID} 6.1 0x50 1;i2c mw ${RGB_I2C_ID} 7.1 0x50 1;i2c mw ${RGB_I2C_ID} 8.1 0x50 1;i2c mw ${RGB_I2C_ID} 4.1 0x2A 1;i2c mw ${RGB_I2C_ID} 1.1 13 1;fi\0" \
+	"set_red_led=i2c mw ${RGB_I2C_ID} 7.1 0x50 1;i2c mw ${RGB_I2C_ID} 4.1 0x4 1\0" \
+	"white_blink_fast=i2c mw ${RGB_I2C_ID} 1.1 1 1\0" \
+	"try_usb_flash=sleep 2; usb reset; if load usb 0 ${loadaddr} ${bsp_script} ; then source ${loadaddr}; else echo UPDATE ERROR: no ${bsp_script} on first USB device. ;fi\0" \
+	"set_RGB_ID=i2c dev 1; i2c probe 0x30 && setenv RGB_I2C_ID 0x30 || i2c probe 0x31 && setenv RGB_I2C_ID 0x31 || i2c probe 0x32 && setenv RGB_I2C_ID 0x32; if test -n \"${RGB_I2C_ID}\" ; then setenv set_RGB_ID 'i2c dev 1; echo RGB ID:$RGB_I2C_ID;'; saveenv;fi\0" \
+	"bsp_bootcmd=echo Running BSP bootcmd ...; run set_RGB_ID; run set_blue_led; " \
 		"run ramsize_check; " \
 		"mmc dev ${mmcdev}; " \
 		"if test ${fdt_file} =~ *'m7.dtb'*; then " \
 			"run prepare_mcore; " \
 		"fi; " \
 		"if mmc rescan; then " \
-			"if test ${use_m7} = yes && run loadm7bin; then " \
-				"run runm7bin; " \
-			"fi; " \
 			"if run loadbootscript; then " \
+				"run set_white_flashing_led; " \
 				"run bootscript; " \
+			"fi; " \
+			"if test -n \"$usb_flash_wanted\"; then " \
+				"run set_white_flashing_led; " \
+				"run try_usb_flash; " \
 			"else " \
 				"if run loadbootenv; then " \
 					"echo Loaded environment from ${bootenv}; " \
 					"run importbootenv; " \
 				"fi;" \
+				"if test ${use_m7} = yes && run loadm7bin; then " \
+					"run runm7bin; " \
+				"fi; " \
 				"if run loadimage; then " \
 					"run mmcboot; " \
 				"else " \
@@ -206,7 +217,7 @@
 #define PHYS_SDRAM			0x40000000
 #define DEFAULT_SDRAM_SIZE		(512 * SZ_1M)
 
-#define CFG_MXC_UART_BASE		UART1_BASE_ADDR
+#define CFG_MXC_UART_BASE		UART3_BASE_ADDR
 
 #define CFG_SYS_FSL_USDHC_NUM	2
 #define CFG_SYS_FSL_ESDHC_ADDR	0
-- 
2.34.1

