From 400be48594f4c05cd4860948225c111140b18099 Mon Sep 17 00:00:00 2001
From: OpenEmbedded <oe.patch@oe>
Date: Mon, 20 Nov 2023 13:18:41 +0100
Subject: [PATCH] tcan4x5x: kernel-6.1-sleep-tcan4x5-on-suspend

WIP: can traffic does not work after wake up.

*** Settings ***

Library		Process
Suite Setup	sshdevice login    dut    ${DUT}
Suite Teardown 	sshdevice close all
Resource    sshdevice.resource

*** Variables ***

${WAKE_ID}	701

*** Test Cases ***

wake on can
	# ${sleeptime_seconds} 	Set Variable 	${20}
	${sleep_cmd} 	Set Variable	RTC=/sys/class/rtc/rtc0/wakealarm; echo 0 > $RTC && sleep 0.5 && echo +${sleeptime_seconds} > $RTC && systemctl suspend
	${wait_time}	Evaluate	${sleeptime_seconds} + 2
	FOR 	${I}	IN RANGE	${LAPS}
		sshdevice call	dut		rm -f /tmp/woke_up
		sshdevice call	dut		${sleep_cmd}
		sshdevice close all

		# Sleep 	${wait_time}
		Sleep 	5

	  ${data}		Evaluate	f"{${I}:016x}"
		Log To Console    ${data}
		Run Process    cansend	can0	${WAKE_ID}#${data}
		${I}	Run Process    /home/mattias/.bin/psu		I
		Log To Console    current is ${I.stdout}

		Wait Until Keyword Succeeds	${wait_time} sec    1 sec	sshdevice login    dut    ${DUT}
		sshdevice call    dut    stat /tmp/woke_up
		Log To Console  /tmp/woke_up exists
	END
---
 drivers/net/can/m_can/m_can.c         |  8 +++--
 drivers/net/can/m_can/tcan4x5x-core.c | 44 +++++++++++++++++++++------
 2 files changed, 40 insertions(+), 12 deletions(-)

diff --git a/drivers/net/can/m_can/m_can.c b/drivers/net/can/m_can/m_can.c
index c8723318f6dd..821431a5a144 100644
--- a/drivers/net/can/m_can/m_can.c
+++ b/drivers/net/can/m_can/m_can.c
@@ -1224,15 +1224,17 @@ static irqreturn_t m_can_isr(int irq, void *dev_id)
 
 	ir = m_can_read(cdev, M_CAN_IR);
 	m_can_coalescing_update(cdev, ir);
+
+	/* There may be interrupts outside the m_can core even if ir == 0 */
+	if (cdev->ops->clear_interrupts)
+		cdev->ops->clear_interrupts(cdev);
+
 	if (!ir)
 		return IRQ_NONE;
 
 	/* ACK all irqs */
 	m_can_write(cdev, M_CAN_IR, ir);
 
-	if (cdev->ops->clear_interrupts)
-		cdev->ops->clear_interrupts(cdev);
-
 	/* schedule NAPI in case of
 	 * - rx IRQ
 	 * - state change IRQ
diff --git a/drivers/net/can/m_can/tcan4x5x-core.c b/drivers/net/can/m_can/tcan4x5x-core.c
index f596e35fbdb7..c71a900ea382 100644
--- a/drivers/net/can/m_can/tcan4x5x-core.c
+++ b/drivers/net/can/m_can/tcan4x5x-core.c
@@ -318,19 +318,22 @@ static const struct tcan4x5x_version_info
 	return &tcan4x5x_versions[TCAN4X5X];
 }
 
+static struct gpio_desc *global_device_wake_gpio = NULL;
+
 static int tcan4x5x_get_gpios(struct m_can_classdev *cdev,
 			      const struct tcan4x5x_version_info *version_info)
 {
 	struct tcan4x5x_priv *tcan4x5x = cdev_to_priv(cdev);
 	int ret;
 
-	if (version_info->has_wake_pin) {
-		tcan4x5x->device_wake_gpio = devm_gpiod_get(cdev->dev, "device-wake",
+	if (version_info->has_wake_pin && !global_device_wake_gpio) {
+		global_device_wake_gpio = devm_gpiod_get(cdev->dev, "device-wake",
 							    GPIOD_OUT_HIGH);
-		if (IS_ERR(tcan4x5x->device_wake_gpio)) {
-			if (PTR_ERR(tcan4x5x->device_wake_gpio) == -EPROBE_DEFER)
+		if (IS_ERR(global_device_wake_gpio)) {
+			if (PTR_ERR(global_device_wake_gpio) == -EPROBE_DEFER)
 				return -EPROBE_DEFER;
 
+			global_device_wake_gpio = NULL;
 			tcan4x5x_disable_wake(cdev);
 		}
 	}
@@ -500,22 +503,45 @@ static void tcan4x5x_can_remove(struct spi_device *spi)
 
 static int __maybe_unused tcan4x5x_suspend(struct device *dev)
 {
+	int ret;
 	struct spi_device *spi = to_spi_device(dev);
+	struct tcan4x5x_priv *priv = spi_get_drvdata(spi);
 
 	if (device_may_wakeup(dev)) {
 		enable_irq_wake(spi->irq);
-
-		return m_can_class_suspend(dev, true);
+		/* Set is wake source to false since we are going to sleep mode with the chip partly turned off*/
+		ret = m_can_class_suspend(dev, false);
+		dev_info(dev, "set wake to false m_can_class_suspend returned %d\n",ret);
+		regmap_update_bits(priv->regmap, TCAN4X5X_CONFIG,
+			TCAN4X5X_MODE_SEL_MASK, TCAN4X5X_MODE_SLEEP);
+	} else {
+		ret = m_can_class_suspend(dev, false);
+		dev_info(dev, "no3 no wake m_can_class_suspend returned %d\n",ret);
 	}
 
-	return m_can_class_suspend(dev, false);
+	return ret;
+
 }
 
 static int __maybe_unused tcan4x5x_resume(struct device *dev)
 {
+	int ret;
+	bool wake_source;
 	struct spi_device *spi = to_spi_device(dev);
-	bool wake_source = device_may_wakeup(dev);
-	int ret = m_can_class_resume(dev, wake_source);
+	struct tcan4x5x_priv *priv = spi_get_drvdata(spi);
+	if (global_device_wake_gpio) {
+		dev_info(dev, "RESUME WAKE UP using %pB \n", global_device_wake_gpio);
+		gpiod_set_value(global_device_wake_gpio, 0);
+		usleep_range(5000, 50000);
+		gpiod_set_value(global_device_wake_gpio, 1);
+	} else {
+		dev_warn(dev, "NO WaKE UP DEFINED %pB \n", global_device_wake_gpio);
+	}
+	
+
+	wake_source = device_may_wakeup(dev);
+	wake_source = FALSE;
+	ret = m_can_class_resume(dev, wake_source);
 
 	if (wake_source)
 		disable_irq_wake(spi->irq);
-- 
2.30.2

